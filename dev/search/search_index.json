{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DaMiao Motor","text":"<p>Safety</p> <p>Commands can move hardware immediately. Use a secure setup and keep clear of moving parts.</p>","tags":["getting-started","overview"]},{"location":"#what-you-can-do","title":"What you can do","text":"<ul> <li>CLI Tools</li> </ul> <p>Use <code>damiao</code> commands to scan, command, and configure motors.</p> <ul> <li>Web GUI</li> </ul> <p>Monitor live position, velocity, torque, and edit writable registers.</p> <ul> <li>Python API</li> </ul> <p>Build robust control loops and automate multi-motor workflows.</p> <ul> <li>Motor Control Modes</li> </ul> <p>Understand MIT, POS_VEL, VEL, and FORCE_POS behavior in detail.</p>","tags":["getting-started","overview"]},{"location":"#control-laws-preview","title":"Control laws preview","text":"<p>The MIT mode combines position error, velocity error, and feedforward torque:</p> <pre><code>T_ref  = Kp * (p_des - theta_m) + Kd * (v_des - dtheta_m) + tau_ff\niq_ref = T_ref / K_T\nid_ref = 0\n</code></pre> <p>See all control law diagrams:</p> <ul> <li>MIT mode</li> <li>POS_VEL mode</li> <li>VEL mode</li> <li>FORCE_POS mode</li> </ul>","tags":["getting-started","overview"]},{"location":"#installation","title":"Installation","text":"","tags":["getting-started","overview"]},{"location":"#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install damiao-motor\n</code></pre>","tags":["getting-started","overview"]},{"location":"#install-from-source","title":"Install from source","text":"<p>For latest repository updates:</p> <pre><code>git clone https://github.com/jia-xie/python-damiao-driver.git\ncd python-damiao-driver\npip install -e .\n</code></pre>","tags":["getting-started","overview"]},{"location":"#verify-installation","title":"Verify Installation","text":"<pre><code>python -c \"import damiao_motor; print(damiao_motor.__version__)\"\n</code></pre> <p>Then verify CLI availability:</p> <pre><code>damiao --help\n</code></pre>","tags":["getting-started","overview"]},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Hardware Setup - CAN interface setup</li> <li>Package Tools - Using the CLI tools</li> </ul>","tags":["getting-started","overview"]},{"location":"api/controller/","title":"DaMiaoController","text":"","tags":["api","reference","core"]},{"location":"api/controller/#damiao_motor.core.controller.DaMiaoController","title":"damiao_motor.core.controller.DaMiaoController","text":"<pre><code>DaMiaoController(channel: str = 'can0', bustype: str = 'socketcan')\n</code></pre> <p>Simple multi-motor controller.</p> <ul> <li>Owns a single CAN bus.</li> <li>Manages multiple DaMiaoMotor instances on that bus.</li> <li>Automatically polls feedback in background when motors are present.</li> <li>Provides helper methods to:<ul> <li>enable/disable all motors</li> <li>send commands to one or all motors</li> <li>poll feedback non-blockingly</li> </ul> </li> </ul> Source code in <code>damiao_motor/core/controller.py</code> <pre><code>def __init__(self, channel: str = \"can0\", bustype: str = \"socketcan\") -&gt; None:\n    self.bus: can.Bus = can.interface.Bus(channel=channel, bustype=bustype)\n    # Keyed by command CAN ID (motor_id)\n    self.motors: Dict[int, DaMiaoMotor] = {}\n    # Keyed by logical motor ID (embedded in feedback frame)\n    self._motors_by_feedback: Dict[int, DaMiaoMotor] = {}\n    # Background polling thread\n    self._polling_thread: Optional[threading.Thread] = None\n    self._polling_active = False\n    self._polling_lock = threading.Lock()\n</code></pre>","tags":["api","reference","core"]},{"location":"api/controller/#damiao_motor.core.controller.DaMiaoController.flush_bus","title":"flush_bus","text":"<pre><code>flush_bus() -&gt; int\n</code></pre> <p>Flush all pending messages from the CAN bus buffer.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of messages flushed.</p> <p>Raises:</p> Type Description <code>CanOperationError</code> <p>If CAN interface is down (Error Code 100) with helpful hint</p> <code>OSError</code> <p>If other network/system errors occur</p> Source code in <code>damiao_motor/core/controller.py</code> <pre><code>def flush_bus(self) -&gt; int:\n    \"\"\"\n    Flush all pending messages from the CAN bus buffer.\n\n    Returns:\n        Number of messages flushed.\n\n    Raises:\n        can.CanOperationError: If CAN interface is down (Error Code 100) with helpful hint\n        OSError: If other network/system errors occur\n    \"\"\"\n    count = 0\n    try:\n        while True:\n            msg = self.bus.recv(timeout=0)\n            if msg is None:\n                break\n            count += 1\n    except can.CanOperationError as e:\n        error_str = str(e)\n        errno = getattr(e, \"errno\", None)\n\n        # Error Code 100: Network is down - CAN interface not up\n        if (\n            errno == 100\n            or \"Error Code 100\" in error_str\n            or \"Network is down\" in error_str\n            or \"[Errno 100]\" in error_str\n        ):\n            channel = getattr(self.bus, \"channel\", \"can0\")\n            raise can.CanOperationError(\n                f\"CAN interface '{channel}' is down (Error Code 100)\"\n            ) from e\n        # Re-raise other CanOperationError\n        raise\n    except OSError as e:\n        errno = getattr(e, \"errno\", None)\n        if errno == 100 or \"Network is down\" in str(e) or \"[Errno 100]\" in str(e):\n            channel = getattr(self.bus, \"channel\", \"can0\")\n            raise OSError(\n                f\"CAN interface '{channel}' is down (Error Code 100)\"\n            ) from e\n        raise\n    return count\n</code></pre>","tags":["api","reference","core"]},{"location":"api/controller/#damiao_motor.core.controller.DaMiaoController.poll_feedback","title":"poll_feedback","text":"<pre><code>poll_feedback() -&gt; None\n</code></pre> <p>Non-blocking read of all pending CAN frames on this bus, and dispatch feedback frames to the corresponding motors.</p> Source code in <code>damiao_motor/core/controller.py</code> <pre><code>def poll_feedback(self) -&gt; None:\n    \"\"\"\n    Non-blocking read of all pending CAN frames on this bus, and dispatch\n    feedback frames to the corresponding motors.\n    \"\"\"\n    try:\n        while True:\n            msg = self.bus.recv(timeout=0)\n            if msg is None:\n                break\n\n            if len(msg.data) != 8:\n                continue\n\n            # Feedback messages include the logical motor ID in the low 4 bits\n            # of the first data byte. Use that to route feedback to the right motor.\n            logical_id = msg.data[0] &amp; 0x0F\n            motor = self._motors_by_feedback.get(logical_id)\n            if motor is None:\n                continue\n\n            motor.process_feedback_frame(\n                bytes(msg.data), arbitration_id=msg.arbitration_id\n            )\n    except (ValueError, OSError, AttributeError):\n        # Bus is closed or invalid, stop polling\n        with self._polling_lock:\n            self._polling_active = False\n</code></pre>","tags":["api","reference","core"]},{"location":"api/controller/#damiao_motor.core.controller.DaMiaoController.send_cmd","title":"send_cmd","text":"<pre><code>send_cmd(motor_id: int, target_position: float = 0.0, target_velocity: float = 0.0, stiffness: float = 0.0, damping: float = 0.0, feedforward_torque: float = 0.0) -&gt; None\n</code></pre> <p>Send MIT mode command to a specific motor (convenience method).</p> Source code in <code>damiao_motor/core/controller.py</code> <pre><code>def send_cmd(\n    self,\n    motor_id: int,\n    target_position: float = 0.0,\n    target_velocity: float = 0.0,\n    stiffness: float = 0.0,\n    damping: float = 0.0,\n    feedforward_torque: float = 0.0,\n) -&gt; None:\n    \"\"\"Send MIT mode command to a specific motor (convenience method).\"\"\"\n    self.get_motor(motor_id).send_cmd_mit(\n        target_position=target_position,\n        target_velocity=target_velocity,\n        stiffness=stiffness,\n        damping=damping,\n        feedforward_torque=feedforward_torque,\n    )\n</code></pre>","tags":["api","reference","core"]},{"location":"api/controller/#damiao_motor.core.controller.DaMiaoController.send_cmd_all","title":"send_cmd_all","text":"<pre><code>send_cmd_all(target_position: float = 0.0, target_velocity: float = 0.0, stiffness: float = 0.0, damping: float = 0.0, feedforward_torque: float = 0.0) -&gt; None\n</code></pre> <p>Send MIT mode command to all motors (convenience method).</p> Source code in <code>damiao_motor/core/controller.py</code> <pre><code>def send_cmd_all(\n    self,\n    target_position: float = 0.0,\n    target_velocity: float = 0.0,\n    stiffness: float = 0.0,\n    damping: float = 0.0,\n    feedforward_torque: float = 0.0,\n) -&gt; None:\n    \"\"\"Send MIT mode command to all motors (convenience method).\"\"\"\n    for m in self.all_motors():\n        m.send_cmd_mit(\n            target_position=target_position,\n            target_velocity=target_velocity,\n            stiffness=stiffness,\n            damping=damping,\n            feedforward_torque=feedforward_torque,\n        )\n</code></pre>","tags":["api","reference","core"]},{"location":"api/controller/#damiao_motor.core.controller.DaMiaoController.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Shutdown the controller and stop background polling.</p> Source code in <code>damiao_motor/core/controller.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shutdown the controller and stop background polling.\"\"\"\n    self._stop_polling()\n    self.disable_all()\n    self.bus.shutdown()\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/","title":"DaMiaoMotor","text":"","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor","title":"damiao_motor.core.motor.DaMiaoMotor","text":"<pre><code>DaMiaoMotor(motor_id: int, feedback_id: int, bus: can.Bus, *, motor_type: str, p_min: Optional[float] = None, p_max: Optional[float] = None, v_min: Optional[float] = None, v_max: Optional[float] = None, t_min: Optional[float] = None, t_max: Optional[float] = None)\n</code></pre> <p>Lightweight DaMiao motor wrapper over a CAN bus.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def __init__(\n    self,\n    motor_id: int,\n    feedback_id: int,\n    bus: can.Bus,\n    *,\n    motor_type: str,\n    p_min: Optional[float] = None,\n    p_max: Optional[float] = None,\n    v_min: Optional[float] = None,\n    v_max: Optional[float] = None,\n    t_min: Optional[float] = None,\n    t_max: Optional[float] = None,\n) -&gt; None:\n    self.motor_id = motor_id\n    self.feedback_id = feedback_id\n    self.bus = bus\n\n    # Resolve P/V/T limits from motor_type preset + optional overrides. kp and kd use fixed KP_MIN/KP_MAX, KD_MIN/KD_MAX.\n    base = self._resolve_limits(motor_type)\n    overrides = {\n        k: v\n        for k, v in (\n            (\"p_min\", p_min),\n            (\"p_max\", p_max),\n            (\"v_min\", v_min),\n            (\"v_max\", v_max),\n            (\"t_min\", t_min),\n            (\"t_max\", t_max),\n        )\n        if v is not None\n    }\n    base.update(overrides)\n    for k in _LIMITS_KEYS:\n        setattr(self, f\"_{k}\", base[k])\n\n    self.motor_type = motor_type\n\n    # last decoded feedback\n    self.state: Dict[str, Any] = {}\n    self.state_lock = threading.Lock()\n\n    # last register values\n    self.registers: Dict[int, float | int] = {}\n    self.registers_lock = threading.Lock()\n    self.register_request_time: Dict[int, float] = {}\n    self.register_request_time_lock = threading.Lock()\n    self.register_reply_time: Dict[int, float] = {}\n    self.register_reply_time_lock = threading.Lock()\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.clear_error","title":"clear_error","text":"<pre><code>clear_error() -&gt; None\n</code></pre> <p>Clear motor errors (e.g., overheating).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def clear_error(self) -&gt; None:\n    \"\"\"Clear motor errors (e.g., overheating).\"\"\"\n    self.send_raw(self.encode_clear_error_msg())\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.encode_clear_error_msg","title":"encode_clear_error_msg  <code>staticmethod</code>","text":"<pre><code>encode_clear_error_msg() -&gt; bytes\n</code></pre> <p>Encode clear error command (clears motor errors like overheating).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>@staticmethod\ndef encode_clear_error_msg() -&gt; bytes:\n    \"\"\"Encode clear error command (clears motor errors like overheating).\"\"\"\n    return bytes([0xFF] * 7 + [0xFB])\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.encode_cmd_msg","title":"encode_cmd_msg","text":"<pre><code>encode_cmd_msg(pos: float, vel: float, torq: float, kp: float, kd: float) -&gt; bytes\n</code></pre> <p>Encode a command to CAN frame for sending to the motor. Uses this motor's P/V/T limits (from motor_type preset) and fixed kp (KP_MIN/KP_MAX), kd (KD_MIN/KD_MAX).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def encode_cmd_msg(\n    self, pos: float, vel: float, torq: float, kp: float, kd: float\n) -&gt; bytes:\n    \"\"\"\n    Encode a command to CAN frame for sending to the motor.\n    Uses this motor's P/V/T limits (from motor_type preset) and fixed kp (KP_MIN/KP_MAX), kd (KD_MIN/KD_MAX).\n    \"\"\"\n    pos_u = float_to_uint(pos, self._p_min, self._p_max, 16)\n    vel_u = float_to_uint(vel, self._v_min, self._v_max, 12)\n    kp_u = float_to_uint(kp, KP_MIN, KP_MAX, 12)\n    kd_u = float_to_uint(kd, KD_MIN, KD_MAX, 12)\n    torq_u = float_to_uint(torq, self._t_min, self._t_max, 12)\n\n    data = [\n        (pos_u &gt;&gt; 8) &amp; 0xFF,\n        pos_u &amp; 0xFF,\n        (vel_u &gt;&gt; 4) &amp; 0xFF,\n        ((vel_u &amp; 0xF) &lt;&lt; 4) | ((kp_u &gt;&gt; 8) &amp; 0xF),\n        kp_u &amp; 0xFF,\n        (kd_u &gt;&gt; 4) &amp; 0xFF,\n        ((kd_u &amp; 0xF) &lt;&lt; 4) | ((torq_u &gt;&gt; 8) &amp; 0xF),\n        torq_u &amp; 0xFF,\n    ]\n    return bytes(data)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.encode_save_position_zero_msg","title":"encode_save_position_zero_msg  <code>staticmethod</code>","text":"<pre><code>encode_save_position_zero_msg() -&gt; bytes\n</code></pre> <p>Encode save position zero command (sets current position to zero).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>@staticmethod\ndef encode_save_position_zero_msg() -&gt; bytes:\n    \"\"\"Encode save position zero command (sets current position to zero).\"\"\"\n    return bytes([0xFF] * 7 + [0xFE])\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.ensure_control_mode","title":"ensure_control_mode","text":"<pre><code>ensure_control_mode(control_mode: str) -&gt; None\n</code></pre> <p>Ensure control mode (register 10) matches the desired mode. Reads register 10; if it differs, writes and verifies.</p> <p>Parameters:</p> Name Type Description Default <code>control_mode</code> <code>str</code> <p>\"MIT\", \"POS_VEL\", \"VEL\", or \"FORCE_POS\"</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If control_mode is invalid or register value is invalid</p> <code>TimeoutError</code> <p>If reading/writing register times out</p> <code>RuntimeError</code> <p>Other errors during register operations, or if verification after write fails</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def ensure_control_mode(self, control_mode: str) -&gt; None:\n    \"\"\"\n    Ensure control mode (register 10) matches the desired mode.\n    Reads register 10; if it differs, writes and verifies.\n\n    Args:\n        control_mode: \"MIT\", \"POS_VEL\", \"VEL\", or \"FORCE_POS\"\n\n    Raises:\n        ValueError: If control_mode is invalid or register value is invalid\n        TimeoutError: If reading/writing register times out\n        RuntimeError: Other errors during register operations, or if verification after write fails\n    \"\"\"\n    mode_to_register = {\"MIT\": 1, \"POS_VEL\": 2, \"VEL\": 3, \"FORCE_POS\": 4}\n    if control_mode not in mode_to_register:\n        raise ValueError(\n            f\"Invalid control_mode: {control_mode}. Must be one of {list(mode_to_register.keys())}\"\n        )\n    desired = mode_to_register[control_mode]\n\n    try:\n        current = int(self.get_register(10, timeout=1.0))\n        if current == desired:\n            return\n        print(\n            f\"\u26a0 Control mode mismatch: register 10 = {current}, required = {desired}\"\n        )\n        print(\n            f\"  Setting control mode to {control_mode} (register value: {desired})...\"\n        )\n        self.write_register(10, desired)\n        time.sleep(0.1)\n        verify = int(self.get_register(10, timeout=1.0))\n        if verify != desired:\n            raise RuntimeError(\n                f\"Control mode verification failed after write: expected {desired}, got {verify}\"\n            )\n        print(f\"\u2713 Control mode set to {control_mode}\")\n    except TimeoutError as e:\n        raise TimeoutError(\n            f\"Timeout while checking/setting control mode (register 10): {e}\"\n        ) from e\n    except ValueError as e:\n        raise ValueError(f\"Invalid control mode value in register 10: {e}\") from e\n    except RuntimeError:\n        raise  # verification failure, preserve message\n    except Exception as e:\n        raise RuntimeError(f\"Error checking/setting control mode: {e}\") from e\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.get_register","title":"get_register","text":"<pre><code>get_register(rid: int, timeout: float = 1.0) -&gt; float | int\n</code></pre> <p>Read a register value from the motor.</p> <p>If the value is not already cached, sends a read request and waits for the controller's background polling to receive the reply. The motor never reads from the bus; only the controller's poll_feedback does, avoiding multiple consumers.</p> <p>Requires the motor to be managed by a DaMiaoController (added via controller.add_motor). Standalone motors can only return cached values.</p> <p>Parameters:</p> Name Type Description Default <code>rid</code> <code>int</code> <p>Register ID (0-81)</p> required <code>timeout</code> <code>float</code> <p>Timeout in seconds to wait for response</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float | int</code> <p>Register value as float or int depending on register data type</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If register ID is not in the register table</p> <code>RuntimeError</code> <p>If the motor is not managed by a controller (no background polling)</p> <code>TimeoutError</code> <p>If the register reply was not received within timeout</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def get_register(self, rid: int, timeout: float = 1.0) -&gt; float | int:\n    \"\"\"\n    Read a register value from the motor.\n\n    If the value is not already cached, sends a read request and waits for the\n    controller's background polling to receive the reply. The motor never\n    reads from the bus; only the controller's poll_feedback does, avoiding\n    multiple consumers.\n\n    Requires the motor to be managed by a DaMiaoController (added via\n    controller.add_motor). Standalone motors can only return cached values.\n\n    Args:\n        rid: Register ID (0-81)\n        timeout: Timeout in seconds to wait for response\n\n    Returns:\n        Register value as float or int depending on register data type\n\n    Raises:\n        KeyError: If register ID is not in the register table\n        RuntimeError: If the motor is not managed by a controller (no background polling)\n        TimeoutError: If the register reply was not received within timeout\n    \"\"\"\n    if rid not in REGISTER_TABLE:\n        raise KeyError(f\"Register {rid} not found in register table\")\n    with self.registers_lock:\n        if rid in self.registers:\n            return self.registers[rid]\n    if getattr(self, \"_controller\", None) is None:\n        raise RuntimeError(\n            \"get_register requires the motor to be managed by a DaMiaoController \"\n            \"(added via controller.add_motor). The controller's background polling \"\n            \"is the only bus reader; standalone motors cannot block-wait for register replies.\"\n        )\n    self.request_register_reading(rid)\n    deadline = time.time() + timeout\n    while True:\n        with self.registers_lock:\n            if rid in self.registers:\n                return self.registers[rid]\n        if time.time() &gt;= deadline:\n            raise TimeoutError(f\"Register {rid} not received within {timeout}s\")\n        time.sleep(0.01)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.get_register_info","title":"get_register_info","text":"<pre><code>get_register_info(rid: int) -&gt; RegisterInfo\n</code></pre> <p>Get information about a register.</p> <p>Parameters:</p> Name Type Description Default <code>rid</code> <code>int</code> <p>Register ID</p> required <p>Returns:</p> Type Description <code>RegisterInfo</code> <p>RegisterInfo object with register details</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If register ID is not in the register table</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def get_register_info(self, rid: int) -&gt; RegisterInfo:\n    \"\"\"\n    Get information about a register.\n\n    Args:\n        rid: Register ID\n\n    Returns:\n        RegisterInfo object with register details\n\n    Raises:\n        KeyError: If register ID is not in the register table\n    \"\"\"\n    if rid not in REGISTER_TABLE:\n        raise KeyError(f\"Register {rid} not found in register table\")\n    return REGISTER_TABLE[rid]\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.get_states","title":"get_states","text":"<pre><code>get_states() -&gt; Dict[str, Any]\n</code></pre> <p>Get the current motor state dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing current motor state information:</p> <code>Dict[str, Any]</code> <ul> <li>can_id: CAN ID</li> </ul> <code>Dict[str, Any]</code> <ul> <li>status: Human-readable status name</li> </ul> <code>Dict[str, Any]</code> <ul> <li>status_code: Status code</li> </ul> <code>Dict[str, Any]</code> <ul> <li>pos: Position</li> </ul> <code>Dict[str, Any]</code> <ul> <li>vel: Velocity</li> </ul> <code>Dict[str, Any]</code> <ul> <li>torq: Torque</li> </ul> <code>Dict[str, Any]</code> <ul> <li>t_mos: MOSFET temperature</li> </ul> <code>Dict[str, Any]</code> <ul> <li>t_rotor: Rotor temperature</li> </ul> <code>Dict[str, Any]</code> <ul> <li>arbitration_id: CAN arbitration ID</li> </ul> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def get_states(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the current motor state dictionary.\n\n    Returns:\n        Dictionary containing current motor state information:\n        - can_id: CAN ID\n        - status: Human-readable status name\n        - status_code: Status code\n        - pos: Position\n        - vel: Velocity\n        - torq: Torque\n        - t_mos: MOSFET temperature\n        - t_rotor: Rotor temperature\n        - arbitration_id: CAN arbitration ID\n    \"\"\"\n    return self.state.copy() if self.state else {}\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.read_all_registers","title":"read_all_registers","text":"<pre><code>read_all_registers(timeout: float = 0.05) -&gt; Dict[int, float | int]\n</code></pre> <p>Read all registers from the motor.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Timeout in seconds per register read</p> <code>0.05</code> <p>Returns:</p> Type Description <code>Dict[int, float | int]</code> <p>Dictionary mapping register ID to value</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def read_all_registers(self, timeout: float = 0.05) -&gt; Dict[int, float | int]:\n    \"\"\"\n    Read all registers from the motor.\n\n    Args:\n        timeout: Timeout in seconds per register read\n\n    Returns:\n        Dictionary mapping register ID to value\n    \"\"\"\n    for rid, reg_info in REGISTER_TABLE.items():\n        if reg_info.access in [\"RO\", \"RW\"]:  # Readable registers\n            self.request_register_reading(rid)\n            time.sleep(0.0005)\n    results: Dict[int, float | int] = {}\n    time.sleep(0.01)  # wait for the replies\n    for rid, reg_info in REGISTER_TABLE.items():\n        if reg_info.access in [\"RO\", \"RW\"]:  # Readable registers\n            try:\n                results[rid] = self.get_register(rid, timeout=timeout)\n            except (TimeoutError, KeyError, ValueError, RuntimeError) as e:\n                # Store error as string for debugging\n                results[rid] = f\"ERROR: {e}\"\n    return results\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.request_motor_feedback","title":"request_motor_feedback","text":"<pre><code>request_motor_feedback() -&gt; None\n</code></pre> <p>Request motor feedback/status information. After successful transmission, the motor driver will return current status information.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def request_motor_feedback(self) -&gt; None:\n    \"\"\"\n    Request motor feedback/status information.\n    After successful transmission, the motor driver will return current status information.\n    \"\"\"\n    canid_l, canid_h = self._encode_can_id(self.motor_id)\n    msg_data = bytes([canid_l, canid_h, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00])\n    self.send_raw(msg_data, arbitration_id=0x7FF)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.request_register_reading","title":"request_register_reading","text":"<pre><code>request_register_reading(rid: int) -&gt; None\n</code></pre> <p>Request a register reading from the motor.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def request_register_reading(self, rid: int) -&gt; None:\n    \"\"\"\n    Request a register reading from the motor.\n    \"\"\"\n    with self.register_request_time_lock:\n        self.register_request_time[rid] = time.perf_counter()\n    self._send_register_cmd(0x33, rid)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.send_cmd","title":"send_cmd","text":"<pre><code>send_cmd(target_position: float = 0.0, target_velocity: float = 0.0, stiffness: float = 0.0, damping: float = 0.0, feedforward_torque: float = 0.0, control_mode: str = 'MIT', velocity_limit: float = 0.0, torque_limit_ratio: float = 0.0) -&gt; None\n</code></pre> <p>Send command to motor with specified control mode (convenience wrapper).</p> <p>This method is a convenience wrapper that calls the appropriate mode-specific method. For better type safety and clarity, consider using the mode-specific methods directly: - <code>send_cmd_mit()</code> for MIT mode - <code>send_cmd_pos_vel()</code> for POS_VEL mode - <code>send_cmd_vel()</code> for VEL mode - <code>send_cmd_force_pos()</code> for FORCE_POS mode</p> <p>Parameters:</p> Name Type Description Default <code>target_position</code> <code>float</code> <p>Desired position (radians)</p> <code>0.0</code> <code>target_velocity</code> <code>float</code> <p>Desired velocity (rad/s) for MIT and VEL modes</p> <code>0.0</code> <code>stiffness</code> <code>float</code> <p>Stiffness (kp) for MIT mode</p> <code>0.0</code> <code>damping</code> <code>float</code> <p>Damping (kd) for MIT mode</p> <code>0.0</code> <code>feedforward_torque</code> <code>float</code> <p>Feedforward torque for MIT mode</p> <code>0.0</code> <code>control_mode</code> <code>str</code> <p>Control mode - \"MIT\" (default), \"POS_VEL\", \"VEL\", or \"FORCE_POS\"</p> <code>'MIT'</code> <code>velocity_limit</code> <code>float</code> <p>Velocity limit. Used as max speed for POS_VEL and as clipped limit (0-100 rad/s) for FORCE_POS</p> <code>0.0</code> <code>torque_limit_ratio</code> <code>float</code> <p>Normalized torque-limit coefficient (0.0-1.0) for FORCE_POS mode. Effective torque clip: tau_lim = torque_limit_ratio * T_max(motor_type).</p> <code>0.0</code> Note <p>Before using this method to send commands, ensure that the motor's control mode register (register 10) is set to match the desired control_mode argument (\"MIT\", \"POS_VEL\", \"VEL\", or \"FORCE_POS\"). If the register does not match, the motor will not respond to commands and will not move.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def send_cmd(\n    self,\n    target_position: float = 0.0,\n    target_velocity: float = 0.0,\n    stiffness: float = 0.0,\n    damping: float = 0.0,\n    feedforward_torque: float = 0.0,\n    control_mode: str = \"MIT\",\n    velocity_limit: float = 0.0,\n    torque_limit_ratio: float = 0.0,\n) -&gt; None:\n    \"\"\"\n    Send command to motor with specified control mode (convenience wrapper).\n\n    This method is a convenience wrapper that calls the appropriate mode-specific method.\n    For better type safety and clarity, consider using the mode-specific methods directly:\n    - `send_cmd_mit()` for MIT mode\n    - `send_cmd_pos_vel()` for POS_VEL mode\n    - `send_cmd_vel()` for VEL mode\n    - `send_cmd_force_pos()` for FORCE_POS mode\n\n    Args:\n        target_position: Desired position (radians)\n        target_velocity: Desired velocity (rad/s) for MIT and VEL modes\n        stiffness: Stiffness (kp) for MIT mode\n        damping: Damping (kd) for MIT mode\n        feedforward_torque: Feedforward torque for MIT mode\n        control_mode: Control mode - \"MIT\" (default), \"POS_VEL\", \"VEL\", or \"FORCE_POS\"\n        velocity_limit: Velocity limit. Used as max speed for POS_VEL and as clipped limit (0-100 rad/s) for FORCE_POS\n        torque_limit_ratio: Normalized torque-limit coefficient (0.0-1.0) for\n            FORCE_POS mode. Effective torque clip:\n            tau_lim = torque_limit_ratio * T_max(motor_type).\n\n    Note:\n        Before using this method to send commands, ensure that the motor's control mode register (register 10)\n        is set to match the desired control_mode argument (\"MIT\", \"POS_VEL\", \"VEL\", or \"FORCE_POS\").\n        If the register does not match, the motor will not respond to commands and will not move.\n    \"\"\"\n    if control_mode == \"MIT\":\n        self.send_cmd_mit(\n            target_position, target_velocity, stiffness, damping, feedforward_torque\n        )\n    elif control_mode == \"POS_VEL\":\n        self.send_cmd_pos_vel(target_position, velocity_limit)\n    elif control_mode == \"VEL\":\n        self.send_cmd_vel(target_velocity)\n    elif control_mode == \"FORCE_POS\":\n        self.send_cmd_force_pos(target_position, velocity_limit, torque_limit_ratio)\n    else:\n        raise ValueError(\n            f\"Unknown control_mode: {control_mode}. Must be 'MIT', 'POS_VEL', 'VEL', or 'FORCE_POS'\"\n        )\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.send_cmd_force_pos","title":"send_cmd_force_pos","text":"<pre><code>send_cmd_force_pos(target_position: float = 0.0, velocity_limit: float = 0.0, torque_limit_ratio: float = 0.0) -&gt; None\n</code></pre> <p>Send FORCE_POS (Force Position) control command.</p> <p>Parameters:</p> Name Type Description Default <code>target_position</code> <code>float</code> <p>Desired position (radians)</p> <code>0.0</code> <code>velocity_limit</code> <code>float</code> <p>Velocity limit (rad/s, 0-100) for FORCE_POS mode</p> <code>0.0</code> <code>torque_limit_ratio</code> <code>float</code> <p>Normalized torque-limit coefficient for FORCE_POS mode. The effective torque clip is: tau_lim = torque_limit_ratio * T_max(motor_type) where T_max comes from the selected motor_type preset. Example: for motor_type \"4340\", T_max=28 Nm, so torque_limit_ratio=0.5 gives tau_lim=14 Nm.</p> <code>0.0</code> Note <p>Before using this method, ensure that the motor's control mode register (register 10) is set to FORCE_POS mode (value 4). Use <code>ensure_control_mode(\"FORCE_POS\")</code> or <code>set_control_mode(4)</code>.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def send_cmd_force_pos(\n    self,\n    target_position: float = 0.0,\n    velocity_limit: float = 0.0,\n    torque_limit_ratio: float = 0.0,\n) -&gt; None:\n    \"\"\"\n    Send FORCE_POS (Force Position) control command.\n\n    Args:\n        target_position: Desired position (radians)\n        velocity_limit: Velocity limit (rad/s, 0-100) for FORCE_POS mode\n        torque_limit_ratio: Normalized torque-limit coefficient for FORCE_POS mode.\n            The effective torque clip is:\n            tau_lim = torque_limit_ratio * T_max(motor_type)\n            where T_max comes from the selected motor_type preset.\n            Example: for motor_type \"4340\", T_max=28 Nm, so torque_limit_ratio=0.5\n            gives tau_lim=14 Nm.\n\n    Note:\n        Before using this method, ensure that the motor's control mode register (register 10)\n        is set to FORCE_POS mode (value 4). Use `ensure_control_mode(\"FORCE_POS\")` or `set_control_mode(4)`.\n    \"\"\"\n    self._check_motor_status()\n    # FORCE_POS Mode: CAN ID 0x300 + motor_id\n    # Clamp and scale velocity limit (0-100 rad/s -&gt; 0-10000)\n    v_des_clamped = max(0.0, min(100.0, velocity_limit))\n    v_des_scaled = int(v_des_clamped * 100)\n    v_des_scaled = min(10000, v_des_scaled)\n\n    # Clamp and scale torque limit ratio (0.0-1.0 -&gt; 0-10000)\n    i_des_clamped = max(0.0, min(1.0, torque_limit_ratio))\n    i_des_scaled = int(i_des_clamped * 10000)\n    i_des_scaled = min(10000, i_des_scaled)\n\n    # Pack: float (4 bytes) + uint16 (2 bytes) + uint16 (2 bytes)\n    data = struct.pack(\"&lt;fHH\", target_position, v_des_scaled, i_des_scaled)\n    arbitration_id = 0x300 + self.motor_id\n    self.send_raw(data, arbitration_id=arbitration_id)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.send_cmd_mit","title":"send_cmd_mit","text":"<pre><code>send_cmd_mit(target_position: float = 0.0, target_velocity: float = 0.0, stiffness: float = 0.0, damping: float = 0.0, feedforward_torque: float = 0.0) -&gt; None\n</code></pre> <p>Send MIT (Position + Velocity + Torque) control command.</p> <p>Parameters:</p> Name Type Description Default <code>target_position</code> <code>float</code> <p>Desired position (radians)</p> <code>0.0</code> <code>target_velocity</code> <code>float</code> <p>Desired velocity (rad/s)</p> <code>0.0</code> <code>stiffness</code> <code>float</code> <p>Stiffness (kp) for MIT mode</p> <code>0.0</code> <code>damping</code> <code>float</code> <p>Damping (kd) for MIT mode</p> <code>0.0</code> <code>feedforward_torque</code> <code>float</code> <p>Feedforward torque for MIT mode</p> <code>0.0</code> Note <p>Before using this method, ensure that the motor's control mode register (register 10) is set to MIT mode (value 1). Use <code>ensure_control_mode(\"MIT\")</code> or <code>set_control_mode(1)</code>.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def send_cmd_mit(\n    self,\n    target_position: float = 0.0,\n    target_velocity: float = 0.0,\n    stiffness: float = 0.0,\n    damping: float = 0.0,\n    feedforward_torque: float = 0.0,\n) -&gt; None:\n    \"\"\"\n    Send MIT (Position + Velocity + Torque) control command.\n\n    Args:\n        target_position: Desired position (radians)\n        target_velocity: Desired velocity (rad/s)\n        stiffness: Stiffness (kp) for MIT mode\n        damping: Damping (kd) for MIT mode\n        feedforward_torque: Feedforward torque for MIT mode\n\n    Note:\n        Before using this method, ensure that the motor's control mode register (register 10)\n        is set to MIT mode (value 1). Use `ensure_control_mode(\"MIT\")` or `set_control_mode(1)`.\n    \"\"\"\n    self._check_motor_status()\n    data = self.encode_cmd_msg(\n        target_position, target_velocity, feedforward_torque, stiffness, damping\n    )\n    self.send_raw(data)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.send_cmd_pos_vel","title":"send_cmd_pos_vel","text":"<pre><code>send_cmd_pos_vel(target_position: float = 0.0, velocity_limit: float = 0.0) -&gt; None\n</code></pre> <p>Send POS_VEL (Position + Velocity) control command.</p> <p>Parameters:</p> Name Type Description Default <code>target_position</code> <code>float</code> <p>Desired position (radians)</p> <code>0.0</code> <code>velocity_limit</code> <code>float</code> <p>Maximum velocity during motion (rad/s)</p> <code>0.0</code> Note <p>Before using this method, ensure that the motor's control mode register (register 10) is set to POS_VEL mode (value 2). Use <code>ensure_control_mode(\"POS_VEL\")</code> or <code>set_control_mode(2)</code>.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def send_cmd_pos_vel(\n    self,\n    target_position: float = 0.0,\n    velocity_limit: float = 0.0,\n) -&gt; None:\n    \"\"\"\n    Send POS_VEL (Position + Velocity) control command.\n\n    Args:\n        target_position: Desired position (radians)\n        velocity_limit: Maximum velocity during motion (rad/s)\n\n    Note:\n        Before using this method, ensure that the motor's control mode register (register 10)\n        is set to POS_VEL mode (value 2). Use `ensure_control_mode(\"POS_VEL\")` or `set_control_mode(2)`.\n    \"\"\"\n    self._check_motor_status()\n    # POS_VEL Mode: CAN ID 0x100 + motor_id\n    data = struct.pack(\"&lt;ff\", target_position, velocity_limit)\n    arbitration_id = 0x100 + self.motor_id\n    self.send_raw(data, arbitration_id=arbitration_id)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.send_cmd_vel","title":"send_cmd_vel","text":"<pre><code>send_cmd_vel(target_velocity: float = 0.0) -&gt; None\n</code></pre> <p>Send VEL (Velocity) control command.</p> <p>Parameters:</p> Name Type Description Default <code>target_velocity</code> <code>float</code> <p>Desired velocity (rad/s)</p> <code>0.0</code> Note <p>Before using this method, ensure that the motor's control mode register (register 10) is set to VEL mode (value 3). Use <code>ensure_control_mode(\"VEL\")</code> or <code>set_control_mode(3)</code>.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def send_cmd_vel(\n    self,\n    target_velocity: float = 0.0,\n) -&gt; None:\n    \"\"\"\n    Send VEL (Velocity) control command.\n\n    Args:\n        target_velocity: Desired velocity (rad/s)\n\n    Note:\n        Before using this method, ensure that the motor's control mode register (register 10)\n        is set to VEL mode (value 3). Use `ensure_control_mode(\"VEL\")` or `set_control_mode(3)`.\n    \"\"\"\n    self._check_motor_status()\n    # VEL Mode: CAN ID 0x200 + motor_id\n    data = struct.pack(\"&lt;f\", target_velocity) + b\"\\x00\" * 4\n    arbitration_id = 0x200 + self.motor_id\n    self.send_raw(data, arbitration_id=arbitration_id)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.send_raw","title":"send_raw","text":"<pre><code>send_raw(data: bytes, arbitration_id: int | None = None) -&gt; None\n</code></pre> <p>Send raw CAN message.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>CAN message data bytes (must be 8 bytes)</p> required <code>arbitration_id</code> <code>int | None</code> <p>CAN arbitration ID (defaults to motor_id if not specified)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data is not 8 bytes or arbitration_id is invalid</p> <code>OSError</code> <p>If CAN bus error occurs (e.g., Error Code 105 - No buffer space)</p> <code>CanError</code> <p>If CAN-specific error occurs</p> <code>AttributeError</code> <p>If bus is not initialized</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def send_raw(self, data: bytes, arbitration_id: int | None = None) -&gt; None:\n    \"\"\"\n    Send raw CAN message.\n\n    Args:\n        data: CAN message data bytes (must be 8 bytes)\n        arbitration_id: CAN arbitration ID (defaults to motor_id if not specified)\n\n    Raises:\n        ValueError: If data is not 8 bytes or arbitration_id is invalid\n        OSError: If CAN bus error occurs (e.g., Error Code 105 - No buffer space)\n        can.CanError: If CAN-specific error occurs\n        AttributeError: If bus is not initialized\n    \"\"\"\n    if len(data) != 8:\n        raise ValueError(f\"CAN message data must be 8 bytes, got {len(data)} bytes\")\n\n    if arbitration_id is None:\n        arbitration_id = self.motor_id\n\n    if arbitration_id &lt; 0 or arbitration_id &gt; 0x7FF:\n        raise ValueError(\n            f\"Invalid arbitration_id: {arbitration_id}. Must be in range 0-0x7FF\"\n        )\n\n    try:\n        msg = can.Message(\n            arbitration_id=arbitration_id, data=data, is_extended_id=False\n        )\n        self.bus.send(msg)\n    except OSError as e:\n        error_str = str(e)\n        errno = getattr(e, \"errno\", None)\n\n        # Error Code 105: No buffer space available\n        if (\n            errno == 105\n            or \"Error Code 105\" in error_str\n            or \"No buffer space available\" in error_str\n            or \"[Errno 105]\" in error_str\n        ):\n            raise OSError(\n                f\"CAN bus buffer full (Error Code 105) when sending to arbitration_id 0x{arbitration_id:03X}. \"\n                f\"This typically indicates: no motor connected, motor not powered, or CAN hardware issue. \"\n                f\"Original error: {e}\"\n            ) from e\n        # Other OSError cases\n        raise OSError(\n            f\"CAN bus system error when sending to arbitration_id 0x{arbitration_id:03X}: {e}\"\n        ) from e\n    except can.CanError as e:\n        raise can.CanError(\n            f\"CAN bus error when sending to arbitration_id 0x{arbitration_id:03X}: {e}\"\n        ) from e\n    except AttributeError as e:\n        if \"bus\" in str(e).lower() or \"send\" in str(e).lower():\n            raise AttributeError(\n                \"CAN bus not initialized. Bus may be closed or not connected.\"\n            ) from e\n        raise\n    except Exception as e:\n        raise RuntimeError(\n            f\"Unexpected error sending CAN message to arbitration_id 0x{arbitration_id:03X}: {e}\"\n        ) from e\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_acceleration","title":"set_acceleration","text":"<pre><code>set_acceleration(value: float) -&gt; None\n</code></pre> <p>Set acceleration (register 4).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_acceleration(self, value: float) -&gt; None:\n    \"\"\"Set acceleration (register 4).\"\"\"\n    self.write_register(4, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_can_baud_rate","title":"set_can_baud_rate","text":"<pre><code>set_can_baud_rate(baud_rate_code: int) -&gt; None\n</code></pre> <p>Set CAN baud rate using register 35 (can_br).</p> <p>Parameters:</p> Name Type Description Default <code>baud_rate_code</code> <code>int</code> <p>Baud rate code (0=125K, 1=200K, 2=250K, 3=500K, 4=1M)</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If baud_rate_code is not in valid range [0, 4]</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_can_baud_rate(self, baud_rate_code: int) -&gt; None:\n    \"\"\"\n    Set CAN baud rate using register 35 (can_br).\n\n    Args:\n        baud_rate_code: Baud rate code (0=125K, 1=200K, 2=250K, 3=500K, 4=1M)\n\n    Raises:\n        ValueError: If baud_rate_code is not in valid range [0, 4]\n    \"\"\"\n    if baud_rate_code not in CAN_BAUD_RATE_CODES:\n        raise ValueError(\n            f\"Invalid baud rate code: {baud_rate_code}. Must be in {list(CAN_BAUD_RATE_CODES.keys())}\"\n        )\n\n    self.write_register(35, baud_rate_code)  # Register 35 is can_br\n    self.store_parameters()  # Store to flash so it persists\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_can_timeout","title":"set_can_timeout","text":"<pre><code>set_can_timeout(timeout_ms: int) -&gt; None\n</code></pre> <p>Set CAN timeout alarm time (register 9).</p> <p>Parameters:</p> Name Type Description Default <code>timeout_ms</code> <code>int</code> <p>Timeout in milliseconds</p> required Note <p>Register 9 stores timeout in units of 50 microseconds: 1 register unit = 50 microseconds.</p> <p>Conversion formula: register_value = timeout_ms * 20</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_can_timeout(self, timeout_ms: int) -&gt; None:\n    \"\"\"\n    Set CAN timeout alarm time (register 9).\n\n    Args:\n        timeout_ms: Timeout in milliseconds\n\n    Note:\n        Register 9 stores timeout in units of 50 microseconds:\n        1 register unit = 50 microseconds.\n\n        Conversion formula: register_value = timeout_ms * 20\n    \"\"\"\n    # Convert milliseconds to register units: 1 register unit = 50 microseconds\n    # timeout_ms * 1000 us/ms / 50 us/unit = timeout_ms * 20\n    register_value = timeout_ms * 20\n    self.write_register(9, register_value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_control_mode","title":"set_control_mode","text":"<pre><code>set_control_mode(value: int) -&gt; None\n</code></pre> <p>Set control mode (register 10).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_control_mode(self, value: int) -&gt; None:\n    \"\"\"Set control mode (register 10).\"\"\"\n    self.write_register(10, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_current_loop_bandwidth","title":"set_current_loop_bandwidth","text":"<pre><code>set_current_loop_bandwidth(value: float) -&gt; None\n</code></pre> <p>Set current loop control bandwidth (register 24).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_current_loop_bandwidth(self, value: float) -&gt; None:\n    \"\"\"Set current loop control bandwidth (register 24).\"\"\"\n    self.write_register(24, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_current_loop_enhancement","title":"set_current_loop_enhancement","text":"<pre><code>set_current_loop_enhancement(value: float) -&gt; None\n</code></pre> <p>Set current loop enhancement coefficient (register 33).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_current_loop_enhancement(self, value: float) -&gt; None:\n    \"\"\"Set current loop enhancement coefficient (register 33).\"\"\"\n    self.write_register(33, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_deceleration","title":"set_deceleration","text":"<pre><code>set_deceleration(value: float) -&gt; None\n</code></pre> <p>Set deceleration (register 5).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_deceleration(self, value: float) -&gt; None:\n    \"\"\"Set deceleration (register 5).\"\"\"\n    self.write_register(5, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_feedback_id","title":"set_feedback_id","text":"<pre><code>set_feedback_id(value: int) -&gt; None\n</code></pre> <p>Set feedback ID (register 7).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_feedback_id(self, value: int) -&gt; None:\n    \"\"\"Set feedback ID (register 7).\"\"\"\n    self.write_register(7, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_gear_efficiency","title":"set_gear_efficiency","text":"<pre><code>set_gear_efficiency(value: float) -&gt; None\n</code></pre> <p>Set gear torque efficiency (register 30).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_gear_efficiency(self, value: float) -&gt; None:\n    \"\"\"Set gear torque efficiency (register 30).\"\"\"\n    self.write_register(30, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_limits","title":"set_limits","text":"<pre><code>set_limits(*, p_min: Optional[float] = None, p_max: Optional[float] = None, v_min: Optional[float] = None, v_max: Optional[float] = None, t_min: Optional[float] = None, t_max: Optional[float] = None) -&gt; None\n</code></pre> <p>Update only the specified P/V/T limits. Omitted keys are left unchanged. kp and kd are fixed (KP_MIN/KP_MAX, KD_MIN/KD_MAX).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_limits(\n    self,\n    *,\n    p_min: Optional[float] = None,\n    p_max: Optional[float] = None,\n    v_min: Optional[float] = None,\n    v_max: Optional[float] = None,\n    t_min: Optional[float] = None,\n    t_max: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Update only the specified P/V/T limits. Omitted keys are left unchanged. kp and kd are fixed (KP_MIN/KP_MAX, KD_MIN/KD_MAX).\"\"\"\n    if p_min is not None:\n        self._p_min = p_min\n    if p_max is not None:\n        self._p_max = p_max\n    if v_min is not None:\n        self._v_min = v_min\n    if v_max is not None:\n        self._v_max = v_max\n    if t_min is not None:\n        self._t_min = t_min\n    if t_max is not None:\n        self._t_max = t_max\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_maximum_speed","title":"set_maximum_speed","text":"<pre><code>set_maximum_speed(value: float) -&gt; None\n</code></pre> <p>Set maximum speed (register 6).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_maximum_speed(self, value: float) -&gt; None:\n    \"\"\"Set maximum speed (register 6).\"\"\"\n    self.write_register(6, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_motor_type","title":"set_motor_type","text":"<pre><code>set_motor_type(motor_type: str) -&gt; None\n</code></pre> <p>Update motor type and P/V/T limits from a preset. Validates against MOTOR_TYPE_PRESETS.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_motor_type(self, motor_type: str) -&gt; None:\n    \"\"\"Update motor type and P/V/T limits from a preset. Validates against MOTOR_TYPE_PRESETS.\"\"\"\n    if motor_type not in MOTOR_TYPE_PRESETS:\n        raise ValueError(\n            f\"Unknown motor_type: {motor_type!r}. \"\n            f\"Known: {list(MOTOR_TYPE_PRESETS.keys())}\"\n        )\n    base = dict(MOTOR_TYPE_PRESETS[motor_type])\n    for k in _LIMITS_KEYS:\n        setattr(self, f\"_{k}\", base[k])\n    self.motor_type = motor_type\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_over_current_protection","title":"set_over_current_protection","text":"<pre><code>set_over_current_protection(value: float) -&gt; None\n</code></pre> <p>Set over-current protection value (register 3).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_over_current_protection(self, value: float) -&gt; None:\n    \"\"\"Set over-current protection value (register 3).\"\"\"\n    self.write_register(3, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_over_temperature_protection","title":"set_over_temperature_protection","text":"<pre><code>set_over_temperature_protection(value: float) -&gt; None\n</code></pre> <p>Set over-temperature protection value (register 2).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_over_temperature_protection(self, value: float) -&gt; None:\n    \"\"\"Set over-temperature protection value (register 2).\"\"\"\n    self.write_register(2, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_overvoltage_protection","title":"set_overvoltage_protection","text":"<pre><code>set_overvoltage_protection(value: float) -&gt; None\n</code></pre> <p>Set overvoltage protection value (register 29).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_overvoltage_protection(self, value: float) -&gt; None:\n    \"\"\"Set overvoltage protection value (register 29).\"\"\"\n    self.write_register(29, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_p_limits","title":"set_p_limits","text":"<pre><code>set_p_limits(p_min: float, p_max: float) -&gt; None\n</code></pre> <p>Set position limits used for encode/decode (MIT mode).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_p_limits(self, p_min: float, p_max: float) -&gt; None:\n    \"\"\"Set position limits used for encode/decode (MIT mode).\"\"\"\n    self._p_min, self._p_max = p_min, p_max\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_position_loop_ki","title":"set_position_loop_ki","text":"<pre><code>set_position_loop_ki(value: float) -&gt; None\n</code></pre> <p>Set position loop integral gain Ki (register 28).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_position_loop_ki(self, value: float) -&gt; None:\n    \"\"\"Set position loop integral gain Ki (register 28).\"\"\"\n    self.write_register(28, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_position_loop_kp","title":"set_position_loop_kp","text":"<pre><code>set_position_loop_kp(value: float) -&gt; None\n</code></pre> <p>Set position loop proportional gain Kp (register 27).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_position_loop_kp(self, value: float) -&gt; None:\n    \"\"\"Set position loop proportional gain Kp (register 27).\"\"\"\n    self.write_register(27, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_position_mapping_range","title":"set_position_mapping_range","text":"<pre><code>set_position_mapping_range(value: float) -&gt; None\n</code></pre> <p>Set position mapping range (register 21).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_position_mapping_range(self, value: float) -&gt; None:\n    \"\"\"Set position mapping range (register 21).\"\"\"\n    self.write_register(21, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_receive_id","title":"set_receive_id","text":"<pre><code>set_receive_id(value: int) -&gt; None\n</code></pre> <p>Set receive ID (register 8).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_receive_id(self, value: int) -&gt; None:\n    \"\"\"Set receive ID (register 8).\"\"\"\n    self.write_register(8, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_speed_loop_damping","title":"set_speed_loop_damping","text":"<pre><code>set_speed_loop_damping(value: float) -&gt; None\n</code></pre> <p>Set speed loop damping coefficient (register 31).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_speed_loop_damping(self, value: float) -&gt; None:\n    \"\"\"Set speed loop damping coefficient (register 31).\"\"\"\n    self.write_register(31, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_speed_loop_enhancement","title":"set_speed_loop_enhancement","text":"<pre><code>set_speed_loop_enhancement(value: float) -&gt; None\n</code></pre> <p>Set speed loop enhancement coefficient (register 34).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_speed_loop_enhancement(self, value: float) -&gt; None:\n    \"\"\"Set speed loop enhancement coefficient (register 34).\"\"\"\n    self.write_register(34, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_speed_loop_filter_bandwidth","title":"set_speed_loop_filter_bandwidth","text":"<pre><code>set_speed_loop_filter_bandwidth(value: float) -&gt; None\n</code></pre> <p>Set speed loop filter bandwidth (register 32).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_speed_loop_filter_bandwidth(self, value: float) -&gt; None:\n    \"\"\"Set speed loop filter bandwidth (register 32).\"\"\"\n    self.write_register(32, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_speed_loop_ki","title":"set_speed_loop_ki","text":"<pre><code>set_speed_loop_ki(value: float) -&gt; None\n</code></pre> <p>Set speed loop integral gain Ki (register 26).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_speed_loop_ki(self, value: float) -&gt; None:\n    \"\"\"Set speed loop integral gain Ki (register 26).\"\"\"\n    self.write_register(26, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_speed_loop_kp","title":"set_speed_loop_kp","text":"<pre><code>set_speed_loop_kp(value: float) -&gt; None\n</code></pre> <p>Set speed loop proportional gain Kp (register 25).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_speed_loop_kp(self, value: float) -&gt; None:\n    \"\"\"Set speed loop proportional gain Kp (register 25).\"\"\"\n    self.write_register(25, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_speed_mapping_range","title":"set_speed_mapping_range","text":"<pre><code>set_speed_mapping_range(value: float) -&gt; None\n</code></pre> <p>Set speed mapping range (register 22).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_speed_mapping_range(self, value: float) -&gt; None:\n    \"\"\"Set speed mapping range (register 22).\"\"\"\n    self.write_register(22, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_t_limits","title":"set_t_limits","text":"<pre><code>set_t_limits(t_min: float, t_max: float) -&gt; None\n</code></pre> <p>Set torque limits used for encode/decode (MIT mode).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_t_limits(self, t_min: float, t_max: float) -&gt; None:\n    \"\"\"Set torque limits used for encode/decode (MIT mode).\"\"\"\n    self._t_min, self._t_max = t_min, t_max\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_timeout_alarm","title":"set_timeout_alarm","text":"<pre><code>set_timeout_alarm(value: int) -&gt; None\n</code></pre> <p>Set timeout alarm time (register 9).</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>Timeout value in register units (1 register unit = 50 microseconds)</p> required Note <p>Register 9 stores timeout in units of 50 microseconds: 1 register unit = 50 microseconds.</p> <p>This method writes the raw register value. For convenience, use <code>set_can_timeout()</code> which accepts milliseconds and handles the conversion automatically.</p> <p>To convert from milliseconds: register_value = timeout_ms * 20</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_timeout_alarm(self, value: int) -&gt; None:\n    \"\"\"\n    Set timeout alarm time (register 9).\n\n    Args:\n        value: Timeout value in register units (1 register unit = 50 microseconds)\n\n    Note:\n        Register 9 stores timeout in units of 50 microseconds:\n        1 register unit = 50 microseconds.\n\n        This method writes the raw register value. For convenience, use `set_can_timeout()`\n        which accepts milliseconds and handles the conversion automatically.\n\n        To convert from milliseconds: register_value = timeout_ms * 20\n    \"\"\"\n    self.write_register(9, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_torque_coefficient","title":"set_torque_coefficient","text":"<pre><code>set_torque_coefficient(value: float) -&gt; None\n</code></pre> <p>Set torque coefficient (register 1).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_torque_coefficient(self, value: float) -&gt; None:\n    \"\"\"Set torque coefficient (register 1).\"\"\"\n    self.write_register(1, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_torque_mapping_range","title":"set_torque_mapping_range","text":"<pre><code>set_torque_mapping_range(value: float) -&gt; None\n</code></pre> <p>Set torque mapping range (register 23).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_torque_mapping_range(self, value: float) -&gt; None:\n    \"\"\"Set torque mapping range (register 23).\"\"\"\n    self.write_register(23, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_under_voltage_protection","title":"set_under_voltage_protection","text":"<pre><code>set_under_voltage_protection(value: float) -&gt; None\n</code></pre> <p>Set under-voltage protection value (register 0).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_under_voltage_protection(self, value: float) -&gt; None:\n    \"\"\"Set under-voltage protection value (register 0).\"\"\"\n    self.write_register(0, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_v_limits","title":"set_v_limits","text":"<pre><code>set_v_limits(v_min: float, v_max: float) -&gt; None\n</code></pre> <p>Set velocity limits used for encode/decode (MIT mode).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_v_limits(self, v_min: float, v_max: float) -&gt; None:\n    \"\"\"Set velocity limits used for encode/decode (MIT mode).\"\"\"\n    self._v_min, self._v_max = v_min, v_max\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_zero_command","title":"set_zero_command","text":"<pre><code>set_zero_command() -&gt; None\n</code></pre> <p>Send zero command (pos=0, vel=0, torq=0, kp=0, kd=0).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_zero_command(self) -&gt; None:\n    \"\"\"Send zero command (pos=0, vel=0, torq=0, kp=0, kd=0).\"\"\"\n    self.send_cmd_mit(\n        target_position=0.0,\n        target_velocity=0.0,\n        stiffness=0.0,\n        damping=0.0,\n        feedforward_torque=0.0,\n    )\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_zero_position","title":"set_zero_position","text":"<pre><code>set_zero_position() -&gt; None\n</code></pre> <p>Set the current output shaft position to zero.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_zero_position(self) -&gt; None:\n    \"\"\"Set the current output shaft position to zero.\"\"\"\n    self.send_raw(self.encode_save_position_zero_msg())\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.store_parameters","title":"store_parameters","text":"<pre><code>store_parameters() -&gt; None\n</code></pre> <p>Store all parameters to flash memory. After successful write, all parameters will be written to the chip.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def store_parameters(self) -&gt; None:\n    \"\"\"\n    Store all parameters to flash memory.\n    After successful write, all parameters will be written to the chip.\n    \"\"\"\n    self._send_register_cmd(0xAA, 0x01)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.write_register","title":"write_register","text":"<pre><code>write_register(rid: int, value: float | int) -&gt; None\n</code></pre> <p>Write a value to a register.</p> <p>Parameters:</p> Name Type Description Default <code>rid</code> <code>int</code> <p>Register ID (0-81)</p> required <code>value</code> <code>float | int</code> <p>Value to write (float or int)</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If register ID is not in the register table</p> <code>ValueError</code> <p>If register is read-only or value is out of range</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def write_register(self, rid: int, value: float | int) -&gt; None:\n    \"\"\"\n    Write a value to a register.\n\n    Args:\n        rid: Register ID (0-81)\n        value: Value to write (float or int)\n\n    Raises:\n        KeyError: If register ID is not in the register table\n        ValueError: If register is read-only or value is out of range\n    \"\"\"\n    # Check if register exists in table\n    if rid not in REGISTER_TABLE:\n        raise KeyError(f\"Register {rid} not found in register table\")\n\n    reg_info = REGISTER_TABLE[rid]\n\n    # Check if register is writable\n    if reg_info.access != \"RW\":\n        raise ValueError(\n            f\"Register {rid} ({reg_info.variable}) is read-only (access: {reg_info.access})\"\n        )\n\n    # Encode value to 4 bytes using data type from register table\n    if reg_info.data_type == \"float\":\n        data_bytes = struct.pack(\"&lt;f\", float(value))\n    elif reg_info.data_type == \"uint32\":\n        data_bytes = struct.pack(\"&lt;I\", int(value))\n    else:\n        raise ValueError(\n            f\"Unknown data_type: {reg_info.data_type} for register {rid}\"\n        )\n\n    # Send write command\n    self._send_register_cmd(0x55, rid, data_bytes)\n</code></pre>","tags":["api","reference","core"]},{"location":"concept/can/","title":"CAN Bus Fundamentals","text":"<p>This document explains the CAN (Controller Area Network) bus fundamentals as they relate to DaMiao motors.</p>","tags":["concept","can","hardware"]},{"location":"concept/can/#what-is-can-bus","title":"What is CAN Bus?","text":"<p>CAN bus is a robust, multi-master communication protocol designed for real-time control applications. It's widely used in automotive and industrial automation systems, including robotics.</p>","tags":["concept","can","hardware"]},{"location":"concept/can/#why-can-for-motors","title":"Why CAN for Motors?","text":"<p>CAN bus is ideal for motor control because:</p> <ul> <li>Reliability: Built-in error detection and fault tolerance</li> <li>Real-time: Deterministic message delivery with priority-based arbitration</li> <li>Multi-device: Multiple motors can share a single bus</li> <li>Noise immunity: Differential signaling resists electrical interference</li> <li>Standardized: Well-established protocol with broad hardware support</li> </ul>","tags":["concept","can","hardware"]},{"location":"concept/can/#can-bus-basics","title":"CAN Bus Basics","text":"<p>Physical Layer</p> <ul> <li>Differential signaling: Two wires (CAN_H and CAN_L) carry complementary signals</li> <li>Termination: 120\u03a9 resistors required at both ends of the bus</li> <li>Bitrate: Configurable (typically 1 Mbps for DaMiao motors)</li> <li>Topology: Linear bus (all devices connected in parallel)</li> </ul> <p>Message Format</p> <p>CAN messages consist of:</p> <ul> <li>Arbitration ID: 11-bit identifier (0x000-0x7FF) that determines message priority</li> <li>Data: Up to 8 bytes of payload</li> <li>Control bits: DLC (Data Length Code), RTR (Remote Transmission Request), etc.</li> </ul> <p>Arbitration</p> <p>When multiple devices transmit simultaneously:</p> <ul> <li>Lower arbitration IDs have higher priority</li> <li>Devices with lower priority automatically back off</li> <li>No data is lost during arbitration</li> <li>Winner transmits immediately</li> </ul>","tags":["concept","can","hardware"]},{"location":"concept/can/#damiao-motor-can-configuration","title":"DaMiao Motor CAN Configuration","text":"<p>Bitrate</p> <p>DaMiao motors typically use 1 Mbps (1,000,000 bits per second). The bitrate must match between all devices on the bus.</p> <p>Arbitration IDs</p> <p>DaMiao motors use different arbitration IDs for different purposes:</p> Purpose Arbitration ID Format Example (motor_id=1) MIT Control <code>motor_id</code> 0x001 POS_VEL Control <code>0x100 + motor_id</code> 0x101 VEL Control <code>0x200 + motor_id</code> 0x201 FORCE_POS Control <code>0x300 + motor_id</code> 0x301 Register Operations <code>0x7FF</code> 0x7FF Feedback <code>feedback_id</code> (MST_ID) Variable <p>Message Length</p> <p>All DaMiao motor messages are 8 bytes (standard CAN frame length).</p>","tags":["concept","can","hardware"]},{"location":"concept/can/#socketcan-on-linux","title":"SocketCAN on Linux","text":"<p>The driver uses SocketCAN, the Linux CAN subsystem:</p> <ul> <li>Interface naming: <code>can0</code>, <code>can1</code>, etc.</li> <li>Configuration: Standard Linux network tools (<code>ip link</code>)</li> <li>Access: Standard socket API</li> </ul> <p>Basic Setup</p> <pre><code># Bring up CAN interface\nsudo ip link set can0 up type can bitrate 1000000\n\n# Check status\nip link show can0\n\n# Monitor traffic\ncandump can0\n</code></pre>","tags":["concept","can","hardware"]},{"location":"concept/can/#bus-topology","title":"Bus Topology","text":"<pre><code>[Computer] ----[CAN Interface]----[CAN Bus]----[Motor 1]\n                                              [Motor 2]\n                                              [Motor 3]\n</code></pre> <p>Requirements</p> <ul> <li>Termination resistors: 120\u03a9 at both ends of the bus</li> <li>Bitrate matching: All devices must use the same bitrate</li> <li>Proper wiring: CAN_H and CAN_L must be connected correctly</li> </ul>","tags":["concept","can","hardware"]},{"location":"concept/can/#error-handling","title":"Error Handling","text":"<p>CAN bus includes built-in error detection:</p> <ul> <li>CRC (Cyclic Redundancy Check): Detects transmission errors</li> <li>ACK (Acknowledgment): Confirms successful reception</li> <li>Error frames: Automatically transmitted on error detection</li> <li>Bus-off: Device disconnects after repeated errors</li> </ul>","tags":["concept","can","hardware"]},{"location":"concept/can/#best-practices","title":"Best Practices","text":"<ol> <li>Termination: Always use 120\u03a9 resistors at both bus ends</li> <li>Bitrate: Verify all devices use the same bitrate</li> <li>Cable length: Keep bus length reasonable (&lt; 40m for 1 Mbps)</li> <li>Grounding: Ensure proper ground connections</li> <li>Shielding: Use shielded cables in noisy environments</li> </ol>","tags":["concept","can","hardware"]},{"location":"concept/can/#troubleshooting","title":"Troubleshooting","text":"<p>No Communication</p> <ul> <li>Check CAN interface is up: <code>ip link show can0</code></li> <li>Verify bitrate matches motor configuration</li> <li>Check termination resistors are present</li> <li>Verify motor is powered on</li> </ul> <p>Intermittent Communication</p> <ul> <li>Check for loose connections</li> <li>Verify cable quality and length</li> <li>Check for electrical interference</li> <li>Verify termination resistors</li> </ul> <p>Error Messages</p> <ul> <li>Error Code 105: No buffer space - motor not responding or not powered</li> <li>Timeout errors: Motor not receiving commands or not responding</li> <li>Bus errors: Physical layer issues (wiring, termination, bitrate mismatch)</li> </ul>","tags":["concept","can","hardware"]},{"location":"concept/can/#further-reading","title":"Further Reading","text":"<ul> <li>Motor Control Modes</li> <li>SocketCAN Documentation</li> <li>CAN-utils Documentation</li> </ul>","tags":["concept","can","hardware"]},{"location":"concept/communication-protocol/","title":"Communication Protocol","text":"<p>This document describes the CAN bus communication protocol used by DaMiao motors.</p>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#overview","title":"Overview","text":"<p>DaMiao motors communicate over CAN bus using a custom protocol. The protocol supports:</p> <ul> <li>Command messages: Send control commands to motors</li> <li>Feedback messages: Receive motor state information</li> <li>Register operations: Read/write motor configuration registers</li> </ul>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#message-types","title":"Message Types","text":"<p>1. Control Commands</p> <p>Control commands send motion commands to motors. All frames are standard CAN (<code>STD</code>) with 8-byte data payload (<code>D[0]..D[7]</code>).</p> <p>MIT command frame (MIT mode)</p> Arbitration ID Attribute D[0] D[1] D[2] D[3] D[4] D[5] D[6] D[7] <code>motor_id</code> <code>STD</code> <code>pos_u[15:8]</code> <code>pos_u[7:0]</code> <code>vel_u[11:4]</code> <code>vel_u[3:0]</code> / <code>kp_u[11:8]</code> <code>kp_u[7:0]</code> <code>kd_u[11:4]</code> <code>kd_u[3:0]</code> / <code>torq_u[11:8]</code> <code>torq_u[7:0]</code> <p>POS_VEL command frame (POS_VEL mode, little-endian)</p> Arbitration ID Attribute D[0] D[1] D[2] D[3] D[4] D[5] D[6] D[7] <code>0x100 + motor_id</code> <code>STD</code> <code>position_b0</code> <code>position_b1</code> <code>position_b2</code> <code>position_b3</code> <code>vel_limit_b0</code> <code>vel_limit_b1</code> <code>vel_limit_b2</code> <code>vel_limit_b3</code> <p>VEL command frame (VEL mode, little-endian)</p> Arbitration ID Attribute D[0] D[1] D[2] D[3] D[4] D[5] D[6] D[7] <code>0x200 + motor_id</code> <code>STD</code> <code>velocity_b0</code> <code>velocity_b1</code> <code>velocity_b2</code> <code>velocity_b3</code> <code>0x00</code> <code>0x00</code> <code>0x00</code> <code>0x00</code> <p>FORCE_POS command frame (FORCE_POS mode, little-endian)</p> Arbitration ID Attribute D[0] D[1] D[2] D[3] D[4] D[5] D[6] D[7] <code>0x300 + motor_id</code> <code>STD</code> <code>position_b0</code> <code>position_b1</code> <code>position_b2</code> <code>position_b3</code> <code>vel_limit_b0</code> <code>vel_limit_b1</code> <code>torque_ratio_b0</code> <code>torque_ratio_b1</code> <p><code>b0</code> is the least significant byte (LSB), <code>b3</code> is the most significant byte (MSB).</p> <p>2. System Commands</p> <p>System commands also use <code>arbitration_id = motor_id</code> and <code>STD</code> frames:</p> Command Arbitration ID Attribute D[0] D[1] D[2] D[3] D[4] D[5] D[6] D[7] Enable motor <code>motor_id</code> <code>STD</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFC</code> Disable motor <code>motor_id</code> <code>STD</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFD</code> Set zero position <code>motor_id</code> <code>STD</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFE</code> Clear error <code>motor_id</code> <code>STD</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFF</code> <code>0xFB</code> <p>3. Register Operations</p> <p>Register command requests use arbitration ID <code>0x7FF</code> and <code>STD</code> frames:</p> <p>For register semantics and persistence behavior:</p> <ul> <li>See Registers: How it works? for write (RAM/runtime) vs store (flash persistence) behavior (<code>write_register(...)</code> vs <code>store_parameters()</code>).</li> <li>See Register Table for valid <code>RID</code>, access type (<code>RW</code>/<code>RO</code>), value range, and data type.</li> <li>Terminology used in this documentation: write = runtime RAM update, store = persist to flash.</li> </ul> <p>Read register request (<code>D[2] = 0x33</code>)</p> Arbitration ID Attribute D[0] D[1] D[2] D[3] D[4] D[5] D[6] D[7] <code>0x7FF</code> <code>STD</code> <code>CANID_L</code> <code>CANID_H</code> <code>0x33</code> <code>RID</code> <code>0x00</code> <code>0x00</code> <code>0x00</code> <code>0x00</code> <p>Write register request (<code>D[2] = 0x55</code>)</p> Arbitration ID Attribute D[0] D[1] D[2] D[3] D[4] D[5] D[6] D[7] <code>0x7FF</code> <code>STD</code> <code>CANID_L</code> <code>CANID_H</code> <code>0x55</code> <code>RID</code> <code>data_b0</code> <code>data_b1</code> <code>data_b2</code> <code>data_b3</code> <p>Store parameters request (<code>D[2] = 0xAA</code>)</p> Arbitration ID Attribute D[0] D[1] D[2] D[3] D[4] D[5] D[6] D[7] <code>0x7FF</code> <code>STD</code> <code>CANID_L</code> <code>CANID_H</code> <code>0xAA</code> <code>RID</code> (driver uses <code>0x01</code>) <code>0x00</code> <code>0x00</code> <code>0x00</code> <code>0x00</code> <p>4. Feedback Messages</p> <p>Motors continuously send feedback as <code>STD</code> frames:</p> Arbitration ID Attribute D[0] D[1] D[2] D[3] D[4] D[5] D[6] D[7] <code>feedback_id</code> (MST_ID, reg 7) <code>STD</code> <code>status[7:4]</code> / <code>motor_id[3:0]</code> <code>pos_u[15:8]</code> <code>pos_u[7:0]</code> <code>vel_u[11:4]</code> <code>vel_u[3:0]</code> / <code>torq_u[11:8]</code> <code>torq_u[7:0]</code> <code>T_mos</code> <code>T_rotor</code>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#status-codes","title":"Status Codes","text":"Group Code Name Description Normal <code>0x0</code> DISABLED Motor is disabled Normal <code>0x1</code> ENABLED Motor is enabled and ready Fault <code>0x8</code> OVER_VOLTAGE Over-voltage protection triggered (threshold: OV_Value reg 29) Fault <code>0x9</code> UNDER_VOLTAGE Under-voltage protection triggered (threshold: UV_Value reg 0) Fault <code>0xA</code> OVER_CURRENT Over-current protection triggered (threshold: OC_Value reg 3) Fault <code>0xB</code> MOS_OVER_TEMP MOSFET over-temperature protection triggered (threshold: OT_Value reg 2) Fault <code>0xC</code> ROTOR_OVER_TEMP Rotor over-temperature protection triggered (threshold: OT_Value reg 2) Fault <code>0xD</code> LOST_COMM Communication timeout/loss detected (related: TIMEOUT reg 9, where 1 register unit = 50 microseconds) Fault <code>0xE</code> OVERLOAD Motor overload detected <p>5. Register Reply Messages</p> <p>Register read replies are <code>STD</code> frames:</p> Arbitration ID Attribute D[0] D[1] D[2] D[3] D[4] D[5] D[6] D[7] <code>feedback_id</code> (MST_ID, reg 7) <code>STD</code> <code>CANID_L</code> <code>CANID_H</code> <code>0x33</code> <code>RID</code> <code>data_b0</code> <code>data_b1</code> <code>data_b2</code> <code>data_b3</code>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#data-encoding","title":"Data Encoding","text":"<p>Position/Velocity/Torque Encoding</p> <p>Position, velocity, and torque values are encoded using a mapping function:</p> \\[ u=\\frac{x-x_{\\min}}{x_{\\max}-x_{\\min}}\\left(2^{N}-1\\right) \\] <p>Where: - <code>x_{\\min}</code> and <code>x_{\\max}</code> are motor-specific limits (from motor type presets; see PMAX / VMAX / TMAX defaults) - <code>N</code> is the bit width (16 for position, 12 for velocity/torque) - <code>u</code> is the encoded unsigned integer value</p> <p>Decoding reverses this process:</p> \\[ x=x_{\\min}+\\frac{u}{2^{N}-1}\\left(x_{\\max}-x_{\\min}\\right) \\] <p>Stiffness/Damping Encoding</p> <p>Stiffness (kp) and damping (kd) use fixed ranges:</p> <ul> <li>Stiffness: 0-500 (12-bit encoding)</li> <li>Damping: 0-5 (12-bit encoding)</li> </ul>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#multi-motor-communication","title":"Multi-Motor Communication","text":"<p>Multiple motors can share the same CAN bus:</p> <ol> <li>Each motor has a unique <code>motor_id</code> (ESC_ID, register 8)</li> <li>Each motor has a <code>feedback_id</code> (MST_ID, register 7); unique assignment is recommended</li> <li>Commands are addressed to specific <code>motor_id</code></li> <li>Feedback is identified by <code>feedback_id</code></li> </ol> <p>@remarks</p> <p>Each motor has a unique <code>feedback_id</code> (MST_ID, register 7) that identifies the motor in feedback messages. While the <code>feedback_id</code> does not strictly need to be unique for each motor (since the motor ID is included in the data frame), it is recommended to assign unique <code>feedback_id</code>s to avoid confusion and simplify message routing.</p> <p>@see Message frame structure for details on motor ID encoding in feedback messages.</p> <p>Example: Three Motors</p> <p>Motor ID assignment:</p> Motor <code>motor_id</code> (ESC_ID, reg 8) <code>feedback_id</code> (MST_ID, reg 7) Motor 1 <code>0x01</code> <code>0x11</code> Motor 2 <code>0x02</code> <code>0x12</code> Motor 3 <code>0x03</code> <code>0x13</code> <p>MIT mode command arbitration IDs (<code>arbitration_id = motor_id</code>):</p> Motor Arbitration ID Motor 1 <code>0x001</code> Motor 2 <code>0x002</code> Motor 3 <code>0x003</code> <p>Feedback arbitration IDs (<code>arbitration_id = feedback_id</code>):</p> Motor Arbitration ID Motor 1 <code>0x011</code> Motor 2 <code>0x012</code> Motor 3 <code>0x013</code>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#error-handling","title":"Error Handling","text":"<p>Timeout Protection</p> <ul> <li>Register operations have timeout protection</li> <li>If no reply received within timeout, operation fails</li> <li>Motor has CAN timeout alarm (TIMEOUT register 9); Register 9 stores timeout in units of 50 microseconds (1 register unit = 50 microseconds), and motor disables if no commands are received</li> <li>Timeout-related status is reported as LOST_COMM (<code>0xD</code>)</li> </ul> <p>Error States</p> <ul> <li>Motor enters error state on various conditions (overcurrent, overtemperature, etc.)</li> <li>Error state is reported in feedback status byte</li> <li>Use clear error command to reset error state</li> </ul>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#protocol-limitations","title":"Protocol Limitations","text":"<ol> <li>Message size: Fixed 8 bytes (CAN limitation)</li> <li>Arbitration ID range: 0x000-0x7FF (11-bit standard CAN)</li> <li>Bitrate: Must match across all devices</li> <li>Real-time: No guaranteed delivery time (best-effort)</li> </ol>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#further-reading","title":"Further Reading","text":"<ul> <li>See Motor Control Modes for control mode details</li> <li>See CAN Bus Fundamentals for CAN bus basics</li> <li>For interactive understanding of control modes, use <code>damiao gui</code></li> <li>See API Reference for implementation details</li> </ul>","tags":["concept","protocol","advanced"]},{"location":"concept/motor-control-modes/","title":"Motor Control Modes","text":"<p>DaMiao motors support four different control modes, each optimized for different use cases.</p> <p>Quick links: MIT mode | POS_VEL mode | VEL mode | FORCE_POS mode</p> <p>Recommended learning path</p> <p>To better understand the control modes in practice, use <code>damiao gui</code> and switch between modes while observing live feedback and charts.</p>","tags":["concept","control-modes","reference"]},{"location":"concept/motor-control-modes/#overview","title":"Overview","text":"<p>Control modes determine how the motor interprets command messages. The control mode is set via register 10 (CTRL_MODE) and must match the command format being sent.</p> <p>API method: <code>DaMiaoMotor.ensure_control_mode()</code></p> <p>Mode parameters marked as \"Motor-specific\" use the mapping limits for the selected motor type. See PMAX / VMAX / TMAX defaults. These registers are writable, but changing them is generally not recommended.</p> <p>The <code>ensure_control_mode()</code> method automatically:</p> <ol> <li> <p>Reads the current mode from register 10</p> </li> <li> <p>Writes the new mode if different</p> </li> <li> <p>Verifies the write was successful</p> </li> </ol> <p>Low Level Torque Control (Current-based)</p> <p>All four modes eventually do the same low-level job: they run a current feedback loop inside the motor controller.</p> <p>In simple terms:</p> <ul> <li> <p>The selected mode (MIT/POS_VEL/VEL/FORCE_POS) decides what current the motor should produce.</p> </li> <li> <p>That target current is sent to a fast inner controller.</p> </li> <li> <p>The inner controller continuously compares target current vs measured current and corrects PWM voltage to reduce the error.</p> </li> <li> <p>\\(i_{q,\\mathrm{ref}}\\): the target for the torque-producing current.   Larger magnitude means stronger torque. Sign decides rotation direction.</p> </li> <li> <p>\\(i_{d,\\mathrm{ref}}\\): the target for the flux-axis current.   In these modes it is set to <code>0</code>, meaning \"do not add extra d-axis current.\"</p> </li> </ul> <p>Note</p> <p>The motor tracks the calculated \\(i_{q,\\mathrm{ref}}\\) to produce the desired torque, while keeping the d-axis current at \\(i_{d,\\mathrm{ref}} = 0\\).</p> Mode Easy interpretation of \\(i_{q,\\mathrm{ref}}\\) \\(i_{d,\\mathrm{ref}}\\) MIT Calculated from position/velocity error + feedforward torque, then converted to current <code>0</code> POS_VEL Position loop outputs a speed target, speed loop converts that speed error to current <code>0</code> VEL Speed loop directly converts velocity error to current <code>0</code> FORCE_POS Position loop and speed loop compute current, then it is clipped by current/force limit <code>0</code>","tags":["concept","control-modes","reference"]},{"location":"concept/motor-control-modes/#mit-mode","title":"MIT Mode (Impedance Control)","text":"<p>MIT mode (named after MIT's Cheetah robot) provides impedance control with position, velocity, stiffness, damping, and feedforward torque.</p> <p>API method: <code>DaMiaoMotor.send_cmd_mit()</code></p> Parameter Range Description <code>target_position</code> Motor-specific Desired position (radians) <code>target_velocity</code> Motor-specific Desired velocity (rad/s) <code>stiffness</code> (kp) 0-500 Position gain (stiffness) <code>damping</code> (kd) 0-5 Velocity gain (damping) <code>feedforward_torque</code> Motor-specific Feedforward torque (Nm) <p></p> \\[ T_{\\text{ref}} = K_p \\cdot (p_{\\text{des}} - \\theta_m) + K_d \\cdot (v_{\\text{des}} - \\dot{\\theta}_m) + \\tau_{ff} \\] \\[ i_{q,\\text{ref}} = \\frac{T_{\\text{ref}}}{K_T}, \\quad i_{d,\\text{ref}} = 0 \\] <p>where \\(K_T\\) comes from KT_Value (register 1).</p>","tags":["concept","control-modes","reference"]},{"location":"concept/motor-control-modes/#pos-vel-mode","title":"POS_VEL Mode (Position + Velocity-Limit)","text":"<p>POS_VEL mode provides position-velocity control with trapezoidal motion profiles. The motor moves toward the target position, limiting velocity to the specified maximum, with automatic acceleration and deceleration.</p> <p>API method: <code>DaMiaoMotor.send_cmd_pos_vel()</code></p> Parameter Range Description <code>target_position</code> Motor-specific Desired position (radians) <code>velocity_limit</code> Motor-specific Maximum velocity during motion (rad/s) <p></p> \\[ v_{\\text{des}} = \\text{clip}\\!\\left(K_{p,\\text{apr}} (p_{\\text{des}} - \\theta_m) + K_{i,\\text{apr}} \\int (p_{\\text{des}} - \\theta_m) \\, dt,\\; -v_{\\text{limit}},\\; v_{\\text{limit}}\\right) \\] <p>In the control-law diagram, <code>velocity_limit</code> directly sets the clip bounds \\(\\pm v_{\\text{limit}}\\).</p> \\[ i_{q,\\text{ref}} = K_{p,\\text{asr}} (v_{\\text{des}} - \\dot{\\theta}_m) + K_{i,\\text{asr}} \\int (v_{\\text{des}} - \\dot{\\theta}_m) \\, dt, \\quad i_{d,\\text{ref}} = 0 \\] <p>where \\(v_{\\text{limit}}\\) is the commanded <code>velocity_limit</code>, KP_APR (reg 27), KI_APR (reg 28) are position loop gains, and KP_ASR (reg 25), KI_ASR (reg 26) are speed loop gains.</p>","tags":["concept","control-modes","reference"]},{"location":"concept/motor-control-modes/#vel-mode","title":"VEL Mode (Velocity)","text":"<p>VEL mode provides pure velocity control. The motor maintains the commanded velocity. Positive values rotate in one direction, negative values in the opposite direction.</p> <p>API method: <code>DaMiaoMotor.send_cmd_vel()</code></p> Parameter Range Description <code>target_velocity</code> Motor-specific Desired velocity (rad/s) <p></p> \\[ i_{q,\\text{ref}} = K_{p,\\text{asr}} (v_{\\text{des}} - \\dot{\\theta}_m) + K_{i,\\text{asr}} \\int (v_{\\text{des}} - \\dot{\\theta}_m) \\, dt, \\quad i_{d,\\text{ref}} = 0 \\] <p>where KP_ASR (reg 25) and KI_ASR (reg 26) are speed loop gains.</p>","tags":["concept","control-modes","reference"]},{"location":"concept/motor-control-modes/#force-pos-mode","title":"FORCE_POS Mode (Force-Limited Position)","text":"<p>FORCE_POS mode (Force-Position Hybrid) provides position control with velocity and torque-limit-ratio constraints. The motor moves toward the target position while respecting these limits, providing safe position control with force limiting.</p> <p>API method: <code>DaMiaoMotor.send_cmd_force_pos()</code></p> Parameter Range Description <code>target_position</code> Motor-specific Desired position (radians) <code>velocity_limit</code> 0-100 rad/s Maximum velocity during motion <code>torque_limit_ratio</code> 0.0-1.0 Normalized torque-limit coefficient <p></p> \\[ v_{\\text{des}} = \\text{clip}\\!\\left(K_{p,\\text{apr}} (p_{\\text{des}} - \\theta_m) + K_{i,\\text{apr}} \\int (p_{\\text{des}} - \\theta_m) \\, dt,\\; -v_{\\text{limit}},\\; v_{\\text{limit}}\\right) \\] \\[ i_{q,\\text{ref}} = \\text{clip}\\!\\left(K_{p,\\text{asr}} (v_{\\text{des}} - \\dot{\\theta}_m) + K_{i,\\text{asr}} \\int (v_{\\text{des}} - \\dot{\\theta}_m) \\, dt,\\; -\\tau_{\\text{lim}},\\; \\tau_{\\text{lim}}\\right), \\quad i_{d,\\text{ref}} = 0 \\] <p>In FORCE_POS mode:</p> \\[ \\tau_{\\text{lim}} = \\text{torque_limit_ratio} \\cdot T_{\\max} \\] <p>Here \\(T_{\\max}\\) is the max torque for the selected motor type (for example, for <code>4340</code>, \\(T_{\\max}=28\\) Nm, so <code>torque_limit_ratio=0.5</code> gives \\(\\tau_{\\text{lim}}=14\\) Nm).</p> <p>Also, \\(v_{\\text{limit}}\\) is the commanded <code>velocity_limit</code>, KP_APR (reg 27), KI_APR (reg 28) are position loop gains, and KP_ASR (reg 25), KI_ASR (reg 26) are speed loop gains.</p>","tags":["concept","control-modes","reference"]},{"location":"concept/registers/","title":"Registers","text":"<p>This page documents all motor registers available in the DaMiao motor.</p>","tags":["concept","reference","registers"]},{"location":"concept/registers/#how-it-works","title":"How it works?","text":"<p>Register Persistence (Write vs Store)</p> <p><code>write</code> and <code>store</code> are two different operations:</p> <ul> <li>Write (<code>write_register</code>): update register value in RAM immediately (runtime only).</li> <li>Store (<code>store_parameters</code>): persist current runtime register values to flash (survives power cycle).</li> </ul> <p>Python API (<code>damiao_motor/core/motor.py</code>)</p> <p>Use these methods on <code>DaMiaoMotor</code>:</p> <ul> <li><code>write_register(rid, value)</code> to write one register at runtime (RAM).</li> <li>Most <code>set_*</code> helper methods (for example <code>set_control_mode</code>, <code>set_speed_loop_kp</code>, <code>set_can_timeout</code>) internally call <code>write_register</code>.</li> <li><code>store_parameters()</code> to store current runtime parameters to flash.</li> <li><code>set_can_baud_rate(...)</code> writes register <code>35</code> and then calls store automatically.</li> </ul> <pre><code># Write to register (RAM, immediate but NOT persistent)\nmotor.write_register(25, 20.0)  # KP_ASR\n\n# Store current runtime parameters to flash (persistent)\nmotor.store_parameters()\n</code></pre> <p> Web GUI (Write vs Store)</p> <ul> <li>Editing a register in the Web GUI performs a runtime write first.</li> <li>Click <code>Store Parameters</code> to store current runtime values to flash.</li> <li>In current implementation, changing register <code>7</code> (<code>MST_ID</code>) or <code>8</code> (<code>ESC_ID</code>) also triggers store automatically.</li> </ul> <p></p> <p>CLI</p> <p>From current CLI implementation:</p> Command Write action (RAM) Store behavior (flash) <code>damiao set-motor-id</code> Writes register <code>8</code> (<code>ESC_ID</code>) Yes (calls <code>store_parameters()</code>) <code>damiao set-feedback-id</code> Writes register <code>7</code> (<code>MST_ID</code>) Yes (calls <code>store_parameters()</code>) <code>damiao set-can-timeout</code> Writes register <code>9</code> (<code>TIMEOUT</code>, 1 register unit = 50 microseconds) Yes (calls <code>store_parameters()</code>) <p>Other CLI control commands (<code>send-cmd-*</code>, <code>set-zero-command</code>, <code>set-zero-position</code>) do not call store, so parameter changes are not persisted.</p> <p>CAN Baud Rate Codes</p> <p>The <code>CAN_BAUD_RATE_CODES</code> dictionary maps baud rate codes to actual baud rates:</p> Code Baud Rate 0 125,000 (125K) 1 200,000 (200K) 2 250,000 (250K) 3 500,000 (500K) 4 1,000,000 (1M) <pre><code>from damiao_motor import CAN_BAUD_RATE_CODES\n\n# Access baud rate codes\nfor code, baud_rate in CAN_BAUD_RATE_CODES.items():\n    print(f\"Code {code}: {baud_rate} bps\")\n</code></pre> <p>Usage Examples</p> <pre><code>from damiao_motor import DaMiaoController\n\ncontroller = DaMiaoController(channel=\"can0\")\nmotor = controller.add_motor(motor_id=0x01, feedback_id=0x00, motor_type=\"4340\")\n\n# Read a specific register\nvalue = motor.get_register(0x00)  # Read UV_Value\n\n# Check if read was successful\nif value is not None:\n    print(f\"Value: {value}\")\n</code></pre> <pre><code># Write to a register (only RW registers can be written)\nmotor.write_register(7, 0x01)  # Set MST_ID to 1 (RAM)\n\n# Store to keep the change after power cycle\nmotor.store_parameters()\n</code></pre> <pre><code>from damiao_motor import REGISTER_TABLE\n\n# Access register information\nfor register_id, info in REGISTER_TABLE.items():\n    print(f\"Register {register_id:2d} (0x{register_id:02X}): \"\n          f\"{info.variable:12s} - {info.description} \"\n          f\"[{info.access}]\")\n</code></pre> <p>Safety Notes</p> <p>Register Safety</p> <ul> <li>Some registers affect motor behavior immediately</li> <li>Always verify register values before writing</li> <li>Read-only (RO) registers cannot be written</li> <li>Refer to motor firmware documentation for detailed register behavior</li> <li>Test register changes in a safe environment</li> </ul>","tags":["concept","reference","registers"]},{"location":"concept/registers/#register-table","title":"Register Table","text":"ID Variable Description Access Range Type 0 <code>UV_Value</code> Under-voltage protection value (see UNDER_VOLTAGE <code>0x9</code>) RW (10.0, 3.4E38] float 1 <code>KT_Value</code> Torque coefficient \\(K_T\\) used in MIT mode RW [0.0, 3.4E38] float 2 <code>OT_Value</code> Over-temperature protection value (see MOS/ROTOR over-temp) RW [80.0, 200) float 3 <code>OC_Value</code> Over-current protection value (see OVER_CURRENT <code>0xA</code>) RW (0.0, 1.0) float 4 <code>ACC</code> Acceleration RW (0.0, 3.4E38) float 5 <code>DEC</code> Deceleration RW [-3.4E38, 0.0) float 6 <code>MAX_SPD</code> Maximum speed RW (0.0, 3.4E38] float ID Variable Description Access Range Type 7 <code>MST_ID</code> Feedback ID RW [0, 0x7FF] uint32 8 <code>ESC_ID</code> Receive ID RW [0, 0x7FF] uint32 9 <code>TIMEOUT</code> Timeout alarm time (1 register unit = 50 microseconds; see LOST_COMM <code>0xD</code>) RW [0, 2^32-1] uint32 10 <code>CTRL_MODE</code> Control mode RW [1, 4] uint32 ID Variable Description Access Range Type 11 <code>Damp</code> Motor viscous damping coefficient RO / float 12 <code>Inertia</code> Motor moment of inertia RO / float 13 <code>hw_ver</code> Reserved RO / uint32 14 <code>sw_ver</code> Software version number RO / uint32 15 <code>SN</code> Reserved RO / uint32 16 <code>NPP</code> Motor pole pairs RO / uint32 17 <code>Rs</code> Motor phase resistance RO / float 18 <code>Ls</code> Motor phase inductance RO / float 19 <code>Flux</code> Motor flux linkage value RO / float 20 <code>Gr</code> Gear reduction ratio RO / float ID Variable Description Access Range Type 21 <code>PMAX</code> Position mapping range RW (0.0, 3.4E38] float 22 <code>VMAX</code> Speed mapping range RW (0.0, 3.4E38] float 23 <code>TMAX</code> Torque mapping range RW (0.0, 3.4E38] float <p>PMAX / VMAX / TMAX Defaults</p> <p>Registers <code>21</code> (<code>PMAX</code>), <code>22</code> (<code>VMAX</code>), and <code>23</code> (<code>TMAX</code>) are writable and can be changed with register writes (API/CLI/GUI).</p> <p>Recommended Practice</p> <p>These mapping limits should normally stay at their default motor-type values. The SDK uses motor-type presets in <code>damiao_motor/core/motor.py</code> (<code>MOTOR_TYPE_PRESETS</code>, built from <code>_MOTOR_LIMIT_PARAM</code>) for command encoding and feedback decoding. If motor register mapping limits are changed without keeping SDK limits consistent, command/feedback scaling can become inconsistent.</p> <p>Default values in code (<code>_MOTOR_LIMIT_PARAM</code>): </p> Motor type PMAX VMAX TMAX <code>3507</code> 12.566 50 5 <code>4310</code> 12.5 30 10 <code>4310P</code> 12.5 50 10 <code>4340</code> 12.5 10 28 <code>4340P</code> 12.5 10 28 <code>6006</code> 12.5 45 20 <code>8006</code> 12.5 45 40 <code>8009</code> 12.5 45 54 <code>10010L</code> 12.5 25 200 <code>10010</code> 12.5 20 200 <code>H3510</code> 12.5 280 1 <code>G6215</code> 12.5 45 10 <code>H6220</code> 12.5 45 10 <code>JH11</code> 12.5 10 12 <code>6248P</code> 12.566 20 120 ID Variable Description Access Range Type 24 <code>I_BW</code> Current loop control bandwidth RW [100.0, 10000.0] float 25 <code>KP_ASR</code> Speed loop Kp (used in POS_VEL, VEL, FORCE_POS) RW [0.0, 3.4E38] float 26 <code>KI_ASR</code> Speed loop Ki (used in POS_VEL, VEL, FORCE_POS) RW [0.0, 3.4E38] float 27 <code>KP_APR</code> Position loop Kp (used in POS_VEL, FORCE_POS) RW [0.0, 3.4E38] float 28 <code>KI_APR</code> Position loop Ki (used in POS_VEL, FORCE_POS) RW [0.0, 3.4E38] float ID Variable Description Access Range Type 29 <code>OV_Value</code> Overvoltage protection value (see OVER_VOLTAGE <code>0x8</code>) RW TBD float 30 <code>GREF</code> Gear torque efficiency RW (0.0, 1.0] float 31 <code>Deta</code> Speed loop damping coefficient RW [1.0, 30.0] float 32 <code>V_BW</code> Speed loop filter bandwidth RW (0.0, 500.0) float ID Variable Description Access Range Type 33 <code>IQ_c1</code> Current loop enhancement coefficient RW [100.0, 10000.0] float 34 <code>VL_c1</code> Speed loop enhancement coefficient RW (0.0, 10000.0] float ID Variable Description Access Range Type 35 <code>can_br</code> CAN baud rate code RW [0, 4] uint32 36 <code>sub_ver</code> Sub-version number RO / uint32 ID Variable Description Access Range Type 50 <code>u_off</code> U-phase offset RO - float 51 <code>v_off</code> V-phase offset RO - float 52 <code>k1</code> Compensation factor 1 RO - float 53 <code>k2</code> Compensation factor 2 RO - float 54 <code>m_off</code> Angle offset RO - float 55 <code>dir</code> Direction RO - float ID Variable Description Access Range Type 80 <code>p_m</code> Motor position RO - float 81 <code>xout</code> Output shaft position RO - float","tags":["concept","reference","registers"]},{"location":"hardware-setup/can-set-up/","title":"CAN Setup","text":"<p>This guide covers setting up the CAN interface for use with DaMiao motors.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#prerequisites","title":"Prerequisites","text":"<ul> <li>Linux operating system</li> <li>CAN interface hardware (USB-CAN adapter, CAN-capable board, etc.)</li> <li>SocketCAN drivers</li> </ul>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#basic-can-setup","title":"Basic CAN Setup","text":"","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#1-check-can-interface","title":"1. Check CAN Interface","text":"<p>List available network interfaces:</p> <pre><code>ip link show\n</code></pre> <p>Look for <code>can0</code>, <code>can1</code>, or similar interfaces.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#2-bring-up-can-interface","title":"2. Bring Up CAN Interface","text":"<pre><code>sudo ip link set can0 up type can bitrate 1000000\n</code></pre> <p>This sets up <code>can0</code> with a 1 Mbps bitrate.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#3-verify-interface","title":"3. Verify Interface","text":"<pre><code>ip link show can0\n</code></pre> <p>You should see the interface is <code>UP</code>.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#persistent-interface-name-fixed-device-name","title":"Persistent Interface Name (Fixed Device Name)","text":"<p>If you use multiple CAN adapters, Linux may swap <code>can0</code>/<code>can1</code> order across reboots. Use a udev rule to assign a fixed name to a specific adapter.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#1-find-a-unique-identifier","title":"1. Find a Unique Identifier","text":"<pre><code># Replace can0 with your current interface\nudevadm info -a -p /sys/class/net/can0 | grep -E \"ATTRS\\\\{serial\\\\}|ATTRS\\\\{idVendor\\\\}|ATTRS\\\\{idProduct\\\\}\"\n</code></pre> <p>Pick a stable value such as <code>ATTRS{serial}</code>.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#2-create-a-udev-rule","title":"2. Create a udev Rule","text":"<pre><code>sudo tee /etc/udev/rules.d/70-can-persistent.rules &gt;/dev/null &lt;&lt;'EOF'\nSUBSYSTEM==\"net\", ACTION==\"add\", KERNEL==\"can*\", ATTRS{serial}==\"YOUR_SERIAL_HERE\", NAME=\"can_damiao\"\nEOF\n</code></pre> <p>Notes:</p> <ul> <li>Replace <code>YOUR_SERIAL_HERE</code> with your adapter serial.</li> <li><code>can_damiao</code> is an example; interface names must be 15 characters or fewer.</li> </ul>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#3-reload-rules-and-reconnect-adapter","title":"3. Reload Rules and Reconnect Adapter","text":"<pre><code>sudo udevadm control --reload-rules\n</code></pre> <p>Then unplug/replug the adapter (or reboot).</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#4-use-the-fixed-name","title":"4. Use the Fixed Name","text":"<pre><code>sudo ip link set can_damiao up type can bitrate 1000000\ndamiao scan --channel can_damiao\n</code></pre>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#testing-can-interface","title":"Testing CAN Interface","text":"","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#using-candump","title":"Using candump","text":"<pre><code>sudo apt-get install can-utils\nsudo candump can0\n</code></pre> <p>This will show all CAN messages on the bus.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#using-damiao-scan","title":"Using damiao scan","text":"<pre><code>damiao scan --channel can0\n</code></pre>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#troubleshooting","title":"Troubleshooting","text":"","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#interface-not-found","title":"Interface Not Found","text":"<ul> <li>Check hardware connection</li> <li>Verify drivers are loaded: <code>lsmod | grep can</code></li> <li>Check dmesg for errors: <code>dmesg | grep can</code></li> </ul>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#permission-errors","title":"Permission Errors","text":"<p>You may need to run with <code>sudo</code> or add your user to a group with CAN access:</p> <pre><code>sudo usermod -a -G dialout $USER\n</code></pre> <p>Then log out and back in.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#bitrate-mismatch","title":"Bitrate Mismatch","text":"<p>Ensure the CAN bitrate matches your motor configuration. Check motor firmware settings.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#multiple-can-interfaces","title":"Multiple CAN Interfaces","text":"<p>If you have multiple CAN interfaces:</p> <pre><code>sudo ip link set can0 up type can bitrate 1000000\nsudo ip link set can1 up type can bitrate 1000000\n</code></pre> <p>Then specify the channel in your code:</p> <pre><code>controller = DaMiaoController(channel=\"can1\", bustype=\"socketcan\")\n</code></pre>","tags":["hardware","setup","can"]},{"location":"hardware-setup/motor-connection/","title":"Motor Connection","text":"<p>This guide covers the physical connection of DaMiao motors to your system.</p>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#overview","title":"Overview","text":"<p>DaMiao motors connect to your computer via CAN bus. This requires:</p> <ul> <li>CAN interface hardware (USB-CAN adapter, CAN-capable board, etc.)</li> <li>CAN bus wiring (CAN_H, CAN_L, GND)</li> <li>Termination resistors (120\u03a9 at both ends)</li> <li>Power supply for the motors</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#can-interface-options","title":"CAN Interface Options","text":"<ul> <li>CANable/CandleLight: Open-source USB-CAN adapter</li> <li>Raspberry Pi: With CAN HAT (e.g., Waveshare CAN HAT)</li> <li>Jetson: With CAN expansion boards</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#requirements","title":"Requirements","text":"<ul> <li>SocketCAN support: Must have Linux kernel driver</li> <li>1 Mbps capability: Should support 1 Mbps bitrate</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#wiring","title":"Wiring","text":"","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#can-bus-wiring","title":"CAN Bus Wiring","text":"<p>CAN bus uses two wires:</p> Wire Description CAN_H CAN High signal CAN_L CAN Low signal","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#connection-diagram","title":"Connection Diagram","text":"","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#termination-resistors","title":"Termination Resistors","text":"<p>Critical: Termination resistors (120\u03a9) must be installed at both ends of the bus.</p> <ul> <li>Location: First and last device on the bus</li> <li>Value: 120\u03a9 (standard CAN bus impedance)</li> <li>Type: Standard resistor, can be through-hole or SMD</li> <li>Connection: Between CAN_H and CAN_L</li> </ul> <p>Without termination resistors, signal reflections will cause communication errors.</p>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#power-supply","title":"Power Supply","text":"<p>Motors require a separate power supply:</p> <ul> <li>Voltage: Check motor specifications (typically 24V or 48V)</li> <li>Current: Must supply enough current for all motors</li> </ul> <p>Power Safety</p> <ul> <li>Ensure power supply matches motor voltage rating</li> <li>Use appropriate fuses/circuit breakers</li> <li>Verify polarity before connecting</li> <li>Keep power and signal grounds connected</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#motor-id-configuration","title":"Motor ID Configuration","text":"<p>Each motor on the bus must have a unique ID:</p> <ul> <li>ESC_ID (Register 8): Motor receive ID (for commands)</li> <li>MST_ID (Register 7): Motor feedback ID (for feedback messages)</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#default-ids","title":"Default IDs","text":"<p>Motors typically come with default IDs. Check motor documentation or use the scan command:</p> <pre><code># Motor type is optional (defaults to 4310)\ndamiao scan\n</code></pre>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#changing-motor-ids","title":"Changing Motor IDs","text":"<p>Use the CLI to change motor IDs:</p> <pre><code># Change receive ID (ESC_ID)\ndamiao set-motor-id --current 1 --target 2 --motor-type 4340\n\n# Change feedback ID (MST_ID)\ndamiao set-feedback-id --current 1 --target 3 --motor-type 4340\n</code></pre> <p>ID Selection</p> <ul> <li>Each motor on the same bus must have a unique ESC_ID and MST_ID</li> <li>Use sequential IDs for simplicity (0x01, 0x02, 0x03, ...)</li> <li>Lower ID number will have higher priority in physical layer.</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#power-considerations","title":"Power Considerations","text":"<ul> <li>Total current: Sum of all motor currents</li> <li>Voltage drop: Longer bus may have voltage drop</li> <li>Power distribution: Consider power distribution if motors are far apart</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#testing-connections","title":"Testing Connections","text":"<p>Use one of the following options to validate your setup.</p>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#option-1-gui-recommended","title":"Option 1: GUI (Recommended)","text":"<pre><code># Start the Web GUI\ndamiao gui\n</code></pre> <p>In the GUI, follow these steps:</p> <ol> <li>Connect and scan motors: Click Connect, then Scan Motors. See GUI Connection.</li> <li>Configure the motor: Select motor type, IDs, and relevant registers. See GUI Register Parameters.</li> <li>Test motor control: Select control mode and send test commands while monitoring feedback. See GUI Motor Control.</li> </ol>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#option-2-cli-if-strictly-headless","title":"Option 2: CLI (If strictly headless)","text":"","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#1-verify-can-interface","title":"1. Verify CAN Interface","text":"<pre><code># Check interface is up\nip link show can0\n\n# Should show: state UP\n</code></pre>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#2-scan-for-motors","title":"2. Scan for Motors","text":"<pre><code># Scan for connected motors (motor-type is optional)\ndamiao scan\n\n# Should detect all connected motors\n</code></pre>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#3-test-communication","title":"3. Test Communication","text":"<pre><code># Send zero command to verify communication\ndamiao set-zero-command --id 1 --motor-type 4340\n</code></pre>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#4-monitor-can-traffic","title":"4. Monitor CAN Traffic","text":"<pre><code># Install can-utils if needed\nsudo apt-get install can-utils\n\n# Monitor all CAN messages\ncandump can0\n</code></pre>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#troubleshooting","title":"Troubleshooting","text":"","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#no-motors-detected","title":"No Motors Detected","text":"<ul> <li>Check power: Verify motors are powered on</li> <li>Check wiring: Verify CAN_H, CAN_L, GND connections</li> <li>Check termination: Verify 120\u03a9 resistors are installed</li> <li>Check bitrate: Verify bitrate matches motor configuration</li> <li>Check IDs: Verify motor IDs are in scan range</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#intermittent-communication","title":"Intermittent Communication","text":"<ul> <li>Loose connections: Check all connections are secure</li> <li>Cable quality: Verify cable is suitable for CAN bus</li> <li>Bus length: Keep bus length reasonable (&lt; 40m for 1 Mbps)</li> <li>Termination: Verify termination resistors are correct</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#communication-errors","title":"Communication Errors","text":"<ul> <li>Bitrate mismatch: All devices must use same bitrate</li> <li>ID conflicts: Each motor must have unique IDs</li> <li>Bus errors: Check for physical layer issues</li> <li>Power issues: Verify power supply is adequate</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#motor-not-responding","title":"Motor Not Responding","text":"<ul> <li>Enable motor: Use the <code>damiao enable</code> CLI command (or equivalent API call in your control flow)</li> <li>Check status: Read motor status from feedback</li> <li>Clear errors: Use clear error command if motor in error state</li> <li>Verify mode: Ensure control mode matches command type</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#safety-considerations","title":"Safety Considerations","text":"<p>Safety First</p> <ul> <li>Always ensure motors are securely mounted before powering on</li> <li>Keep clear of moving parts during testing</li> <li>Use low values initially to verify motor response</li> <li>Have emergency stop mechanism available</li> <li>Test in safe environment before production use</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#further-reading","title":"Further Reading","text":"<ul> <li>CAN Setup - Software configuration</li> <li>Communication Protocol - Protocol details</li> <li>Motor Control Modes - Control mode information</li> <li>Web GUI - Recommended for understanding control modes interactively with <code>damiao gui</code></li> </ul>","tags":["hardware","setup","wiring"]},{"location":"package-usage/cli-tool/","title":"CLI Tool Reference","text":"<p>The <code>damiao</code> command-line tool provides a unified interface for scanning, configuring, and controlling DaMiao motors.</p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#getting-help","title":"Getting Help","text":"<p>To see all available commands:</p> <pre><code>damiao --help\n</code></pre> <p>To get help for a specific command:</p> <pre><code>damiao &lt;command&gt; --help\n</code></pre> <p>Understand modes faster</p> <p>To better understand control mode behavior, use <code>damiao gui</code> for interactive switching and live feedback, then use CLI commands for repeatable workflows.</p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#register-persistence-write-vs-store","title":"Register Persistence (Write vs Store)","text":"<p>Terminology:</p> <ul> <li>Write: runtime register update in RAM.</li> <li>Store: persist current runtime values to flash.</li> </ul> <p>Register writes are applied immediately at runtime. To keep them after power cycle, they must be stored to flash.</p> <p>Based on current CLI code behavior:</p> Command Write action (RAM) Store behavior (flash) <code>damiao set-motor-id</code> Writes register <code>8</code> (<code>ESC_ID</code>) Also calls <code>store_parameters()</code> -&gt; persisted to flash <code>damiao set-feedback-id</code> Writes register <code>7</code> (<code>MST_ID</code>) Also calls <code>store_parameters()</code> -&gt; persisted to flash <code>damiao set-can-timeout</code> Writes register <code>9</code> (<code>TIMEOUT</code>, 1 register unit = 50 microseconds) Also calls <code>store_parameters()</code> -&gt; persisted to flash <p>All other CLI commands are control/status operations and do not store register parameters to flash.</p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#commands","title":"Commands","text":"","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#scan","title":"scan","text":"<p>Scan for connected motors on the CAN bus.</p> <pre><code>damiao scan [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--ids</code> <code>ID [ID ...]</code> Motor IDs to test (e.g., <code>--ids 1 2 3</code>). If not specified, tests IDs 0x01-0x10. <code>--duration</code> <code>FLOAT</code> Duration to listen for responses in seconds (default: 0.5) <code>--debug</code> flag Print all raw CAN messages for debugging <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># Scan default ID range (0x01-0x10) - motor-type is optional\ndamiao scan\n\n# Scan specific motor IDs\ndamiao scan --ids 1 2 3\n\n# Scan with longer listen duration\ndamiao scan --duration 2.0\n\n# Scan with specific motor type (optional, defaults to 4310)\ndamiao scan --motor-type 4340\n\n# Scan with debug output\ndamiao scan --debug\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#send-cmd-mit","title":"send-cmd-mit","text":"<p>Send MIT mode command to motor. Loops continuously until Ctrl+C. See Motor Control Modes for control mode details.</p> <pre><code>damiao send-cmd-mit [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--id</code> <code>INT</code> Motor ID (required) <code>--position</code> <code>FLOAT</code> Desired position (radians) (required) <code>--velocity</code> <code>FLOAT</code> Desired velocity (rad/s) (required) <code>--stiffness</code> <code>FLOAT</code> Stiffness (kp), range 0\u2013500 (default: 0.0) <code>--damping</code> <code>FLOAT</code> Damping (kd), range 0\u20135 (default: 0.0) <code>--feedforward-torque</code> <code>FLOAT</code> Feedforward torque (default: 0.0) <code>--frequency</code> <code>FLOAT</code> Command frequency in Hz (default: 100.0) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># MIT mode with all parameters\ndamiao send-cmd-mit --id 1 --position 1.5 --velocity 0.0 --stiffness 3.0 --damping 0.5\n\n# With custom frequency\ndamiao send-cmd-mit --id 1 --position 1.5 --velocity 0.0 --stiffness 3.0 --damping 0.5 --frequency 50.0\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#send-cmd-pos-vel","title":"send-cmd-pos-vel","text":"<p>Send POS_VEL mode command to motor. Loops continuously until Ctrl+C. See Motor Control Modes for control mode details.</p> <pre><code>damiao send-cmd-pos-vel [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--id</code> <code>INT</code> Motor ID (required) <code>--position</code> <code>FLOAT</code> Desired position (radians) (required) <code>--velocity-limit</code> <code>FLOAT</code> Maximum velocity during motion (rad/s) (required) <code>--frequency</code> <code>FLOAT</code> Command frequency in Hz (default: 100.0) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># POS_VEL mode\ndamiao send-cmd-pos-vel --id 1 --position 1.5 --velocity-limit 2.0\n\n# With custom frequency\ndamiao send-cmd-pos-vel --id 1 --position 1.5 --velocity-limit 2.0 --frequency 50.0\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#send-cmd-vel","title":"send-cmd-vel","text":"<p>Send VEL mode command to motor. Loops continuously until Ctrl+C. See Motor Control Modes for control mode details.</p> <pre><code>damiao send-cmd-vel [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--id</code> <code>INT</code> Motor ID (required) <code>--velocity</code> <code>FLOAT</code> Desired velocity (rad/s) (required) <code>--frequency</code> <code>FLOAT</code> Command frequency in Hz (default: 100.0) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># VEL mode\ndamiao send-cmd-vel --id 1 --velocity 3.0\n\n# With custom frequency\ndamiao send-cmd-vel --id 1 --velocity 3.0 --frequency 50.0\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#send-cmd-force-pos","title":"send-cmd-force-pos","text":"<p>Send FORCE_POS mode command to motor. Loops continuously until Ctrl+C. See Motor Control Modes for control mode details.</p> <pre><code>damiao send-cmd-force-pos [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--id</code> <code>INT</code> Motor ID (required) <code>--position</code> <code>FLOAT</code> Desired position (radians) (required) <code>--velocity-limit</code> <code>FLOAT</code> Velocity limit (rad/s, 0-100) (required) <code>--torque-limit-ratio</code> <code>FLOAT</code> Normalized torque-limit coefficient (0.0-1.0), where <code>tau_lim = torque_limit_ratio * T_max(motor_type)</code> (required) <code>--frequency</code> <code>FLOAT</code> Command frequency in Hz (default: 100.0) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># FORCE_POS mode\ndamiao send-cmd-force-pos --id 1 --position 1.5 --velocity-limit 50.0 --torque-limit-ratio 0.8\n\n# With custom frequency\ndamiao send-cmd-force-pos --id 1 --position 1.5 --velocity-limit 50.0 --torque-limit-ratio 0.8 --frequency 50.0\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#set-zero-command","title":"set-zero-command","text":"<p>Send zero command to a motor (pos=0, vel=0, torq=0, kp=0, kd=0). Loops continuously until Ctrl+C.</p> <pre><code>damiao set-zero-command [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--id</code> <code>INT</code> Motor ID to send zero command to (required) <code>--frequency</code> <code>FLOAT</code> Command frequency in Hz (default: 100.0) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># Send zero command continuously\ndamiao set-zero-command --id 1\n\n# With custom frequency\ndamiao set-zero-command --id 1 --frequency 50.0\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#set-zero-position","title":"set-zero-position","text":"<p>Set the current output shaft position to zero.</p> <pre><code>damiao set-zero-position [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--id</code> <code>INT</code> Motor ID (required) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># Set current position to zero\ndamiao set-zero-position --id 1\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#set-can-timeout","title":"set-can-timeout","text":"<p>Set CAN timeout alarm time (register 9). Register 9 stores timeout in units of 50 microseconds: 1 register unit = 50 microseconds. The CLI converts milliseconds using <code>register_value = timeout_ms * 20</code>.</p> <pre><code>damiao set-can-timeout [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--id</code> <code>INT</code> Motor ID (required) <code>--timeout</code> <code>INT</code> Timeout in milliseconds (ms) (required) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># Set CAN timeout to 1000 ms\ndamiao set-can-timeout --id 1 --timeout 1000\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#set-motor-id","title":"set-motor-id","text":"<p>Change the motor's receive ID (ESC_ID, register 8). This is the ID used to send commands to the motor.</p> <pre><code>damiao set-motor-id [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--current</code> <code>INT</code> Current motor ID (to connect to the motor) (required) <code>--target</code> <code>INT</code> Target motor ID (new receive ID) (required) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># Change motor ID from 1 to 2\ndamiao set-motor-id --current 1 --target 2\n</code></pre></p> <p>Note</p> <p>After changing the motor ID, you will need to use the new ID to communicate with the motor.</p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#set-feedback-id","title":"set-feedback-id","text":"<p>Change the motor's feedback ID (MST_ID, register 7). This is the ID used to identify feedback messages from the motor.</p> <pre><code>damiao set-feedback-id [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--current</code> <code>INT</code> Current motor ID (to connect to the motor) (required) <code>--target</code> <code>INT</code> Target feedback ID (new MST_ID) (required) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># Change feedback ID to 3 (using motor ID 1 to connect)\ndamiao set-feedback-id --current 1 --target 3\n</code></pre></p> <p>Note</p> <p>The motor will now respond with feedback using the new feedback ID.</p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#gui","title":"gui","text":"<p>Launch the web-based GUI for viewing and controlling DaMiao motors.</p> <pre><code>damiao gui [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--host</code> <code>STR</code> Host to bind to (default: 127.0.0.1) <code>--port</code> <code>INT</code> Port to bind to (default: 5000) <code>--debug</code> flag Enable debug mode <code>--production</code> flag Use production WSGI server (requires waitress) <p>Examples: <pre><code># Start GUI on default host and port (http://127.0.0.1:5000)\ndamiao gui\n\n# Start GUI on custom port\ndamiao gui --port 8080\n\n# Start GUI on all interfaces\ndamiao gui --host 0.0.0.0\n\n# Start GUI with production server\ndamiao gui --production\n</code></pre></p> <p>Backward Compatibility</p> <p>Use <code>damiao gui</code> to launch the GUI.</p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#global-options","title":"Global Options","text":"<p>All commands support the following global options:</p> Option Type Description <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000). Only used when bringing up interface. <p>These options can be specified either before or after the subcommand:</p> <pre><code>damiao --channel can1 scan\ndamiao scan --channel can1\n</code></pre>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#real-time-feedback","title":"Real-time Feedback","text":"<p>All looping send commands (<code>send-cmd-mit</code>, <code>send-cmd-pos-vel</code>, <code>send-cmd-vel</code>, <code>send-cmd-force-pos</code>, <code>set-zero-command</code>) continuously print motor state information:</p> <pre><code>State: 1 (ENABLED) | Pos:   1.234 rad | Vel:   0.567 rad/s | Torq:   0.123 Nm | T_mos: 45.0\u00b0C | T_rotor: 50.0\u00b0C\n</code></pre> <p>The state information includes: - State: Status code and human-readable status name - Pos: Current position (radians) - Vel: Current velocity (rad/s) - Torq: Current torque (Nm) - T_mos: MOSFET temperature (\u00b0C) - T_rotor: Rotor temperature (\u00b0C)</p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#safety-notes","title":"Safety Notes","text":"<p>Safety First</p> <ul> <li>Always ensure motors are securely mounted before sending commands</li> <li>Start with zero commands or low values to verify motor response</li> <li>Monitor motor temperatures during operation</li> <li>Use Ctrl+C to stop looping commands immediately</li> <li>Test in a safe environment before production use</li> </ul>","tags":["usage","cli","reference"]},{"location":"package-usage/web-gui/","title":"Web GUI","text":"<p>The <code>damiao gui</code> command provides a web-based interface to connect to the CAN bus, scan for DaMiao motors, run commands, view and edit registers, and plot position, velocity, and torque in real time.</p> <p></p>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#installation","title":"Installation","text":"<p>Install the package; the <code>damiao</code> command will be available in your PATH:</p> <pre><code>pip install damiao-motor\n</code></pre>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#starting-the-gui","title":"Starting the GUI","text":"<pre><code>damiao gui\n</code></pre> <p>Open http://127.0.0.1:5000 in your browser.</p> <p>Recommended for control modes</p> <p>To better understand control modes, use <code>damiao gui</code> to switch between MIT/POS_VEL/VEL/FORCE_POS and observe parameter visibility and live charts.</p>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#command-options","title":"Command options","text":"Option Description <code>--host</code> Host (default: 127.0.0.1) <code>--port</code> Port (default: 5000) <code>--debug</code> Enable debug mode <code>--production</code> Use production server (requires <code>pip install waitress</code>) <p>Examples:</p> <pre><code>damiao gui --port 8080\ndamiao gui --host 0.0.0.0\ndamiao gui --production\n</code></pre>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#interface-layout","title":"Interface layout","text":"<p>The page is split into:</p> <ul> <li>Top bar: Connection (CAN channel, Connect, Disconnect).</li> <li>Left column: Motor Selection, Motor Control (Control Parameters + Motor Feedback), Register Parameters.</li> <li>Right column: Chart Visualizations (Position, Velocity, Torque).</li> </ul>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#connection","title":"Connection","text":"<ul> <li>CAN Channel: Choose an interface (e.g. can0, vcan0). A refresh button reloads the list.</li> <li>Connect: Connects to the selected channel.</li> <li>Disconnect: Disconnects and clears detected motors.</li> </ul> <p>A status log shows connection and scan progress (e.g. Connecting\u2026, Connected to CAN bus: can0, Scanning for motors\u2026, Found N motor(s), Registers loaded).</p> <p></p>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#motor-selection","title":"Motor Selection","text":"<ul> <li>Scan Motors: Scans for motors and lists those that respond.</li> <li>Motor dropdown: Select a motor\u2026 when none is chosen; otherwise Motor ID: 0xXX | Arb ID: 0xYY for each detected motor. Selecting a motor updates the Control panel, Register Parameters, and charts.</li> </ul>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#motor-control","title":"Motor Control","text":"<p>When a motor is selected, the left column shows Control Parameters and Motor Feedback.</p>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#control-parameters","title":"Control Parameters","text":"<ul> <li>Motor type: Choose the motor model (e.g. 4310, 4340, 6006, 8006, 8009, 10010/L, H3510, G6215, H6220, JH11, 6248P, 3507).</li> <li>Control Mode: MIT, POS_VEL, VEL, FORCE_POS. Row visibility depends on mode: Position, Velocity, Stiffness, Damping, Torque for MIT; Position + Velocity Limit for POS_VEL; Velocity for VEL; Vel Limit and Torque Limit Ratio for FORCE_POS.</li> <li>FORCE_POS Torque Limit Ratio meaning: <code>torque_limit_ratio</code> is normalized (0.0-1.0). The effective torque clip is <code>tau_lim = torque_limit_ratio * T_max(motor_type)</code>.</li> <li>Enable / Disable: Enable or disable the motor.</li> <li>Send Command: Applies the current control parameters. Single: once. Continuous: at the set Command Frequency (1\u20131000 Hz).</li> <li>Stop Command: Stops Continuous mode and disables the motor.</li> <li>Set Zero: Saves the current position as zero.</li> <li>Clear Error: Clears the motor error.</li> </ul>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#motor-feedback","title":"Motor Feedback","text":"<ul> <li>Status (e.g. ENABLED, DISABLED) and live Position, Velocity, Torque, MOS Temp, Rotor Temp for the selected motor.</li> </ul>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#register-parameters","title":"Register Parameters","text":"<ul> <li>Table: Description, Value, Type, Action. Read-only (RO) registers have no Edit. Writable (RW) registers: click Edit, change the value, then Save or Cancel.</li> <li>Special UIs: Feedback ID and Motor ID use hex input; Control mode and CAN baud rate use dropdowns. Changing Feedback ID or Motor ID triggers a rescan so the motor list stays correct.</li> </ul>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#chart-visualizations","title":"Chart Visualizations","text":"<p>Three line charts: Position (rad), Velocity (rad/s), Torque (Nm). Live data when a motor is selected (and when sending commands in Continuous mode).</p> <p>For each chart:</p> <ul> <li>Export Data: Save the visible data as CSV.</li> <li>Grid: Toggle grid on/off.</li> <li>Duration (s): Time window on the X-axis.</li> <li>Y Min / Y Max: Set Y-axis limits, or \"Auto\".</li> <li>Reset Limits: Restore Y-axis to the motor\u2019s limits or auto.</li> <li>Points: Toggle data points.</li> </ul> <p>Charts support zoom (scroll or pinch). Each chart shows live data over the set time window.</p> <p></p>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#export-chart-data","title":"Export Chart Data","text":"<p>Clicking Export Data on a chart opens a modal: enter a file name and Save to download a CSV of the chart\u2019s visible data. The file is saved to your default download folder.</p> <p></p>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#register-editing-details","title":"Register editing (details)","text":"<ul> <li>RO: Shown in gray; no Edit button.</li> <li>RW: Click Edit, change the value (or choose from the dropdown for Control mode and CAN baud rate), then Save or Cancel. Changing Feedback ID or Motor ID triggers a rescan so the motor list stays correct.</li> </ul>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#safety-notes","title":"Safety notes","text":"<p>Safety First</p> <ul> <li>Verify CAN interface and motor wiring before Connect.</li> <li>Ensure the motor is securely mounted and the area is clear before Enable and Continuous commands.</li> <li>Always verify register values before writing; some changes take effect immediately.</li> <li>Changing Motor ID or Feedback ID changes how the motor is identified; the GUI rescans automatically.</li> <li>Test register and command changes in a safe environment before production use.</li> </ul>","tags":["usage","gui","web"]}]}