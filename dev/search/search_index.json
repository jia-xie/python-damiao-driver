{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DaMiao Motor","text":"<p>Safety</p> <p>Commands can move hardware immediately. Use a secure setup and keep clear of moving parts.</p>","tags":["getting-started","overview"]},{"location":"#what-you-can-do","title":"What you can do","text":"<ul> <li>CLI Tools</li> </ul> <p>Use <code>damiao</code> commands to scan, command, and configure motors.</p> <ul> <li>Web GUI</li> </ul> <p>Monitor live position, velocity, torque, and edit writable registers.</p> <ul> <li>Python API</li> </ul> <p>Build robust control loops and automate multi-motor workflows.</p> <ul> <li>Motor Control Modes</li> </ul> <p>Understand MIT, POS_VEL, VEL, and FORCE_POS behavior in detail.</p>","tags":["getting-started","overview"]},{"location":"#control-laws-preview","title":"Control laws preview","text":"<p>The MIT mode combines position error, velocity error, and feedforward torque:</p> <pre><code>T_ref  = Kp * (p_des - theta_m) + Kd * (v_des - dtheta_m) + tau_ff\niq_ref = T_ref / K_T\nid_ref = 0\n</code></pre> <p>See all control law diagrams:</p> <ul> <li>MIT mode</li> <li>POS_VEL mode</li> <li>VEL mode</li> <li>FORCE_POS mode</li> </ul>","tags":["getting-started","overview"]},{"location":"#installation","title":"Installation","text":"","tags":["getting-started","overview"]},{"location":"#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install damiao-motor\n</code></pre>","tags":["getting-started","overview"]},{"location":"#install-from-source","title":"Install from source","text":"<p>For latest repository updates:</p> <pre><code>git clone https://github.com/jia-xie/python-damiao-driver.git\ncd python-damiao-driver\npip install -e .\n</code></pre>","tags":["getting-started","overview"]},{"location":"#verify-installation","title":"Verify Installation","text":"<pre><code>python -c \"import damiao_motor; print(damiao_motor.__version__)\"\n</code></pre> <p>Then verify CLI availability:</p> <pre><code>damiao --help\n</code></pre>","tags":["getting-started","overview"]},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Hardware Setup - CAN interface setup</li> <li>Package Tools - Using the CLI tools</li> </ul>","tags":["getting-started","overview"]},{"location":"api/cli/","title":"CLI Module API","text":"<p>This page documents the Python API for the CLI module. For user-facing CLI documentation, see the CLI Tool.</p>","tags":["api","reference","cli"]},{"location":"api/cli/#main-entry-point","title":"Main Entry Point","text":"","tags":["api","reference","cli"]},{"location":"api/cli/#damiao_motor.cli.unified_main","title":"damiao_motor.cli.unified_main","text":"<pre><code>unified_main() -&gt; None\n</code></pre> <p>Unified CLI entry point with subcommands.</p> <p>Main entry point for the <code>damiao</code> command-line tool. Provides a unified interface for scanning, configuring, and controlling DaMiao motors over CAN bus.</p> Available commands <ul> <li>scan: Scan for connected motors</li> <li>send-cmd-mit: Send MIT control mode command</li> <li>send-cmd-pos-vel: Send POS_VEL control mode command</li> <li>send-cmd-vel: Send VEL control mode command</li> <li>send-cmd-force-pos: Send FORCE_POS control mode command</li> <li>set-zero-command: Send zero command continuously</li> <li>set-zero-position: Set current position to zero</li> <li>set-can-timeout: Set CAN timeout alarm time</li> <li>set-motor-id: Change motor receive ID</li> <li>set-feedback-id: Change motor feedback ID</li> <li>gui: Launch web-based GUI for motor control</li> </ul> <p>Global options (available for all commands):     - --version: Show version number and exit     - --channel: CAN channel (default: can0)     - --bustype: CAN bus type (default: socketcan)     - --bitrate: CAN bitrate in bits per second (default: 1000000)</p> <p>Examples:</p> <pre><code># Scan for motors\ndamiao scan\n\n# Send MIT command\ndamiao send-cmd-mit --id 1 --position 1.5 --velocity 0.0 --stiffness 3.0 --damping 0.5\n\n# Set current position to zero\ndamiao set-zero-position --id 1\n</code></pre> Source code in <code>damiao_motor/cli/__init__.py</code> <pre><code>def unified_main() -&gt; None:\n    \"\"\"\n    Unified CLI entry point with subcommands.\n\n    Main entry point for the `damiao` command-line tool. Provides a unified interface\n    for scanning, configuring, and controlling DaMiao motors over CAN bus.\n\n    Available commands:\n        - scan: Scan for connected motors\n        - send-cmd-mit: Send MIT control mode command\n        - send-cmd-pos-vel: Send POS_VEL control mode command\n        - send-cmd-vel: Send VEL control mode command\n        - send-cmd-force-pos: Send FORCE_POS control mode command\n        - set-zero-command: Send zero command continuously\n        - set-zero-position: Set current position to zero\n        - set-can-timeout: Set CAN timeout alarm time\n        - set-motor-id: Change motor receive ID\n        - set-feedback-id: Change motor feedback ID\n        - gui: Launch web-based GUI for motor control\n\n    Global options (available for all commands):\n        - --version: Show version number and exit\n        - --channel: CAN channel (default: can0)\n        - --bustype: CAN bus type (default: socketcan)\n        - --bitrate: CAN bitrate in bits per second (default: 1000000)\n\n    Examples:\n        ```bash\n        # Scan for motors\n        damiao scan\n\n        # Send MIT command\n        damiao send-cmd-mit --id 1 --position 1.5 --velocity 0.0 --stiffness 3.0 --damping 0.5\n\n        # Set current position to zero\n        damiao set-zero-position --id 1\n        ```\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"DaMiao Motor CLI Tool - Control and configure DaMiao motors over CAN bus\",\n        formatter_class=ColorizedHelpFormatter,\n        epilog=\"\"\"\nFor more information about a specific command, use:\n  damiao &lt;command&gt; --help\n        \"\"\",\n    )\n\n    # Global arguments\n    parser.add_argument(\n        \"--version\",\n        action=\"version\",\n        version=f\"{__version__}\",\n        help=\"Show version number\",\n    )\n    parser.add_argument(\n        \"--channel\",\n        type=str,\n        default=\"can0\",\n        help=\"CAN channel (default: can0)\",\n    )\n    parser.add_argument(\n        \"--bustype\",\n        type=str,\n        default=\"socketcan\",\n        help=\"CAN bus type (default: socketcan)\",\n    )\n    parser.add_argument(\n        \"--bitrate\",\n        type=int,\n        default=1000000,\n        help=\"CAN bitrate in bits per second (default: 1000000). Only used when bringing up interface.\",\n    )\n\n    subparsers = parser.add_subparsers(\n        dest=\"command\",\n        help=\"Available commands\",\n        required=True,\n        metavar=\"COMMAND\",\n        title=\"Commands\",\n        description=\"Use 'damiao &lt;command&gt; --help' for more information about a specific command.\",\n    )\n\n    # gui command (highlighted - listed first)\n    gui_parser = subparsers.add_parser(\n        \"gui\",\n        help=\"Launch web-based GUI for motor control (recommended)\",\n        description=\"Launch the web-based GUI for viewing and controlling DaMiao motors.\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Start GUI on default host and port (http://127.0.0.1:5000)\n  damiao gui\n\n  # Start GUI on custom port\n  damiao gui --port 8080\n\n  # Start GUI on all interfaces\n  damiao gui --host 0.0.0.0\n\n  # Start GUI with production server (requires waitress)\n  damiao gui --production\n\n  # Start GUI with debug mode\n  damiao gui --debug\n        \"\"\",\n    )\n    gui_parser.add_argument(\n        \"--host\",\n        type=str,\n        default=\"127.0.0.1\",\n        help=\"Host to bind to (default: 127.0.0.1)\",\n    )\n    gui_parser.add_argument(\n        \"--port\",\n        type=int,\n        default=5000,\n        help=\"Port to bind to (default: 5000)\",\n    )\n    gui_parser.add_argument(\n        \"--debug\",\n        action=\"store_true\",\n        help=\"Enable debug mode\",\n    )\n    gui_parser.add_argument(\n        \"--production\",\n        action=\"store_true\",\n        help=\"Use production WSGI server (requires waitress)\",\n    )\n    gui_parser.set_defaults(func=cmd_gui)\n\n    # Helper function to add global arguments to subcommands\n    def add_global_args(subparser):\n        \"\"\"Add global arguments to a subcommand parser.\"\"\"\n        subparser.add_argument(\n            \"--channel\",\n            type=str,\n            default=\"can0\",\n            help=\"CAN channel (default: can0)\",\n        )\n        subparser.add_argument(\n            \"--bustype\",\n            type=str,\n            default=\"socketcan\",\n            help=\"CAN bus type (default: socketcan)\",\n        )\n        subparser.add_argument(\n            \"--bitrate\",\n            type=int,\n            default=1000000,\n            help=\"CAN bitrate in bits per second (default: 1000000). Only used when bringing up interface.\",\n        )\n        subparser.add_argument(\n            \"--motor-type\",\n            type=str,\n            default=\"4340\",\n            choices=[\n                \"4310\",\n                \"4310P\",\n                \"4340\",\n                \"4340P\",\n                \"6006\",\n                \"8006\",\n                \"8009\",\n                \"10010L\",\n                \"10010\",\n                \"H3510\",\n                \"G6215\",\n                \"H6220\",\n                \"JH11\",\n                \"6248P\",\n                \"3507\",\n            ],\n            dest=\"motor_type\",\n            help=\"Motor type for P/V/T presets (e.g. 4340, 4310, 3507). Defaults to 4340. Only needed for encoding commands; doesn't affect which motors are detected during scan.\",\n        )\n\n    # scan command\n    scan_parser = subparsers.add_parser(\n        \"scan\",\n        help=\"Scan for connected motors on CAN bus\",\n        description=\"Scan for connected motors on CAN bus by sending zero commands and listening for responses.\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Scan default ID range (0x01-0x10) - motor-type is optional\n  damiao scan\n\n  # Scan specific motor IDs\n  damiao scan --ids 1 2 3\n\n  # Scan with longer listen duration\n  damiao scan --duration 2.0\n\n  # Scan with specific motor type (optional, defaults to 4310)\n  damiao scan --motor-type 4340\n\n  # Scan with debug output (print all raw CAN messages)\n  damiao scan --debug\n        \"\"\",\n    )\n    scan_parser.add_argument(\n        \"--ids\",\n        type=int,\n        nargs=\"+\",\n        metavar=\"ID\",\n        help=\"Motor IDs to test (e.g., --ids 1 2 3). If not specified, tests IDs 0x01-0x10.\",\n    )\n    scan_parser.add_argument(\n        \"--duration\",\n        type=float,\n        default=0.5,\n        help=\"Duration to listen for responses in seconds (default: 0.5)\",\n    )\n    scan_parser.add_argument(\n        \"--debug\",\n        action=\"store_true\",\n        help=\"Print all raw CAN messages for debugging.\",\n    )\n    # Add global args (channel, bustype, bitrate) but NOT motor-type\n    scan_parser.add_argument(\n        \"--channel\",\n        type=str,\n        default=\"can0\",\n        help=\"CAN channel (default: can0)\",\n    )\n    scan_parser.add_argument(\n        \"--bustype\",\n        type=str,\n        default=\"socketcan\",\n        help=\"CAN bus type (default: socketcan)\",\n    )\n    scan_parser.add_argument(\n        \"--bitrate\",\n        type=int,\n        default=1000000,\n        help=\"CAN bitrate in bits per second (default: 1000000). Only used when bringing up interface.\",\n    )\n    # Motor type is optional for scan (defaults to 4310)\n    scan_parser.add_argument(\n        \"--motor-type\",\n        type=str,\n        default=\"4310\",\n        choices=[\n            \"4310\",\n            \"4310P\",\n            \"4340\",\n            \"4340P\",\n            \"6006\",\n            \"8006\",\n            \"8009\",\n            \"10010L\",\n            \"10010\",\n            \"H3510\",\n            \"G6215\",\n            \"H6220\",\n            \"JH11\",\n            \"6248P\",\n            \"3507\",\n        ],\n        dest=\"motor_type\",\n        help=\"Motor type for P/V/T presets (default: 4310). Only used for encoding zero commands; doesn't affect which motors are detected.\",\n    )\n    scan_parser.set_defaults(func=cmd_scan)\n\n    # set-zero-command (renamed from set-zero)\n    zero_parser = subparsers.add_parser(\n        \"set-zero-command\",\n        help=\"Send zero command to a motor\",\n        description=\"Send a zero command continuously to a motor.\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Send zero command continuously (loops until Ctrl+C)\n  damiao set-zero-command --id 1\n\n  # With custom frequency\n  damiao set-zero-command --id 1 --frequency 50.0\n        \"\"\",\n    )\n    zero_parser.add_argument(\n        \"--id\",\n        type=int,\n        required=True,\n        dest=\"motor_id\",\n        help=\"Motor ID to send zero command to\",\n    )\n    zero_parser.add_argument(\n        \"--frequency\",\n        type=float,\n        default=100.0,\n        help=\"Command frequency in Hz (default: 100.0)\",\n    )\n    add_global_args(zero_parser)\n    zero_parser.set_defaults(func=cmd_set_zero)\n\n    # set-zero-position command\n    zero_pos_parser = subparsers.add_parser(\n        \"set-zero-position\",\n        help=\"Set current position to zero\",\n        description=\"Set the current output shaft position to zero (save position zero).\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Set current position to zero\n  damiao set-zero-position --id 1\n        \"\"\",\n    )\n    zero_pos_parser.add_argument(\n        \"--id\",\n        type=int,\n        required=True,\n        dest=\"motor_id\",\n        help=\"Motor ID\",\n    )\n    add_global_args(zero_pos_parser)\n    zero_pos_parser.set_defaults(func=cmd_set_zero_position)\n\n    # set-can-timeout command\n    timeout_parser = subparsers.add_parser(\n        \"set-can-timeout\",\n        help=\"Set CAN timeout alarm time (register 9)\",\n        description=\"Set the CAN timeout alarm time in milliseconds. Register 9 uses units of 50 microseconds (1 unit = 50us).\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Set CAN timeout to 1000 ms\n  damiao set-can-timeout --id 1 --timeout 1000\n        \"\"\",\n    )\n    timeout_parser.add_argument(\n        \"--id\",\n        type=int,\n        required=True,\n        dest=\"motor_id\",\n        help=\"Motor ID\",\n    )\n    timeout_parser.add_argument(\n        \"--timeout\",\n        type=int,\n        required=True,\n        dest=\"timeout_ms\",\n        help=\"Timeout in milliseconds (ms)\",\n    )\n    add_global_args(timeout_parser)\n    timeout_parser.set_defaults(func=cmd_set_can_timeout)\n\n    # set-motor-id command\n    set_motor_id_parser = subparsers.add_parser(\n        \"set-motor-id\",\n        help=\"Set motor receive ID (register 8)\",\n        description=\"Change the motor's receive ID (ESC_ID, register 8). This is the ID used to send commands to the motor.\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Change motor ID from 1 to 2\n  damiao set-motor-id --current 1 --target 2\n\nNote: After changing the motor ID, you will need to use the new ID to communicate with the motor.\n        \"\"\",\n    )\n    set_motor_id_parser.add_argument(\n        \"--current\",\n        type=int,\n        required=True,\n        help=\"Current motor ID (to connect to the motor)\",\n    )\n    set_motor_id_parser.add_argument(\n        \"--target\",\n        type=int,\n        required=True,\n        help=\"Target motor ID (new receive ID)\",\n    )\n    add_global_args(set_motor_id_parser)\n    set_motor_id_parser.set_defaults(func=cmd_set_motor_id)\n\n    # set-feedback-id command\n    set_feedback_id_parser = subparsers.add_parser(\n        \"set-feedback-id\",\n        help=\"Set motor feedback ID (register 7)\",\n        description=\"Change the motor's feedback ID (MST_ID, register 7). This is the ID used to identify feedback messages from the motor.\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Change feedback ID to 3 (using motor ID 1 to connect)\n  damiao set-feedback-id --current 1 --target 3\n\nNote: The motor will now respond with feedback using the new feedback ID.\n        \"\"\",\n    )\n    set_feedback_id_parser.add_argument(\n        \"--current\",\n        type=int,\n        required=True,\n        help=\"Current motor ID (to connect to the motor)\",\n    )\n    set_feedback_id_parser.add_argument(\n        \"--target\",\n        type=int,\n        required=True,\n        help=\"Target feedback ID (new MST_ID)\",\n    )\n    add_global_args(set_feedback_id_parser)\n    set_feedback_id_parser.set_defaults(func=cmd_set_feedback_id)\n\n    # send-cmd-mit command\n    send_cmd_mit_parser = subparsers.add_parser(\n        \"send-cmd-mit\",\n        help=\"Send MIT control mode command to motor\",\n        description=\"Send MIT control mode command to motor. Loops continuously until Ctrl+C.\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # MIT mode with all parameters\n  damiao send-cmd-mit --id 1 --position 1.5 --velocity 0.0 --stiffness 3.0 --damping 0.5\n\n  # With custom frequency\n  damiao send-cmd-mit --id 1 --position 1.5 --velocity 0.0 --stiffness 3.0 --damping 0.5 --frequency 50.0\n        \"\"\",\n    )\n    send_cmd_mit_parser.add_argument(\n        \"--id\",\n        type=int,\n        required=True,\n        dest=\"motor_id\",\n        help=\"Motor ID\",\n    )\n    send_cmd_mit_parser.add_argument(\n        \"--position\",\n        type=float,\n        required=True,\n        help=\"Desired position (radians)\",\n    )\n    send_cmd_mit_parser.add_argument(\n        \"--velocity\",\n        type=float,\n        required=True,\n        help=\"Desired velocity (rad/s)\",\n    )\n    send_cmd_mit_parser.add_argument(\n        \"--stiffness\",\n        type=float,\n        default=0.0,\n        dest=\"stiffness\",\n        help=\"Stiffness (kp), range 0\u2013500 (default: 0.0)\",\n    )\n    send_cmd_mit_parser.add_argument(\n        \"--damping\",\n        type=float,\n        default=0.0,\n        dest=\"damping\",\n        help=\"Damping (kd), range 0\u20135 (default: 0.0)\",\n    )\n    send_cmd_mit_parser.add_argument(\n        \"--feedforward-torque\",\n        type=float,\n        default=0.0,\n        dest=\"feedforward_torque\",\n        help=\"Feedforward torque (default: 0.0)\",\n    )\n    send_cmd_mit_parser.add_argument(\n        \"--frequency\",\n        type=float,\n        default=100.0,\n        help=\"Command frequency in Hz (default: 100.0)\",\n    )\n    add_global_args(send_cmd_mit_parser)\n    send_cmd_mit_parser.set_defaults(func=cmd_send_cmd_mit)\n\n    # send-cmd-pos-vel command\n    send_cmd_pos_vel_parser = subparsers.add_parser(\n        \"send-cmd-pos-vel\",\n        help=\"Send POS_VEL control mode command to motor\",\n        description=\"Send POS_VEL control mode command to motor. Loops continuously until Ctrl+C.\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # POS_VEL mode\n  damiao send-cmd-pos-vel --id 1 --position 1.5 --velocity-limit 2.0\n\n  # With custom frequency\n  damiao send-cmd-pos-vel --id 1 --position 1.5 --velocity-limit 2.0 --frequency 50.0\n        \"\"\",\n    )\n    send_cmd_pos_vel_parser.add_argument(\n        \"--id\",\n        type=int,\n        required=True,\n        dest=\"motor_id\",\n        help=\"Motor ID\",\n    )\n    send_cmd_pos_vel_parser.add_argument(\n        \"--position\",\n        type=float,\n        required=True,\n        help=\"Desired position (radians)\",\n    )\n    send_cmd_pos_vel_parser.add_argument(\n        \"--velocity-limit\",\n        type=float,\n        required=True,\n        dest=\"velocity_limit\",\n        help=\"Maximum velocity during motion (rad/s)\",\n    )\n    send_cmd_pos_vel_parser.add_argument(\n        \"--frequency\",\n        type=float,\n        default=100.0,\n        help=\"Command frequency in Hz (default: 100.0)\",\n    )\n    add_global_args(send_cmd_pos_vel_parser)\n    send_cmd_pos_vel_parser.set_defaults(func=cmd_send_cmd_pos_vel)\n\n    # send-cmd-vel command\n    send_cmd_vel_parser = subparsers.add_parser(\n        \"send-cmd-vel\",\n        help=\"Send VEL control mode command to motor\",\n        description=\"Send VEL control mode command to motor. Loops continuously until Ctrl+C.\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # VEL mode\n  damiao send-cmd-vel --id 1 --velocity 3.0\n\n  # With custom frequency\n  damiao send-cmd-vel --id 1 --velocity 3.0 --frequency 50.0\n        \"\"\",\n    )\n    send_cmd_vel_parser.add_argument(\n        \"--id\",\n        type=int,\n        required=True,\n        dest=\"motor_id\",\n        help=\"Motor ID\",\n    )\n    send_cmd_vel_parser.add_argument(\n        \"--velocity\",\n        type=float,\n        required=True,\n        help=\"Desired velocity (rad/s)\",\n    )\n    send_cmd_vel_parser.add_argument(\n        \"--frequency\",\n        type=float,\n        default=100.0,\n        help=\"Command frequency in Hz (default: 100.0)\",\n    )\n    add_global_args(send_cmd_vel_parser)\n    send_cmd_vel_parser.set_defaults(func=cmd_send_cmd_vel)\n\n    # send-cmd-force-pos command\n    send_cmd_force_pos_parser = subparsers.add_parser(\n        \"send-cmd-force-pos\",\n        help=\"Send FORCE_POS control mode command to motor\",\n        description=\"Send FORCE_POS control mode command to motor. Loops continuously until Ctrl+C.\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # FORCE_POS mode\n  damiao send-cmd-force-pos --id 1 --position 1.5 --velocity-limit 50.0 --torque-limit-ratio 0.8\n\n  # With custom frequency\n  damiao send-cmd-force-pos --id 1 --position 1.5 --velocity-limit 50.0 --torque-limit-ratio 0.8 --frequency 50.0\n        \"\"\",\n    )\n    send_cmd_force_pos_parser.add_argument(\n        \"--id\",\n        type=int,\n        required=True,\n        dest=\"motor_id\",\n        help=\"Motor ID\",\n    )\n    send_cmd_force_pos_parser.add_argument(\n        \"--position\",\n        type=float,\n        required=True,\n        help=\"Desired position (radians)\",\n    )\n    send_cmd_force_pos_parser.add_argument(\n        \"--velocity-limit\",\n        type=float,\n        required=True,\n        dest=\"velocity_limit\",\n        help=\"Velocity limit (rad/s, 0-100)\",\n    )\n    send_cmd_force_pos_parser.add_argument(\n        \"--torque-limit-ratio\",\n        type=float,\n        required=True,\n        dest=\"torque_limit_ratio\",\n        help=\"Normalized torque-limit coefficient (0.0-1.0)\",\n    )\n    send_cmd_force_pos_parser.add_argument(\n        \"--frequency\",\n        type=float,\n        default=100.0,\n        help=\"Command frequency in Hz (default: 100.0)\",\n    )\n    add_global_args(send_cmd_force_pos_parser)\n    send_cmd_force_pos_parser.set_defaults(func=cmd_send_cmd_force_pos)\n\n    args = parser.parse_args()\n\n    # Execute the appropriate command\n    try:\n        args.func(args)\n    except KeyboardInterrupt:\n        print(\"\\n\\nInterrupted by user.\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"\\n\\nError: {e}\")\n        sys.exit(1)\n</code></pre>","tags":["api","reference","cli"]},{"location":"api/cli/#command-handlers","title":"Command Handlers","text":"","tags":["api","reference","cli"]},{"location":"api/cli/#damiao_motor.cli.commands.cmd_scan","title":"damiao_motor.cli.commands.cmd_scan","text":"<pre><code>cmd_scan(args) -&gt; None\n</code></pre> <p>Handle 'scan' subcommand.</p> <p>Scans for connected motors on the CAN bus by sending zero commands and listening for feedback.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Parsed command-line arguments containing: - channel: CAN channel (default: can0) - bustype: CAN bus type (default: socketcan) - ids: Optional list of motor IDs to test (default: 0x01-0x10) - duration: Duration to listen for responses in seconds (default: 0.5) - bitrate: CAN bitrate in bits per second (default: 1000000) - debug: Print all raw CAN messages for debugging (default: False)</p> required Source code in <code>damiao_motor/cli/commands.py</code> <pre><code>def cmd_scan(args) -&gt; None:\n    \"\"\"\n    Handle 'scan' subcommand.\n\n    Scans for connected motors on the CAN bus by sending zero commands and listening for feedback.\n\n    Args:\n        args: Parsed command-line arguments containing:\n            - channel: CAN channel (default: can0)\n            - bustype: CAN bus type (default: socketcan)\n            - ids: Optional list of motor IDs to test (default: 0x01-0x10)\n            - duration: Duration to listen for responses in seconds (default: 0.5)\n            - bitrate: CAN bitrate in bits per second (default: 1000000)\n            - debug: Print all raw CAN messages for debugging (default: False)\n    \"\"\"\n    # Print header and configuration in a single box\n    print()\n    top_border = f\"{BOX_CORNER_TL}{BOX_HORIZONTAL * 78}{BOX_CORNER_TR}\"\n    print(top_border)\n    # Header line\n    header_text = f\" {GREEN}DaMiao Motor Scanner{RESET}\"\n    print(f\"{BOX_VERTICAL}{pad_with_ansi(header_text, 78)}{BOX_VERTICAL}\")\n    # Separator line\n    print(f\"{BOX_JOIN_LEFT}{BOX_HORIZONTAL * 78}{BOX_JOIN_RIGHT}\")\n    # Configuration lines\n    config_lines = [\n        f\" CAN channel: {args.channel}\",\n        f\" Bus type: {args.bustype}\",\n        f\" Motor type: {args.motor_type} (for encoding only)\",\n        f\" Testing motor IDs: {', '.join([hex(i) for i in args.ids]) if args.ids else '0x01-0x10 (default range)'}\",\n        f\" Listen duration: {args.duration}s\",\n    ]\n    if args.debug:\n        config_lines.append(\" Debug mode: ENABLED (printing all raw CAN messages)\")\n\n    for line in config_lines:\n        print(f\"{BOX_VERTICAL}{pad_with_ansi(line, 78)}{BOX_VERTICAL}\")\n    bottom_border = f\"{BOX_CORNER_BL}{BOX_HORIZONTAL * 78}{BOX_CORNER_BR}\"\n    print(bottom_border)\n    print()\n\n    try:\n        responded = scan_motors(\n            channel=args.channel,\n            bustype=args.bustype,\n            motor_ids=args.ids,\n            duration_s=args.duration,\n            bitrate=args.bitrate,\n            debug=args.debug,\n            motor_type=args.motor_type,\n        )\n\n        # Print final summary\n        print()\n        if responded:\n            # Combined scan summary box\n            top_border = f\"{BOX_CORNER_TL}{BOX_HORIZONTAL * 78}{BOX_CORNER_TR}\"\n            print(top_border)\n            # Header line\n            header_text = f\" {GREEN}Scan Summary{RESET}\"\n            print(f\"{BOX_VERTICAL}{pad_with_ansi(header_text, 78)}{BOX_VERTICAL}\")\n            # Separator line\n            print(f\"{BOX_JOIN_LEFT}{BOX_HORIZONTAL * 78}{BOX_JOIN_RIGHT}\")\n            # Summary lines\n            summary_lines = [f\" Found {len(responded)} motor(s):\"]\n            for motor_id in sorted(responded):\n                summary_lines.append(f\"   \u2022 Motor ID: 0x{motor_id:02X} ({motor_id})\")\n            for line in summary_lines:\n                print(f\"{BOX_VERTICAL}{pad_with_ansi(line, 78)}{BOX_VERTICAL}\")\n            bottom_border = f\"{BOX_CORNER_BL}{BOX_HORIZONTAL * 78}{BOX_CORNER_BR}\"\n            print(bottom_border)\n        else:\n            summary_lines = [\n                \"No motors responded.\",\n                \"\",\n                \"Check:\",\n                \"  \u2022 CAN interface is up (e.g., sudo ip link set can0 up type can bitrate 1000000)\",\n                \"  \u2022 Motors are powered and connected\",\n                \"  \u2022 Motor IDs match the tested range\",\n            ]\n            print_warning_box(\"Scan Summary - No Motors Found\", summary_lines, width=80)\n\n    except KeyboardInterrupt:\n        print(\"\\n\\nInterrupted by user.\")\n    except Exception as e:\n        print(f\"\\n\\nError: {e}\")\n        raise\n</code></pre>","tags":["api","reference","cli"]},{"location":"api/cli/#damiao_motor.cli.commands.cmd_send_cmd_mit","title":"damiao_motor.cli.commands.cmd_send_cmd_mit","text":"<pre><code>cmd_send_cmd_mit(args) -&gt; None\n</code></pre> <p>Handle 'send-cmd-mit' subcommand.</p> <p>Sends MIT control mode command to motor. Loops continuously until Ctrl+C.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Parsed command-line arguments containing: - motor_id: Motor ID (required) - position: Desired position (radians) (required) - velocity: Desired velocity (rad/s) (required) - stiffness: Stiffness (kp) (default: 0.0) - damping: Damping (kd) (default: 0.0) - feedforward_torque: Feedforward torque (default: 0.0) - frequency: Command frequency in Hz (default: 100.0) - channel: CAN channel (default: can0) - bustype: CAN bus type (default: socketcan) - bitrate: CAN bitrate in bits per second (default: 1000000)</p> required Source code in <code>damiao_motor/cli/commands.py</code> <pre><code>def cmd_send_cmd_mit(args) -&gt; None:\n    \"\"\"\n    Handle 'send-cmd-mit' subcommand.\n\n    Sends MIT control mode command to motor. Loops continuously until Ctrl+C.\n\n    Args:\n        args: Parsed command-line arguments containing:\n            - motor_id: Motor ID (required)\n            - position: Desired position (radians) (required)\n            - velocity: Desired velocity (rad/s) (required)\n            - stiffness: Stiffness (kp) (default: 0.0)\n            - damping: Damping (kd) (default: 0.0)\n            - feedforward_torque: Feedforward torque (default: 0.0)\n            - frequency: Command frequency in Hz (default: 100.0)\n            - channel: CAN channel (default: can0)\n            - bustype: CAN bus type (default: socketcan)\n            - bitrate: CAN bitrate in bits per second (default: 1000000)\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"DaMiao Motor - Send MIT Command\")\n    print(\"=\" * 60)\n    print(f\"CAN channel: {args.channel}\")\n    print(f\"Motor ID: 0x{args.motor_id:02X} ({args.motor_id})\")\n    print(\"Control Mode: MIT\")\n    print(f\"  Position: {args.position:.6f} rad\")\n    print(f\"  Velocity: {args.velocity:.6f} rad/s\")\n    print(f\"  Stiffness (kp): {args.stiffness:.6f}\")\n    print(f\"  Damping (kd): {args.damping:.6f}\")\n    print(f\"  Feedforward Torque: {args.feedforward_torque:.6f} Nm\")\n    print(f\"Frequency: {args.frequency} Hz\")\n    print(\"=\" * 60)\n    print()\n\n    # Check and bring up CAN interface if needed\n    if args.bustype == \"socketcan\":\n        if not check_and_bring_up_can_interface(args.channel, bitrate=args.bitrate):\n            print(\n                f\"\u26a0 Warning: Could not verify {args.channel} is ready. Continuing anyway...\"\n            )\n\n    controller = DaMiaoController(channel=args.channel, bustype=args.bustype)\n\n    try:\n        motor = controller.add_motor(\n            motor_id=args.motor_id, feedback_id=0x00, motor_type=args.motor_type\n        )\n        motor.ensure_control_mode(\"MIT\")\n\n        print(\"Sending MIT command continuously (press Ctrl+C to stop)...\")\n        print(f\"  CAN ID: 0x{args.motor_id:03X}\")\n        print(f\"  Frequency: {args.frequency} Hz\")\n        print()\n\n        interval = 1.0 / args.frequency if args.frequency &gt; 0 else 0.01\n\n        try:\n            while True:\n                motor.send_cmd_mit(\n                    target_position=args.position,\n                    target_velocity=args.velocity,\n                    stiffness=args.stiffness,\n                    damping=args.damping,\n                    feedforward_torque=args.feedforward_torque,\n                )\n                controller.poll_feedback()\n\n                if motor.state:\n                    print_motor_state(motor.state)\n\n                time.sleep(interval)\n        except KeyboardInterrupt:\n            print(\"\\n\\nStopped by user.\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n        raise\n    finally:\n        print(\"Shutting down controller...\")\n        controller.shutdown()\n</code></pre>","tags":["api","reference","cli"]},{"location":"api/cli/#damiao_motor.cli.commands.cmd_send_cmd_pos_vel","title":"damiao_motor.cli.commands.cmd_send_cmd_pos_vel","text":"<pre><code>cmd_send_cmd_pos_vel(args) -&gt; None\n</code></pre> <p>Handle 'send-cmd-pos-vel' subcommand.</p> <p>Sends POS_VEL control mode command to motor. Loops continuously until Ctrl+C.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Parsed command-line arguments containing: - motor_id: Motor ID (required) - position: Desired position (radians) (required) - velocity_limit: Maximum velocity during motion (rad/s) (required) - frequency: Command frequency in Hz (default: 100.0) - channel: CAN channel (default: can0) - bustype: CAN bus type (default: socketcan) - bitrate: CAN bitrate in bits per second (default: 1000000)</p> required Source code in <code>damiao_motor/cli/commands.py</code> <pre><code>def cmd_send_cmd_pos_vel(args) -&gt; None:\n    \"\"\"\n    Handle 'send-cmd-pos-vel' subcommand.\n\n    Sends POS_VEL control mode command to motor. Loops continuously until Ctrl+C.\n\n    Args:\n        args: Parsed command-line arguments containing:\n            - motor_id: Motor ID (required)\n            - position: Desired position (radians) (required)\n            - velocity_limit: Maximum velocity during motion (rad/s) (required)\n            - frequency: Command frequency in Hz (default: 100.0)\n            - channel: CAN channel (default: can0)\n            - bustype: CAN bus type (default: socketcan)\n            - bitrate: CAN bitrate in bits per second (default: 1000000)\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"DaMiao Motor - Send POS_VEL Command\")\n    print(\"=\" * 60)\n    print(f\"CAN channel: {args.channel}\")\n    print(f\"Motor ID: 0x{args.motor_id:02X} ({args.motor_id})\")\n    print(\"Control Mode: POS_VEL\")\n    print(f\"  Position: {args.position:.6f} rad\")\n    print(f\"  Velocity Limit: {args.velocity_limit:.6f} rad/s\")\n    print(f\"Frequency: {args.frequency} Hz\")\n    print(\"=\" * 60)\n    print()\n\n    # Check and bring up CAN interface if needed\n    if args.bustype == \"socketcan\":\n        if not check_and_bring_up_can_interface(args.channel, bitrate=args.bitrate):\n            print(\n                f\"\u26a0 Warning: Could not verify {args.channel} is ready. Continuing anyway...\"\n            )\n\n    controller = DaMiaoController(channel=args.channel, bustype=args.bustype)\n\n    try:\n        motor = controller.add_motor(\n            motor_id=args.motor_id, feedback_id=0x00, motor_type=args.motor_type\n        )\n        motor.ensure_control_mode(\"POS_VEL\")\n\n        print(\"Sending POS_VEL command continuously (press Ctrl+C to stop)...\")\n        print(f\"  CAN ID: 0x{0x100 + args.motor_id:03X}\")\n        print(f\"  Frequency: {args.frequency} Hz\")\n        print()\n\n        interval = 1.0 / args.frequency if args.frequency &gt; 0 else 0.01\n\n        try:\n            while True:\n                motor.send_cmd_pos_vel(\n                    target_position=args.position,\n                    velocity_limit=args.velocity_limit,\n                )\n                controller.poll_feedback()\n\n                if motor.state:\n                    print_motor_state(motor.state)\n\n                time.sleep(interval)\n        except KeyboardInterrupt:\n            print(\"\\n\\nStopped by user.\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n        raise\n    finally:\n        print(\"Shutting down controller...\")\n        controller.shutdown()\n</code></pre>","tags":["api","reference","cli"]},{"location":"api/cli/#damiao_motor.cli.commands.cmd_send_cmd_vel","title":"damiao_motor.cli.commands.cmd_send_cmd_vel","text":"<pre><code>cmd_send_cmd_vel(args) -&gt; None\n</code></pre> <p>Handle 'send-cmd-vel' subcommand.</p> <p>Sends VEL control mode command to motor. Loops continuously until Ctrl+C.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Parsed command-line arguments containing: - motor_id: Motor ID (required) - velocity: Desired velocity (rad/s) (required) - frequency: Command frequency in Hz (default: 100.0) - channel: CAN channel (default: can0) - bustype: CAN bus type (default: socketcan) - bitrate: CAN bitrate in bits per second (default: 1000000)</p> required Source code in <code>damiao_motor/cli/commands.py</code> <pre><code>def cmd_send_cmd_vel(args) -&gt; None:\n    \"\"\"\n    Handle 'send-cmd-vel' subcommand.\n\n    Sends VEL control mode command to motor. Loops continuously until Ctrl+C.\n\n    Args:\n        args: Parsed command-line arguments containing:\n            - motor_id: Motor ID (required)\n            - velocity: Desired velocity (rad/s) (required)\n            - frequency: Command frequency in Hz (default: 100.0)\n            - channel: CAN channel (default: can0)\n            - bustype: CAN bus type (default: socketcan)\n            - bitrate: CAN bitrate in bits per second (default: 1000000)\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"DaMiao Motor - Send VEL Command\")\n    print(\"=\" * 60)\n    print(f\"CAN channel: {args.channel}\")\n    print(f\"Motor ID: 0x{args.motor_id:02X} ({args.motor_id})\")\n    print(\"Control Mode: VEL\")\n    print(f\"  Velocity: {args.velocity:.6f} rad/s\")\n    print(f\"Frequency: {args.frequency} Hz\")\n    print(\"=\" * 60)\n    print()\n\n    # Check and bring up CAN interface if needed\n    if args.bustype == \"socketcan\":\n        if not check_and_bring_up_can_interface(args.channel, bitrate=args.bitrate):\n            print(\n                f\"\u26a0 Warning: Could not verify {args.channel} is ready. Continuing anyway...\"\n            )\n\n    controller = DaMiaoController(channel=args.channel, bustype=args.bustype)\n\n    try:\n        motor = controller.add_motor(\n            motor_id=args.motor_id, feedback_id=0x00, motor_type=args.motor_type\n        )\n        motor.ensure_control_mode(\"VEL\")\n\n        print(\"Sending VEL command continuously (press Ctrl+C to stop)...\")\n        print(f\"  CAN ID: 0x{0x200 + args.motor_id:03X}\")\n        print(f\"  Frequency: {args.frequency} Hz\")\n        print()\n\n        interval = 1.0 / args.frequency if args.frequency &gt; 0 else 0.01\n\n        try:\n            while True:\n                motor.send_cmd_vel(\n                    target_velocity=args.velocity,\n                )\n                controller.poll_feedback()\n\n                if motor.state:\n                    print_motor_state(motor.state)\n\n                time.sleep(interval)\n        except KeyboardInterrupt:\n            print(\"\\n\\nStopped by user.\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n        raise\n    finally:\n        print(\"Shutting down controller...\")\n        controller.shutdown()\n</code></pre>","tags":["api","reference","cli"]},{"location":"api/cli/#damiao_motor.cli.commands.cmd_send_cmd_force_pos","title":"damiao_motor.cli.commands.cmd_send_cmd_force_pos","text":"<pre><code>cmd_send_cmd_force_pos(args) -&gt; None\n</code></pre> <p>Handle 'send-cmd-force-pos' subcommand.</p> <p>Sends FORCE_POS control mode command to motor. Loops continuously until Ctrl+C.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Parsed command-line arguments containing: - motor_id: Motor ID (required) - position: Desired position (radians) (required) - velocity_limit: Velocity limit (rad/s, 0-100) (required) - torque_limit_ratio: Normalized torque-limit coefficient (0.0-1.0) (required) - frequency: Command frequency in Hz (default: 100.0) - channel: CAN channel (default: can0) - bustype: CAN bus type (default: socketcan) - bitrate: CAN bitrate in bits per second (default: 1000000)</p> required Source code in <code>damiao_motor/cli/commands.py</code> <pre><code>def cmd_send_cmd_force_pos(args) -&gt; None:\n    \"\"\"\n    Handle 'send-cmd-force-pos' subcommand.\n\n    Sends FORCE_POS control mode command to motor. Loops continuously until Ctrl+C.\n\n    Args:\n        args: Parsed command-line arguments containing:\n            - motor_id: Motor ID (required)\n            - position: Desired position (radians) (required)\n            - velocity_limit: Velocity limit (rad/s, 0-100) (required)\n            - torque_limit_ratio: Normalized torque-limit coefficient (0.0-1.0) (required)\n            - frequency: Command frequency in Hz (default: 100.0)\n            - channel: CAN channel (default: can0)\n            - bustype: CAN bus type (default: socketcan)\n            - bitrate: CAN bitrate in bits per second (default: 1000000)\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"DaMiao Motor - Send FORCE_POS Command\")\n    print(\"=\" * 60)\n    print(f\"CAN channel: {args.channel}\")\n    print(f\"Motor ID: 0x{args.motor_id:02X} ({args.motor_id})\")\n    print(\"Control Mode: FORCE_POS\")\n    print(f\"  Position: {args.position:.6f} rad\")\n    print(f\"  Velocity Limit: {args.velocity_limit:.6f} rad/s\")\n    print(f\"  Torque Limit Ratio: {args.torque_limit_ratio:.6f}\")\n    print(f\"Frequency: {args.frequency} Hz\")\n    print(\"=\" * 60)\n    print()\n\n    # Check and bring up CAN interface if needed\n    if args.bustype == \"socketcan\":\n        if not check_and_bring_up_can_interface(args.channel, bitrate=args.bitrate):\n            print(\n                f\"\u26a0 Warning: Could not verify {args.channel} is ready. Continuing anyway...\"\n            )\n\n    controller = DaMiaoController(channel=args.channel, bustype=args.bustype)\n\n    try:\n        motor = controller.add_motor(\n            motor_id=args.motor_id, feedback_id=0x00, motor_type=args.motor_type\n        )\n        motor.ensure_control_mode(\"FORCE_POS\")\n\n        print(\"Sending FORCE_POS command continuously (press Ctrl+C to stop)...\")\n        print(f\"  CAN ID: 0x{0x300 + args.motor_id:03X}\")\n        print(f\"  Frequency: {args.frequency} Hz\")\n        print()\n\n        interval = 1.0 / args.frequency if args.frequency &gt; 0 else 0.01\n\n        try:\n            while True:\n                motor.send_cmd_force_pos(\n                    target_position=args.position,\n                    velocity_limit=args.velocity_limit,\n                    torque_limit_ratio=args.torque_limit_ratio,\n                )\n                controller.poll_feedback()\n\n                if motor.state:\n                    print_motor_state(motor.state)\n\n                time.sleep(interval)\n        except KeyboardInterrupt:\n            print(\"\\n\\nStopped by user.\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n        raise\n    finally:\n        print(\"Shutting down controller...\")\n        controller.shutdown()\n</code></pre>","tags":["api","reference","cli"]},{"location":"api/cli/#damiao_motor.cli.commands.cmd_set_zero","title":"damiao_motor.cli.commands.cmd_set_zero","text":"<pre><code>cmd_set_zero(args) -&gt; None\n</code></pre> <p>Handle 'set-zero-command' subcommand.</p> <p>Sends a zero command to a motor continuously. Loops until interrupted with Ctrl+C.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Parsed command-line arguments containing: - motor_id: Motor ID to send zero command to (required) - frequency: Command frequency in Hz (default: 100.0) - channel: CAN channel (default: can0) - bustype: CAN bus type (default: socketcan) - bitrate: CAN bitrate in bits per second (default: 1000000)</p> required Source code in <code>damiao_motor/cli/commands.py</code> <pre><code>def cmd_set_zero(args) -&gt; None:\n    \"\"\"\n    Handle 'set-zero-command' subcommand.\n\n    Sends a zero command to a motor continuously.\n    Loops until interrupted with Ctrl+C.\n\n    Args:\n        args: Parsed command-line arguments containing:\n            - motor_id: Motor ID to send zero command to (required)\n            - frequency: Command frequency in Hz (default: 100.0)\n            - channel: CAN channel (default: can0)\n            - bustype: CAN bus type (default: socketcan)\n            - bitrate: CAN bitrate in bits per second (default: 1000000)\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"DaMiao Motor - Set Zero Command\")\n    print(\"=\" * 60)\n    print(f\"CAN channel: {args.channel}\")\n    print(f\"Motor ID: 0x{args.motor_id:02X} ({args.motor_id})\")\n    print(\"=\" * 60)\n    print()\n\n    # Check and bring up CAN interface if needed\n    if args.bustype == \"socketcan\":\n        if not check_and_bring_up_can_interface(args.channel, bitrate=args.bitrate):\n            print(\n                f\"\u26a0 Warning: Could not verify {args.channel} is ready. Continuing anyway...\"\n            )\n\n    controller = DaMiaoController(channel=args.channel, bustype=args.bustype)\n\n    try:\n        motor = controller.add_motor(\n            motor_id=args.motor_id, feedback_id=0x00, motor_type=args.motor_type\n        )\n\n        # Ensure control mode is set to MIT (register 10 = 1) for zero command\n        try:\n            motor.ensure_control_mode(\"MIT\")\n        except Exception as e:\n            print(f\"\u26a0 Warning: Could not verify/set control mode: {e}\")\n            print(\"  Continuing anyway, but motor may not respond correctly.\")\n\n        print(\"Sending zero command continuously (press Ctrl+C to stop)...\")\n        print(\"  Command: pos=0, vel=0, torq=0, kp=0, kd=0\")\n        print(f\"  Frequency: {args.frequency} Hz\")\n        print()\n\n        interval = 1.0 / args.frequency if args.frequency &gt; 0 else 0.01\n\n        try:\n            while True:\n                motor.set_zero_command()\n                controller.poll_feedback()\n\n                if motor.state:\n                    print_motor_state(motor.state)\n\n                time.sleep(interval)\n        except KeyboardInterrupt:\n            print(\"\\n\\nStopped by user.\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n        raise\n    finally:\n        print(\"Shutting down controller...\")\n        controller.shutdown()\n</code></pre>","tags":["api","reference","cli"]},{"location":"api/cli/#damiao_motor.cli.commands.cmd_set_zero_position","title":"damiao_motor.cli.commands.cmd_set_zero_position","text":"<pre><code>cmd_set_zero_position(args) -&gt; None\n</code></pre> <p>Handle 'set-zero-position' subcommand.</p> <p>Sets the current output shaft position to zero (save position zero).</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Parsed command-line arguments containing: - motor_id: Motor ID (required) - channel: CAN channel (default: can0) - bustype: CAN bus type (default: socketcan) - bitrate: CAN bitrate in bits per second (default: 1000000)</p> required Source code in <code>damiao_motor/cli/commands.py</code> <pre><code>def cmd_set_zero_position(args) -&gt; None:\n    \"\"\"\n    Handle 'set-zero-position' subcommand.\n\n    Sets the current output shaft position to zero (save position zero).\n\n    Args:\n        args: Parsed command-line arguments containing:\n            - motor_id: Motor ID (required)\n            - channel: CAN channel (default: can0)\n            - bustype: CAN bus type (default: socketcan)\n            - bitrate: CAN bitrate in bits per second (default: 1000000)\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"DaMiao Motor - Set Zero Position\")\n    print(\"=\" * 60)\n    print(f\"CAN channel: {args.channel}\")\n    print(f\"Motor ID: 0x{args.motor_id:02X} ({args.motor_id})\")\n    print(\"=\" * 60)\n    print()\n\n    # Check and bring up CAN interface if needed\n    if args.bustype == \"socketcan\":\n        if not check_and_bring_up_can_interface(args.channel, bitrate=args.bitrate):\n            print(\n                f\"\u26a0 Warning: Could not verify {args.channel} is ready. Continuing anyway...\"\n            )\n\n    controller = DaMiaoController(channel=args.channel, bustype=args.bustype)\n\n    try:\n        motor = controller.add_motor(\n            motor_id=args.motor_id, feedback_id=0x00, motor_type=args.motor_type\n        )\n\n        print(\"Setting current position to zero...\")\n        motor.set_zero_position()\n        print(\"\u2713 Position zero set\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n        raise\n    finally:\n        controller.shutdown()\n</code></pre>","tags":["api","reference","cli"]},{"location":"api/cli/#damiao_motor.cli.commands.cmd_set_can_timeout","title":"damiao_motor.cli.commands.cmd_set_can_timeout","text":"<pre><code>cmd_set_can_timeout(args) -&gt; None\n</code></pre> <p>Handle 'set-can-timeout' subcommand.</p> <p>Sets the CAN timeout alarm time (register 9) in milliseconds.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Parsed command-line arguments containing: - motor_id: Motor ID (required) - timeout_ms: Timeout in milliseconds (required) - channel: CAN channel (default: can0) - bustype: CAN bus type (default: socketcan) - bitrate: CAN bitrate in bits per second (default: 1000000)</p> required Note <p>Register 9 stores timeout in units of 50 microseconds: 1 register unit = 50 microseconds.</p> <p>The timeout is internally converted from milliseconds to register units using: register_value = timeout_ms \u00d7 20</p> <p>The value is stored to flash memory after setting.</p> Source code in <code>damiao_motor/cli/commands.py</code> <pre><code>def cmd_set_can_timeout(args) -&gt; None:\n    \"\"\"\n    Handle 'set-can-timeout' subcommand.\n\n    Sets the CAN timeout alarm time (register 9) in milliseconds.\n\n    Args:\n        args: Parsed command-line arguments containing:\n            - motor_id: Motor ID (required)\n            - timeout_ms: Timeout in milliseconds (required)\n            - channel: CAN channel (default: can0)\n            - bustype: CAN bus type (default: socketcan)\n            - bitrate: CAN bitrate in bits per second (default: 1000000)\n\n    Note:\n        Register 9 stores timeout in units of 50 microseconds: **1 register unit = 50 microseconds**.\n\n        The timeout is internally converted from milliseconds to register units using:\n        register_value = timeout_ms \u00d7 20\n\n        The value is stored to flash memory after setting.\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"DaMiao Motor - Set CAN Timeout\")\n    print(\"=\" * 60)\n    print(f\"CAN channel: {args.channel}\")\n    print(f\"Motor ID: 0x{args.motor_id:02X} ({args.motor_id})\")\n    print(f\"Timeout: {args.timeout_ms} ms\")\n    print(\"=\" * 60)\n    print()\n\n    # Check and bring up CAN interface if needed\n    if args.bustype == \"socketcan\":\n        if not check_and_bring_up_can_interface(args.channel, bitrate=args.bitrate):\n            print(\n                f\"\u26a0 Warning: Could not verify {args.channel} is ready. Continuing anyway...\"\n            )\n\n    controller = DaMiaoController(channel=args.channel, bustype=args.bustype)\n\n    try:\n        motor = controller.add_motor(\n            motor_id=args.motor_id, feedback_id=0x00, motor_type=args.motor_type\n        )\n\n        print(f\"Setting CAN timeout to {args.timeout_ms} ms (register 9)...\")\n        motor.set_can_timeout(args.timeout_ms)\n\n        # Store parameters to flash\n        print(\"Storing parameters to flash...\")\n        try:\n            motor.store_parameters()\n            print(\"\u2713 Parameters stored to flash\")\n        except Exception as e:\n            print(f\"\u26a0 Warning: Could not store parameters: {e}\")\n\n        print()\n        print(f\"\u2713 CAN timeout set to {args.timeout_ms} ms\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n        raise\n    finally:\n        controller.shutdown()\n</code></pre>","tags":["api","reference","cli"]},{"location":"api/cli/#damiao_motor.cli.commands.cmd_set_motor_id","title":"damiao_motor.cli.commands.cmd_set_motor_id","text":"<pre><code>cmd_set_motor_id(args) -&gt; None\n</code></pre> <p>Handle 'set-motor-id' subcommand.</p> <p>Changes the motor's receive ID (ESC_ID, register 8). This is the ID used to send commands to the motor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Parsed command-line arguments containing: - current: Current motor ID (to connect to the motor) (required) - target: Target motor ID (new receive ID) (required) - channel: CAN channel (default: can0) - bustype: CAN bus type (default: socketcan) - bitrate: CAN bitrate in bits per second (default: 1000000)</p> required Note <p>After changing the motor ID, you will need to use the new ID to communicate with the motor. The value is stored to flash memory after setting.</p> Source code in <code>damiao_motor/cli/commands.py</code> <pre><code>def cmd_set_motor_id(args) -&gt; None:\n    \"\"\"\n    Handle 'set-motor-id' subcommand.\n\n    Changes the motor's receive ID (ESC_ID, register 8). This is the ID used to send commands to the motor.\n\n    Args:\n        args: Parsed command-line arguments containing:\n            - current: Current motor ID (to connect to the motor) (required)\n            - target: Target motor ID (new receive ID) (required)\n            - channel: CAN channel (default: can0)\n            - bustype: CAN bus type (default: socketcan)\n            - bitrate: CAN bitrate in bits per second (default: 1000000)\n\n    Note:\n        After changing the motor ID, you will need to use the new ID to communicate with the motor.\n        The value is stored to flash memory after setting.\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"DaMiao Motor - Set Motor ID (Receive ID)\")\n    print(\"=\" * 60)\n    print(f\"CAN channel: {args.channel}\")\n    print(f\"Current Motor ID: 0x{args.current:02X} ({args.current})\")\n    print(f\"Target Motor ID: 0x{args.target:02X} ({args.target})\")\n    print(\"=\" * 60)\n    print()\n\n    if args.current == args.target:\n        print(\"Current and target IDs are the same. No change needed.\")\n        return\n\n    # Check and bring up CAN interface if needed\n    if args.bustype == \"socketcan\":\n        if not check_and_bring_up_can_interface(args.channel, bitrate=args.bitrate):\n            print(\n                f\"\u26a0 Warning: Could not verify {args.channel} is ready. Continuing anyway...\"\n            )\n\n    controller = DaMiaoController(channel=args.channel, bustype=args.bustype)\n\n    try:\n        # Use current ID to connect\n        motor = controller.add_motor(\n            motor_id=args.current, feedback_id=0x00, motor_type=args.motor_type\n        )\n\n        print(\"Reading current register values...\")\n        time.sleep(0.1)\n        controller.poll_feedback()\n\n        # Read current receive ID (register 8)\n        try:\n            current_receive_id = motor.get_register(8, timeout=1.0)\n            print(\n                f\"Current Receive ID (register 8): {int(current_receive_id)} (0x{int(current_receive_id):02X})\"\n            )\n        except Exception as e:\n            print(f\"\u26a0 Warning: Could not read register 8: {e}\")\n            print(\"  Proceeding with write anyway...\")\n\n        print(\n            f\"Writing new Receive ID (register 8) = {args.target} (0x{args.target:02X})...\"\n        )\n        motor.write_register(8, args.target)\n\n        # Store parameters to flash\n        print(\"Storing parameters to flash...\")\n        try:\n            motor.store_parameters()\n            print(\"\u2713 Parameters stored to flash\")\n        except Exception as e:\n            print(f\"\u26a0 Warning: Could not store parameters: {e}\")\n\n        print()\n        print(f\"\u2713 Motor ID changed from 0x{args.current:02X} to 0x{args.target:02X}\")\n        print(\n            f\"  Note: You may need to reconnect using the new ID: 0x{args.target:02X}\"\n        )\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n        raise\n    finally:\n        controller.shutdown()\n</code></pre>","tags":["api","reference","cli"]},{"location":"api/cli/#damiao_motor.cli.commands.cmd_set_feedback_id","title":"damiao_motor.cli.commands.cmd_set_feedback_id","text":"<pre><code>cmd_set_feedback_id(args) -&gt; None\n</code></pre> <p>Handle 'set-feedback-id' subcommand.</p> <p>Changes the motor's feedback ID (MST_ID, register 7). This is the ID used to identify feedback messages from the motor.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>Parsed command-line arguments containing: - current: Current motor ID (to connect to the motor) (required) - target: Target feedback ID (new MST_ID) (required) - channel: CAN channel (default: can0) - bustype: CAN bus type (default: socketcan) - bitrate: CAN bitrate in bits per second (default: 1000000)</p> required Note <p>The motor will now respond with feedback using the new feedback ID. The value is stored to flash memory after setting.</p> Source code in <code>damiao_motor/cli/commands.py</code> <pre><code>def cmd_set_feedback_id(args) -&gt; None:\n    \"\"\"\n    Handle 'set-feedback-id' subcommand.\n\n    Changes the motor's feedback ID (MST_ID, register 7). This is the ID used to identify feedback messages from the motor.\n\n    Args:\n        args: Parsed command-line arguments containing:\n            - current: Current motor ID (to connect to the motor) (required)\n            - target: Target feedback ID (new MST_ID) (required)\n            - channel: CAN channel (default: can0)\n            - bustype: CAN bus type (default: socketcan)\n            - bitrate: CAN bitrate in bits per second (default: 1000000)\n\n    Note:\n        The motor will now respond with feedback using the new feedback ID.\n        The value is stored to flash memory after setting.\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"DaMiao Motor - Set Feedback ID (MST_ID)\")\n    print(\"=\" * 60)\n    print(f\"CAN channel: {args.channel}\")\n    print(f\"Current Motor ID: 0x{args.current:02X} ({args.current})\")\n    print(f\"Target Feedback ID: 0x{args.target:02X} ({args.target})\")\n    print(\"=\" * 60)\n    print()\n\n    # Check and bring up CAN interface if needed\n    if args.bustype == \"socketcan\":\n        if not check_and_bring_up_can_interface(args.channel, bitrate=args.bitrate):\n            print(\n                f\"\u26a0 Warning: Could not verify {args.channel} is ready. Continuing anyway...\"\n            )\n\n    controller = DaMiaoController(channel=args.channel, bustype=args.bustype)\n\n    try:\n        # Use current motor ID to connect\n        motor = controller.add_motor(\n            motor_id=args.current, feedback_id=0x00, motor_type=args.motor_type\n        )\n\n        print(\"Reading current register values...\")\n        time.sleep(0.1)\n        controller.poll_feedback()\n\n        # Read current feedback ID (register 7)\n        try:\n            current_feedback_id = motor.get_register(7, timeout=1.0)\n            print(\n                f\"Current Feedback ID (register 7): {int(current_feedback_id)} (0x{int(current_feedback_id):02X})\"\n            )\n        except Exception as e:\n            print(f\"\u26a0 Warning: Could not read register 7: {e}\")\n            print(\"  Proceeding with write anyway...\")\n\n        print(\n            f\"Writing new Feedback ID (register 7) = {args.target} (0x{args.target:02X})...\"\n        )\n        motor.write_register(7, args.target)\n\n        # Store parameters to flash\n        print(\"Storing parameters to flash...\")\n        try:\n            motor.store_parameters()\n            print(\"\u2713 Parameters stored to flash\")\n        except Exception as e:\n            print(f\"\u26a0 Warning: Could not store parameters: {e}\")\n\n        print()\n        print(f\"\u2713 Feedback ID changed to 0x{args.target:02X}\")\n        print(f\"  Note: Motor will now respond with feedback ID 0x{args.target:02X}\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n        raise\n    finally:\n        controller.shutdown()\n</code></pre>","tags":["api","reference","cli"]},{"location":"api/cli/#utility-functions","title":"Utility Functions","text":"","tags":["api","reference","cli"]},{"location":"api/cli/#damiao_motor.cli.display.scan_motors","title":"damiao_motor.cli.display.scan_motors","text":"<pre><code>scan_motors(channel: str = 'can0', bustype: str = 'socketcan', motor_ids: list[int] | None = None, duration_s: float = 3.0, bitrate: int = 1000000, debug: bool = False, *, motor_type: str = '4310') -&gt; Set[int]\n</code></pre> <p>Scan for connected motors by sending zero commands and listening for feedback.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>str</code> <p>CAN channel (e.g., \"can0\")</p> <code>'can0'</code> <code>bustype</code> <code>str</code> <p>CAN bus type (e.g., \"socketcan\")</p> <code>'socketcan'</code> <code>motor_ids</code> <code>list[int] | None</code> <p>List of motor IDs to test. If None, tests IDs 0x01-0x10.</p> <code>None</code> <code>duration_s</code> <code>float</code> <p>How long to listen for responses (seconds)</p> <code>3.0</code> <code>motor_type</code> <code>str</code> <p>Motor type for P/V/T presets (e.g. 4340, 4310, 3507).         Defaults to \"4310\". Only used for encoding zero commands;         doesn't affect which motors are detected.</p> <code>'4310'</code> <p>Returns:</p> Type Description <code>Set[int]</code> <p>Set of motor IDs that responded with feedback.</p> Source code in <code>damiao_motor/cli/display.py</code> <pre><code>def scan_motors(\n    channel: str = \"can0\",\n    bustype: str = \"socketcan\",\n    motor_ids: list[int] | None = None,\n    duration_s: float = 3.0,\n    bitrate: int = 1000000,\n    debug: bool = False,\n    *,\n    motor_type: str = \"4310\",\n) -&gt; Set[int]:\n    \"\"\"\n    Scan for connected motors by sending zero commands and listening for feedback.\n\n    Args:\n        channel: CAN channel (e.g., \"can0\")\n        bustype: CAN bus type (e.g., \"socketcan\")\n        motor_ids: List of motor IDs to test. If None, tests IDs 0x01-0x10.\n        duration_s: How long to listen for responses (seconds)\n        motor_type: Motor type for P/V/T presets (e.g. 4340, 4310, 3507).\n                    Defaults to \"4310\". Only used for encoding zero commands;\n                    doesn't affect which motors are detected.\n\n    Returns:\n        Set of motor IDs that responded with feedback.\n    \"\"\"\n    if motor_ids is None:\n        motor_ids = list(range(0x01, 0x11))  # Test IDs 1-16\n\n    # Open scan status box (80 chars wide, 78 interior)\n    print(f\"{BOX_CORNER_TL}{BOX_HORIZONTAL * 78}{BOX_CORNER_TR}\")\n\n    # Check and bring up CAN interface if needed (only for socketcan)\n    if bustype == \"socketcan\":\n        line_text = f\" Checking CAN interface {channel}...\"\n        print(f\"{BOX_VERTICAL}{pad_with_ansi(line_text, 78)}{BOX_VERTICAL}\")\n        if not check_and_bring_up_can_interface(channel, bitrate=bitrate):\n            warning_text = f\" {YELLOW}\u26a0 Warning: Could not verify {channel} is ready. Continuing anyway...{RESET}\"\n            print(f\"{BOX_VERTICAL}{pad_with_ansi(warning_text, 78)}{BOX_VERTICAL}\")\n        else:\n            # Verify interface is actually up and working\n            verify_result = subprocess.run(\n                [\"ip\", \"link\", \"show\", channel],\n                capture_output=True,\n                text=True,\n                check=False,\n            )\n            if verify_result.returncode == 0 and \"state UP\" in verify_result.stdout:\n                ready_text = f\" {GREEN}\u2713 CAN interface {channel} is ready{RESET}\"\n                print(f\"{BOX_VERTICAL}{pad_with_ansi(ready_text, 78)}{BOX_VERTICAL}\")\n            else:\n                warning_text = f\" {YELLOW}\u26a0 Warning: {channel} may not be properly configured{RESET}\"\n                print(f\"{BOX_VERTICAL}{pad_with_ansi(warning_text, 78)}{BOX_VERTICAL}\")\n\n    controller = DaMiaoController(channel=channel, bustype=bustype)\n\n    # Flush any pending messages from the bus\n    line_text = \" Flushing CAN bus buffer...\"\n    print(f\"{BOX_VERTICAL}{pad_with_ansi(line_text, 78)}{BOX_VERTICAL}\")\n    flushed_count = controller.flush_bus()\n    if flushed_count &gt; 0:\n        flushed_text = (\n            f\"   {GREEN}Flushed {flushed_count} pending message(s) from bus{RESET}\"\n        )\n        print(f\"{BOX_VERTICAL}{pad_with_ansi(flushed_text, 78)}{BOX_VERTICAL}\")\n    else:\n        line_text = \"   Bus buffer is clean\"\n        print(f\"{BOX_VERTICAL}{pad_with_ansi(line_text, 78)}{BOX_VERTICAL}\")\n\n    motors: dict[int, DaMiaoMotor] = {}\n\n    # Create motor instances for all IDs we want to test\n    for motor_id in motor_ids:\n        try:\n            motor = controller.add_motor(\n                motor_id=motor_id, feedback_id=0x00, motor_type=motor_type\n            )\n            motors[motor_id] = motor\n        except ValueError:\n            # Motor already exists, skip\n            pass\n\n    # Send zero command to all motors\n    line_text = f\" Sending zero command to {len(motors)} potential motor IDs...\"\n    print(f\"{BOX_VERTICAL}{pad_with_ansi(line_text, 78)}{BOX_VERTICAL}\")\n    try:\n        for motor in motors.values():\n            motor.send_cmd_mit(\n                target_position=0.0,\n                target_velocity=0.0,\n                stiffness=0.0,\n                damping=0.0,\n                feedforward_torque=0.0,\n            )\n            if debug:\n                # Print sent command in debug mode\n                cmd_data = motor.encode_cmd_msg(0.0, 0.0, 0.0, 0.0, 0.0)\n                data_hex = \" \".join(f\"{b:02X}\" for b in cmd_data)\n                sent_text = f\"   [SENT] 0x{motor.motor_id:03X} [{data_hex}]\"\n                print(f\"{BOX_VERTICAL}{pad_with_ansi(sent_text, 78)}{BOX_VERTICAL}\")\n    except Exception as e:\n        error_str = str(e)\n        if (\n            \"Error Code 80\" in error_str\n            or \"No buffer space available\" in error_str\n            or \"[Errno 80]\" in error_str\n        ):\n            error_lines = [\n                \"Original error: \" + str(e),\n                \"\",\n                \"This error typically indicates:\",\n                \"  \u2022 No CAN device (motor) is connected to the bus\",\n                \"  \u2022 Motor(s) are not powered on\",\n                \"  \u2022 CAN interface hardware issue\",\n                \"\",\n                \"Please check:\",\n                \"  1. Motor(s) are properly connected to the CAN bus\",\n                \"  2. Motor(s) are powered on\",\n                \"  3. CAN interface hardware is working correctly\",\n                \"  4. CAN bus termination resistors (120\u03a9) are installed at both ends\",\n            ]\n            print_error_box(\n                \"[ERROR CODE 80] No buffer space available when sending commands\",\n                error_lines,\n                width=70,\n            )\n            # Clean up and exit gracefully\n            try:\n                controller.bus.shutdown()\n            except Exception:\n                pass\n            sys.exit(1)\n        else:\n            raise\n\n    # Listen for feedback\n    line_text = f\" Listening for responses for {duration_s} seconds...\"\n    print(f\"{BOX_VERTICAL}{pad_with_ansi(line_text, 78)}{BOX_VERTICAL}\")\n    start_time = time.perf_counter()\n    responded_ids: Set[int] = set()\n    debug_messages = []  # Collect debug messages if debug mode is enabled\n    # Track seen motor IDs and arbitration IDs for conflict detection\n    seen_motor_ids: Set[int] = set()  # Track decoded motor IDs (logical_id)\n    seen_arbitration_ids: Set[int] = set()  # Track arbitration IDs\n    # Collect conflicts to group them at the end\n    conflicted_motor_ids: Set[int] = set()  # Motor IDs that appeared multiple times\n    conflicted_arbitration_ids: Set[int] = (\n        set()\n    )  # Arbitration IDs that appeared multiple times\n    # Collect motor register information for table display\n    motor_registers: Dict[\n        int, Dict[int, float | int]\n    ] = {}  # motor_id -&gt; {rid -&gt; value}\n\n    while time.perf_counter() - start_time &lt; duration_s:\n        # Debug mode: collect and print raw messages immediately\n        if debug:\n            # Read and collect raw messages, then process normally\n            while True:\n                msg = controller.bus.recv(timeout=0)\n                if msg is None:\n                    break\n                data_hex = \" \".join(f\"{b:02X}\" for b in msg.data)\n                debug_msg = f\"  0x{msg.arbitration_id:03X} [{data_hex}]\"\n                debug_messages.append(debug_msg)\n                # Print immediately in debug mode\n                print(debug_msg)\n                # Process the message manually for debug mode\n                if len(msg.data) == 8:\n                    logical_id = msg.data[0] &amp; 0x0F\n                    arb_id = msg.arbitration_id\n\n                    # Check for motor ID conflict (same decoded motor ID seen twice)\n                    if logical_id in seen_motor_ids:\n                        conflicted_motor_ids.add(logical_id)\n\n                    # Check for arbitration ID conflict (same arbitration ID seen twice)\n                    if arb_id in seen_arbitration_ids:\n                        conflicted_arbitration_ids.add(arb_id)\n\n                    seen_motor_ids.add(logical_id)\n                    seen_arbitration_ids.add(arb_id)\n\n                    motor = controller._motors_by_feedback.get(logical_id)\n                    if motor is not None:\n                        motor.decode_sensor_feedback(\n                            bytes(msg.data), arbitration_id=arb_id\n                        )\n        else:\n            # Normal mode: read messages, check conflicts, then process\n            while True:\n                msg = controller.bus.recv(timeout=0)\n                if msg is None:\n                    break\n\n                if len(msg.data) == 8:\n                    logical_id = msg.data[0] &amp; 0x0F\n                    arb_id = msg.arbitration_id\n\n                    # Check for motor ID conflict (same decoded motor ID seen twice)\n                    if logical_id in seen_motor_ids:\n                        conflicted_motor_ids.add(logical_id)\n\n                    # Check for arbitration ID conflict (same arbitration ID seen twice)\n                    if arb_id in seen_arbitration_ids:\n                        conflicted_arbitration_ids.add(arb_id)\n\n                    seen_motor_ids.add(logical_id)\n                    seen_arbitration_ids.add(arb_id)\n\n                    # Process through controller\n                    motor = controller._motors_by_feedback.get(logical_id)\n                    if motor is not None:\n                        motor.decode_sensor_feedback(\n                            bytes(msg.data), arbitration_id=arb_id\n                        )\n\n        # Check which motors have received feedback\n        for motor_id, motor in motors.items():\n            if motor.state and motor.state.get(\"can_id\") is not None:\n                # Print once per motor when first detected\n                if motor_id not in responded_ids:\n                    state_name = motor.state.get(\"status\", \"UNKNOWN\")\n                    pos = motor.state.get(\"pos\", 0.0)\n                    arb_id = motor.state.get(\"arbitration_id\")\n                    if arb_id is not None:\n                        motor_text = f\"   {GREEN}\u2713 Motor ID 0x{motor_id:02X}{RESET} responded (arb_id: 0x{arb_id:03X}, state: {state_name}, pos: {pos:.3f})\"\n                        print(\n                            f\"{BOX_VERTICAL}{pad_with_ansi(motor_text, 78)}{BOX_VERTICAL}\"\n                        )\n                    else:\n                        motor_text = f\"   {GREEN}\u2713 Motor ID 0x{motor_id:02X}{RESET} responded (state: {state_name}, pos: {pos:.3f})\"\n                        print(\n                            f\"{BOX_VERTICAL}{pad_with_ansi(motor_text, 78)}{BOX_VERTICAL}\"\n                        )\n\n                responded_ids.add(motor_id)\n\n        time.sleep(0.01)\n\n    # Print conflicts (grouped)\n    if conflicted_motor_ids:\n        error_lines = [\n            \"Multiple motors responded with the same motor ID.\",\n            \"This indicates multiple motors are configured with the same motor ID.\",\n            f\"Conflicted Motor IDs: {', '.join(f'0x{mid:02X}' for mid in sorted(conflicted_motor_ids))}\",\n        ]\n        print_error_box(\"[ERROR] Motor ID Conflicts Detected\", error_lines)\n\n    if conflicted_arbitration_ids:\n        warning_lines = [\n            \"Same arbitration ID seen multiple times.\",\n            \"This may indicate a CAN bus configuration issue.\",\n            f\"Conflicted Arbitration IDs: {', '.join(f'0x{aid:03X}' for aid in sorted(conflicted_arbitration_ids))}\",\n        ]\n        print_warning_box(\"[WARNING] Arbitration ID Conflicts Detected\", warning_lines)\n\n    # Close the scan status box\n    print(f\"{BOX_CORNER_BL}{BOX_HORIZONTAL * 78}{BOX_CORNER_BR}\")\n\n    # Read all registers from detected motors if no motor ID conflicts\n    if not conflicted_motor_ids and responded_ids:\n        print(\"Reading register parameters from detected motors...\")\n        for motor_id in sorted(responded_ids):\n            motor = motors.get(motor_id)\n            if motor is not None:\n                try:\n                    registers = motor.read_all_registers(timeout=0.05)\n                    motor_registers[motor_id] = registers\n                except Exception as e:\n                    print(\n                        f\"  {YELLOW}\u26a0 Failed to read registers from motor 0x{motor_id:02X}: {e}{RESET}\"\n                    )\n        print()\n\n    # Print motor register table if no motor ID conflicts\n    if not conflicted_motor_ids and motor_registers:\n        # Start register table box\n        print()\n        top_border = f\"{BOX_CORNER_TL}{BOX_HORIZONTAL * 78}{BOX_CORNER_TR}\"\n        print(top_border)\n        # Header line\n        header_text = f\" {GREEN}Detected Motors - Register Parameters{RESET}\"\n        print(f\"{BOX_VERTICAL}{pad_with_ansi(header_text, 78)}{BOX_VERTICAL}\")\n\n        # Group registers by motor\n        for motor_id in sorted(motor_registers.keys()):\n            registers = motor_registers[motor_id]\n            # Separator line before motor section\n            print(f\"{BOX_JOIN_LEFT}{BOX_HORIZONTAL * 78}{BOX_JOIN_RIGHT}\")\n            # Motor ID header - use pad_with_ansi to account for color codes\n            motor_id_text = f\" {GREEN}Motor ID: 0x{motor_id:02X} ({motor_id}){RESET}\"\n            print(f\"{BOX_VERTICAL}{pad_with_ansi(motor_id_text, 78)}{BOX_VERTICAL}\")\n            # Separator line\n            print(f\"{BOX_JOIN_LEFT}{BOX_HORIZONTAL * 78}{BOX_JOIN_RIGHT}\")\n            # Table header - adjust column widths to fit within 78 chars\n            # Format: \" RID(4) Var(10) Desc(32) Value(12) Type(8) Access(6)\" = 78 total\n            # Calculation: 1+4+1+10+1+32+1+12+1+8+1+6 = 78\n            header_content = f\" {'RID':&lt;4} {'Variable':&lt;10} {'Description':&lt;32} {'Value':&lt;12} {'Type':&lt;8} {'Access':&lt;6}\"\n            print(f\"{BOX_VERTICAL}{pad_with_ansi(header_content, 78)}{BOX_VERTICAL}\")\n            # Header separator\n            print(f\"{BOX_JOIN_LEFT}{BOX_HORIZONTAL * 78}{BOX_JOIN_RIGHT}\")\n\n            for rid in sorted(registers.keys()):\n                if rid not in REGISTER_TABLE:\n                    continue\n\n                reg_info = REGISTER_TABLE[rid]\n                value = registers[rid]\n\n                # Format value based on type\n                if isinstance(value, str) and value.startswith(\"ERROR\"):\n                    value_str = value\n                elif reg_info.data_type == \"float\":\n                    value_str = f\"{float(value):.2f}\"\n                else:\n                    value_str = str(int(value))\n\n                # Truncate long descriptions to fit (32 chars for desc column)\n                desc = (\n                    reg_info.description[:30] + \"..\"\n                    if len(reg_info.description) &gt; 32\n                    else reg_info.description\n                )\n\n                # Format table row - match header column widths\n                row_content = f\" {rid:&lt;4} {reg_info.variable:&lt;10} {desc:&lt;32} {value_str:&lt;12} {reg_info.data_type:&lt;8} {reg_info.access:&lt;6}\"\n                print(f\"{BOX_VERTICAL}{pad_with_ansi(row_content, 78)}{BOX_VERTICAL}\")\n\n        # Close the box\n        print(f\"{BOX_CORNER_BL}{BOX_HORIZONTAL * 78}{BOX_CORNER_BR}\")\n\n    # Print debug summary if messages were collected\n    if debug and debug_messages:\n        print()\n        print_section_header(\n            f\"DEBUG: Total {len(debug_messages)} raw CAN messages received\", width=80\n        )\n        print(f\"{BOX_CORNER_BL}{BOX_HORIZONTAL * 78}{BOX_CORNER_BR}\")\n\n    # Cleanup\n    try:\n        controller.bus.shutdown()\n    except Exception:\n        pass\n\n    return responded_ids\n</code></pre>","tags":["api","reference","cli"]},{"location":"api/controller/","title":"DaMiaoController","text":"","tags":["api","reference","core"]},{"location":"api/controller/#damiao_motor.core.controller.DaMiaoController","title":"damiao_motor.core.controller.DaMiaoController","text":"<pre><code>DaMiaoController(channel: str = 'can0', bustype: str = 'socketcan')\n</code></pre> <p>Simple multi-motor controller.</p> <ul> <li>Owns a single CAN bus.</li> <li>Manages multiple DaMiaoMotor instances on that bus.</li> <li>Automatically polls feedback in background when motors are present.</li> <li>Provides helper methods to:<ul> <li>enable/disable all motors</li> <li>send commands to one or all motors</li> <li>poll feedback non-blockingly</li> </ul> </li> </ul> Source code in <code>damiao_motor/core/controller.py</code> <pre><code>def __init__(self, channel: str = \"can0\", bustype: str = \"socketcan\") -&gt; None:\n    self.bus: can.Bus = can.interface.Bus(channel=channel, bustype=bustype)\n    # Keyed by command CAN ID (motor_id)\n    self.motors: Dict[int, DaMiaoMotor] = {}\n    # Keyed by logical motor ID (embedded in feedback frame)\n    self._motors_by_feedback: Dict[int, DaMiaoMotor] = {}\n    # Background polling thread\n    self._polling_thread: Optional[threading.Thread] = None\n    self._polling_active = False\n    self._polling_lock = threading.Lock()\n</code></pre>","tags":["api","reference","core"]},{"location":"api/controller/#damiao_motor.core.controller.DaMiaoController.flush_bus","title":"flush_bus","text":"<pre><code>flush_bus() -&gt; int\n</code></pre> <p>Flush all pending messages from the CAN bus buffer.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of messages flushed.</p> <p>Raises:</p> Type Description <code>CanOperationError</code> <p>If CAN interface is down (Error Code 100) with helpful hint</p> <code>OSError</code> <p>If other network/system errors occur</p> Source code in <code>damiao_motor/core/controller.py</code> <pre><code>def flush_bus(self) -&gt; int:\n    \"\"\"\n    Flush all pending messages from the CAN bus buffer.\n\n    Returns:\n        Number of messages flushed.\n\n    Raises:\n        can.CanOperationError: If CAN interface is down (Error Code 100) with helpful hint\n        OSError: If other network/system errors occur\n    \"\"\"\n    count = 0\n    try:\n        while True:\n            msg = self.bus.recv(timeout=0)\n            if msg is None:\n                break\n            count += 1\n    except can.CanOperationError as e:\n        error_str = str(e)\n        errno = getattr(e, \"errno\", None)\n\n        # Error Code 100: Network is down - CAN interface not up\n        if (\n            errno == 100\n            or \"Error Code 100\" in error_str\n            or \"Network is down\" in error_str\n            or \"[Errno 100]\" in error_str\n        ):\n            channel = getattr(self.bus, \"channel\", \"can0\")\n            raise can.CanOperationError(\n                f\"CAN interface '{channel}' is down (Error Code 100)\"\n            ) from e\n        # Re-raise other CanOperationError\n        raise\n    except OSError as e:\n        errno = getattr(e, \"errno\", None)\n        if errno == 100 or \"Network is down\" in str(e) or \"[Errno 100]\" in str(e):\n            channel = getattr(self.bus, \"channel\", \"can0\")\n            raise OSError(\n                f\"CAN interface '{channel}' is down (Error Code 100)\"\n            ) from e\n        raise\n    return count\n</code></pre>","tags":["api","reference","core"]},{"location":"api/controller/#damiao_motor.core.controller.DaMiaoController.poll_feedback","title":"poll_feedback","text":"<pre><code>poll_feedback() -&gt; None\n</code></pre> <p>Non-blocking read of all pending CAN frames on this bus, and dispatch feedback frames to the corresponding motors.</p> Source code in <code>damiao_motor/core/controller.py</code> <pre><code>def poll_feedback(self) -&gt; None:\n    \"\"\"\n    Non-blocking read of all pending CAN frames on this bus, and dispatch\n    feedback frames to the corresponding motors.\n    \"\"\"\n    try:\n        while True:\n            msg = self.bus.recv(timeout=0)\n            if msg is None:\n                break\n\n            if len(msg.data) != 8:\n                continue\n\n            # Feedback messages include the logical motor ID in the low 4 bits\n            # of the first data byte. Use that to route feedback to the right motor.\n            logical_id = msg.data[0] &amp; 0x0F\n            motor = self._motors_by_feedback.get(logical_id)\n            if motor is None:\n                continue\n\n            motor.process_feedback_frame(\n                bytes(msg.data), arbitration_id=msg.arbitration_id\n            )\n    except (ValueError, OSError, AttributeError):\n        # Bus is closed or invalid, stop polling\n        with self._polling_lock:\n            self._polling_active = False\n</code></pre>","tags":["api","reference","core"]},{"location":"api/controller/#damiao_motor.core.controller.DaMiaoController.send_cmd","title":"send_cmd","text":"<pre><code>send_cmd(motor_id: int, target_position: float = 0.0, target_velocity: float = 0.0, stiffness: float = 0.0, damping: float = 0.0, feedforward_torque: float = 0.0) -&gt; None\n</code></pre> <p>Send MIT mode command to a specific motor (convenience method).</p> Source code in <code>damiao_motor/core/controller.py</code> <pre><code>def send_cmd(\n    self,\n    motor_id: int,\n    target_position: float = 0.0,\n    target_velocity: float = 0.0,\n    stiffness: float = 0.0,\n    damping: float = 0.0,\n    feedforward_torque: float = 0.0,\n) -&gt; None:\n    \"\"\"Send MIT mode command to a specific motor (convenience method).\"\"\"\n    self.get_motor(motor_id).send_cmd_mit(\n        target_position=target_position,\n        target_velocity=target_velocity,\n        stiffness=stiffness,\n        damping=damping,\n        feedforward_torque=feedforward_torque,\n    )\n</code></pre>","tags":["api","reference","core"]},{"location":"api/controller/#damiao_motor.core.controller.DaMiaoController.send_cmd_all","title":"send_cmd_all","text":"<pre><code>send_cmd_all(target_position: float = 0.0, target_velocity: float = 0.0, stiffness: float = 0.0, damping: float = 0.0, feedforward_torque: float = 0.0) -&gt; None\n</code></pre> <p>Send MIT mode command to all motors (convenience method).</p> Source code in <code>damiao_motor/core/controller.py</code> <pre><code>def send_cmd_all(\n    self,\n    target_position: float = 0.0,\n    target_velocity: float = 0.0,\n    stiffness: float = 0.0,\n    damping: float = 0.0,\n    feedforward_torque: float = 0.0,\n) -&gt; None:\n    \"\"\"Send MIT mode command to all motors (convenience method).\"\"\"\n    for m in self.all_motors():\n        m.send_cmd_mit(\n            target_position=target_position,\n            target_velocity=target_velocity,\n            stiffness=stiffness,\n            damping=damping,\n            feedforward_torque=feedforward_torque,\n        )\n</code></pre>","tags":["api","reference","core"]},{"location":"api/controller/#damiao_motor.core.controller.DaMiaoController.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Shutdown the controller and stop background polling.</p> Source code in <code>damiao_motor/core/controller.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shutdown the controller and stop background polling.\"\"\"\n    self._stop_polling()\n    self.disable_all()\n    self.bus.shutdown()\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/","title":"DaMiaoMotor","text":"","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor","title":"damiao_motor.core.motor.DaMiaoMotor","text":"<pre><code>DaMiaoMotor(motor_id: int, feedback_id: int, bus: can.Bus, *, motor_type: str, p_min: Optional[float] = None, p_max: Optional[float] = None, v_min: Optional[float] = None, v_max: Optional[float] = None, t_min: Optional[float] = None, t_max: Optional[float] = None)\n</code></pre> <p>Lightweight DaMiao motor wrapper over a CAN bus.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def __init__(\n    self,\n    motor_id: int,\n    feedback_id: int,\n    bus: can.Bus,\n    *,\n    motor_type: str,\n    p_min: Optional[float] = None,\n    p_max: Optional[float] = None,\n    v_min: Optional[float] = None,\n    v_max: Optional[float] = None,\n    t_min: Optional[float] = None,\n    t_max: Optional[float] = None,\n) -&gt; None:\n    self.motor_id = motor_id\n    self.feedback_id = feedback_id\n    self.bus = bus\n\n    # Resolve P/V/T limits from motor_type preset + optional overrides. kp and kd use fixed KP_MIN/KP_MAX, KD_MIN/KD_MAX.\n    base = self._resolve_limits(motor_type)\n    overrides = {\n        k: v\n        for k, v in (\n            (\"p_min\", p_min),\n            (\"p_max\", p_max),\n            (\"v_min\", v_min),\n            (\"v_max\", v_max),\n            (\"t_min\", t_min),\n            (\"t_max\", t_max),\n        )\n        if v is not None\n    }\n    base.update(overrides)\n    for k in _LIMITS_KEYS:\n        setattr(self, f\"_{k}\", base[k])\n\n    self.motor_type = motor_type\n\n    # last decoded feedback\n    self.state: Dict[str, Any] = {}\n    self.state_lock = threading.Lock()\n\n    # last register values\n    self.registers: Dict[int, float | int] = {}\n    self.registers_lock = threading.Lock()\n    self.register_request_time: Dict[int, float] = {}\n    self.register_request_time_lock = threading.Lock()\n    self.register_reply_time: Dict[int, float] = {}\n    self.register_reply_time_lock = threading.Lock()\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.clear_error","title":"clear_error","text":"<pre><code>clear_error() -&gt; None\n</code></pre> <p>Clear motor errors (e.g., overheating).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def clear_error(self) -&gt; None:\n    \"\"\"Clear motor errors (e.g., overheating).\"\"\"\n    self.send_raw(self.encode_clear_error_msg())\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.encode_clear_error_msg","title":"encode_clear_error_msg  <code>staticmethod</code>","text":"<pre><code>encode_clear_error_msg() -&gt; bytes\n</code></pre> <p>Encode clear error command (clears motor errors like overheating).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>@staticmethod\ndef encode_clear_error_msg() -&gt; bytes:\n    \"\"\"Encode clear error command (clears motor errors like overheating).\"\"\"\n    return bytes([0xFF] * 7 + [0xFB])\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.encode_cmd_msg","title":"encode_cmd_msg","text":"<pre><code>encode_cmd_msg(pos: float, vel: float, torq: float, kp: float, kd: float) -&gt; bytes\n</code></pre> <p>Encode a command to CAN frame for sending to the motor. Uses this motor's P/V/T limits (from motor_type preset) and fixed kp (KP_MIN/KP_MAX), kd (KD_MIN/KD_MAX).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def encode_cmd_msg(\n    self, pos: float, vel: float, torq: float, kp: float, kd: float\n) -&gt; bytes:\n    \"\"\"\n    Encode a command to CAN frame for sending to the motor.\n    Uses this motor's P/V/T limits (from motor_type preset) and fixed kp (KP_MIN/KP_MAX), kd (KD_MIN/KD_MAX).\n    \"\"\"\n    pos_u = float_to_uint(pos, self._p_min, self._p_max, 16)\n    vel_u = float_to_uint(vel, self._v_min, self._v_max, 12)\n    kp_u = float_to_uint(kp, KP_MIN, KP_MAX, 12)\n    kd_u = float_to_uint(kd, KD_MIN, KD_MAX, 12)\n    torq_u = float_to_uint(torq, self._t_min, self._t_max, 12)\n\n    data = [\n        (pos_u &gt;&gt; 8) &amp; 0xFF,\n        pos_u &amp; 0xFF,\n        (vel_u &gt;&gt; 4) &amp; 0xFF,\n        ((vel_u &amp; 0xF) &lt;&lt; 4) | ((kp_u &gt;&gt; 8) &amp; 0xF),\n        kp_u &amp; 0xFF,\n        (kd_u &gt;&gt; 4) &amp; 0xFF,\n        ((kd_u &amp; 0xF) &lt;&lt; 4) | ((torq_u &gt;&gt; 8) &amp; 0xF),\n        torq_u &amp; 0xFF,\n    ]\n    return bytes(data)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.encode_save_position_zero_msg","title":"encode_save_position_zero_msg  <code>staticmethod</code>","text":"<pre><code>encode_save_position_zero_msg() -&gt; bytes\n</code></pre> <p>Encode save position zero command (sets current position to zero).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>@staticmethod\ndef encode_save_position_zero_msg() -&gt; bytes:\n    \"\"\"Encode save position zero command (sets current position to zero).\"\"\"\n    return bytes([0xFF] * 7 + [0xFE])\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.ensure_control_mode","title":"ensure_control_mode","text":"<pre><code>ensure_control_mode(control_mode: str) -&gt; None\n</code></pre> <p>Ensure control mode (register 10) matches the desired mode. Reads register 10; if it differs, writes and verifies.</p> <p>Parameters:</p> Name Type Description Default <code>control_mode</code> <code>str</code> <p>\"MIT\", \"POS_VEL\", \"VEL\", or \"FORCE_POS\"</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If control_mode is invalid or register value is invalid</p> <code>TimeoutError</code> <p>If reading/writing register times out</p> <code>RuntimeError</code> <p>Other errors during register operations, or if verification after write fails</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def ensure_control_mode(self, control_mode: str) -&gt; None:\n    \"\"\"\n    Ensure control mode (register 10) matches the desired mode.\n    Reads register 10; if it differs, writes and verifies.\n\n    Args:\n        control_mode: \"MIT\", \"POS_VEL\", \"VEL\", or \"FORCE_POS\"\n\n    Raises:\n        ValueError: If control_mode is invalid or register value is invalid\n        TimeoutError: If reading/writing register times out\n        RuntimeError: Other errors during register operations, or if verification after write fails\n    \"\"\"\n    mode_to_register = {\"MIT\": 1, \"POS_VEL\": 2, \"VEL\": 3, \"FORCE_POS\": 4}\n    if control_mode not in mode_to_register:\n        raise ValueError(\n            f\"Invalid control_mode: {control_mode}. Must be one of {list(mode_to_register.keys())}\"\n        )\n    desired = mode_to_register[control_mode]\n\n    try:\n        current = int(self.get_register(10, timeout=1.0))\n        if current == desired:\n            return\n        print(\n            f\"\u26a0 Control mode mismatch: register 10 = {current}, required = {desired}\"\n        )\n        print(\n            f\"  Setting control mode to {control_mode} (register value: {desired})...\"\n        )\n        self.write_register(10, desired)\n        time.sleep(0.1)\n        verify = int(self.get_register(10, timeout=1.0))\n        if verify != desired:\n            raise RuntimeError(\n                f\"Control mode verification failed after write: expected {desired}, got {verify}\"\n            )\n        print(f\"\u2713 Control mode set to {control_mode}\")\n    except TimeoutError as e:\n        raise TimeoutError(\n            f\"Timeout while checking/setting control mode (register 10): {e}\"\n        ) from e\n    except ValueError as e:\n        raise ValueError(f\"Invalid control mode value in register 10: {e}\") from e\n    except RuntimeError:\n        raise  # verification failure, preserve message\n    except Exception as e:\n        raise RuntimeError(f\"Error checking/setting control mode: {e}\") from e\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.get_register","title":"get_register","text":"<pre><code>get_register(rid: int, timeout: float = 1.0) -&gt; float | int\n</code></pre> <p>Read a register value from the motor.</p> <p>If the value is not already cached, sends a read request and waits for the controller's background polling to receive the reply. The motor never reads from the bus; only the controller's poll_feedback does, avoiding multiple consumers.</p> <p>Requires the motor to be managed by a DaMiaoController (added via controller.add_motor). Standalone motors can only return cached values.</p> <p>Parameters:</p> Name Type Description Default <code>rid</code> <code>int</code> <p>Register ID (0-81)</p> required <code>timeout</code> <code>float</code> <p>Timeout in seconds to wait for response</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float | int</code> <p>Register value as float or int depending on register data type</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If register ID is not in the register table</p> <code>RuntimeError</code> <p>If the motor is not managed by a controller (no background polling)</p> <code>TimeoutError</code> <p>If the register reply was not received within timeout</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def get_register(self, rid: int, timeout: float = 1.0) -&gt; float | int:\n    \"\"\"\n    Read a register value from the motor.\n\n    If the value is not already cached, sends a read request and waits for the\n    controller's background polling to receive the reply. The motor never\n    reads from the bus; only the controller's poll_feedback does, avoiding\n    multiple consumers.\n\n    Requires the motor to be managed by a DaMiaoController (added via\n    controller.add_motor). Standalone motors can only return cached values.\n\n    Args:\n        rid: Register ID (0-81)\n        timeout: Timeout in seconds to wait for response\n\n    Returns:\n        Register value as float or int depending on register data type\n\n    Raises:\n        KeyError: If register ID is not in the register table\n        RuntimeError: If the motor is not managed by a controller (no background polling)\n        TimeoutError: If the register reply was not received within timeout\n    \"\"\"\n    if rid not in REGISTER_TABLE:\n        raise KeyError(f\"Register {rid} not found in register table\")\n    with self.registers_lock:\n        if rid in self.registers:\n            return self.registers[rid]\n    if getattr(self, \"_controller\", None) is None:\n        raise RuntimeError(\n            \"get_register requires the motor to be managed by a DaMiaoController \"\n            \"(added via controller.add_motor). The controller's background polling \"\n            \"is the only bus reader; standalone motors cannot block-wait for register replies.\"\n        )\n    self.request_register_reading(rid)\n    deadline = time.time() + timeout\n    while True:\n        with self.registers_lock:\n            if rid in self.registers:\n                return self.registers[rid]\n        if time.time() &gt;= deadline:\n            raise TimeoutError(f\"Register {rid} not received within {timeout}s\")\n        time.sleep(0.01)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.get_register_info","title":"get_register_info","text":"<pre><code>get_register_info(rid: int) -&gt; RegisterInfo\n</code></pre> <p>Get information about a register.</p> <p>Parameters:</p> Name Type Description Default <code>rid</code> <code>int</code> <p>Register ID</p> required <p>Returns:</p> Type Description <code>RegisterInfo</code> <p>RegisterInfo object with register details</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If register ID is not in the register table</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def get_register_info(self, rid: int) -&gt; RegisterInfo:\n    \"\"\"\n    Get information about a register.\n\n    Args:\n        rid: Register ID\n\n    Returns:\n        RegisterInfo object with register details\n\n    Raises:\n        KeyError: If register ID is not in the register table\n    \"\"\"\n    if rid not in REGISTER_TABLE:\n        raise KeyError(f\"Register {rid} not found in register table\")\n    return REGISTER_TABLE[rid]\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.get_states","title":"get_states","text":"<pre><code>get_states() -&gt; Dict[str, Any]\n</code></pre> <p>Get the current motor state dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing current motor state information:</p> <code>Dict[str, Any]</code> <ul> <li>can_id: CAN ID</li> </ul> <code>Dict[str, Any]</code> <ul> <li>status: Human-readable status name</li> </ul> <code>Dict[str, Any]</code> <ul> <li>status_code: Status code</li> </ul> <code>Dict[str, Any]</code> <ul> <li>pos: Position</li> </ul> <code>Dict[str, Any]</code> <ul> <li>vel: Velocity</li> </ul> <code>Dict[str, Any]</code> <ul> <li>torq: Torque</li> </ul> <code>Dict[str, Any]</code> <ul> <li>t_mos: MOSFET temperature</li> </ul> <code>Dict[str, Any]</code> <ul> <li>t_rotor: Rotor temperature</li> </ul> <code>Dict[str, Any]</code> <ul> <li>arbitration_id: CAN arbitration ID</li> </ul> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def get_states(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the current motor state dictionary.\n\n    Returns:\n        Dictionary containing current motor state information:\n        - can_id: CAN ID\n        - status: Human-readable status name\n        - status_code: Status code\n        - pos: Position\n        - vel: Velocity\n        - torq: Torque\n        - t_mos: MOSFET temperature\n        - t_rotor: Rotor temperature\n        - arbitration_id: CAN arbitration ID\n    \"\"\"\n    return self.state.copy() if self.state else {}\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.read_all_registers","title":"read_all_registers","text":"<pre><code>read_all_registers(timeout: float = 0.05) -&gt; Dict[int, float | int]\n</code></pre> <p>Read all registers from the motor.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Timeout in seconds per register read</p> <code>0.05</code> <p>Returns:</p> Type Description <code>Dict[int, float | int]</code> <p>Dictionary mapping register ID to value</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def read_all_registers(self, timeout: float = 0.05) -&gt; Dict[int, float | int]:\n    \"\"\"\n    Read all registers from the motor.\n\n    Args:\n        timeout: Timeout in seconds per register read\n\n    Returns:\n        Dictionary mapping register ID to value\n    \"\"\"\n    for rid, reg_info in REGISTER_TABLE.items():\n        if reg_info.access in [\"RO\", \"RW\"]:  # Readable registers\n            self.request_register_reading(rid)\n            time.sleep(0.0005)\n    results: Dict[int, float | int] = {}\n    time.sleep(0.01)  # wait for the replies\n    for rid, reg_info in REGISTER_TABLE.items():\n        if reg_info.access in [\"RO\", \"RW\"]:  # Readable registers\n            try:\n                results[rid] = self.get_register(rid, timeout=timeout)\n            except (TimeoutError, KeyError, ValueError, RuntimeError) as e:\n                # Store error as string for debugging\n                results[rid] = f\"ERROR: {e}\"\n    return results\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.request_motor_feedback","title":"request_motor_feedback","text":"<pre><code>request_motor_feedback() -&gt; None\n</code></pre> <p>Request motor feedback/status information. After successful transmission, the motor driver will return current status information.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def request_motor_feedback(self) -&gt; None:\n    \"\"\"\n    Request motor feedback/status information.\n    After successful transmission, the motor driver will return current status information.\n    \"\"\"\n    canid_l, canid_h = self._encode_can_id(self.motor_id)\n    msg_data = bytes([canid_l, canid_h, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00])\n    self.send_raw(msg_data, arbitration_id=0x7FF)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.request_register_reading","title":"request_register_reading","text":"<pre><code>request_register_reading(rid: int) -&gt; None\n</code></pre> <p>Request a register reading from the motor.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def request_register_reading(self, rid: int) -&gt; None:\n    \"\"\"\n    Request a register reading from the motor.\n    \"\"\"\n    with self.register_request_time_lock:\n        self.register_request_time[rid] = time.perf_counter()\n    self._send_register_cmd(0x33, rid)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.send_cmd","title":"send_cmd","text":"<pre><code>send_cmd(target_position: float = 0.0, target_velocity: float = 0.0, stiffness: float = 0.0, damping: float = 0.0, feedforward_torque: float = 0.0, control_mode: str = 'MIT', velocity_limit: float = 0.0, torque_limit_ratio: float = 0.0) -&gt; None\n</code></pre> <p>Send command to motor with specified control mode (convenience wrapper).</p> <p>This method is a convenience wrapper that calls the appropriate mode-specific method. For better type safety and clarity, consider using the mode-specific methods directly: - <code>send_cmd_mit()</code> for MIT mode - <code>send_cmd_pos_vel()</code> for POS_VEL mode - <code>send_cmd_vel()</code> for VEL mode - <code>send_cmd_force_pos()</code> for FORCE_POS mode</p> <p>Parameters:</p> Name Type Description Default <code>target_position</code> <code>float</code> <p>Desired position (radians)</p> <code>0.0</code> <code>target_velocity</code> <code>float</code> <p>Desired velocity (rad/s) for MIT and VEL modes</p> <code>0.0</code> <code>stiffness</code> <code>float</code> <p>Stiffness (kp) for MIT mode</p> <code>0.0</code> <code>damping</code> <code>float</code> <p>Damping (kd) for MIT mode</p> <code>0.0</code> <code>feedforward_torque</code> <code>float</code> <p>Feedforward torque for MIT mode</p> <code>0.0</code> <code>control_mode</code> <code>str</code> <p>Control mode - \"MIT\" (default), \"POS_VEL\", \"VEL\", or \"FORCE_POS\"</p> <code>'MIT'</code> <code>velocity_limit</code> <code>float</code> <p>Velocity limit. Used as max speed for POS_VEL and as clipped limit (0-100 rad/s) for FORCE_POS</p> <code>0.0</code> <code>torque_limit_ratio</code> <code>float</code> <p>Normalized torque-limit coefficient (0.0-1.0) for FORCE_POS mode. Effective torque clip: tau_lim = torque_limit_ratio * T_max(motor_type).</p> <code>0.0</code> Note <p>Before using this method to send commands, ensure that the motor's control mode register (register 10) is set to match the desired control_mode argument (\"MIT\", \"POS_VEL\", \"VEL\", or \"FORCE_POS\"). If the register does not match, the motor will not respond to commands and will not move.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def send_cmd(\n    self,\n    target_position: float = 0.0,\n    target_velocity: float = 0.0,\n    stiffness: float = 0.0,\n    damping: float = 0.0,\n    feedforward_torque: float = 0.0,\n    control_mode: str = \"MIT\",\n    velocity_limit: float = 0.0,\n    torque_limit_ratio: float = 0.0,\n) -&gt; None:\n    \"\"\"\n    Send command to motor with specified control mode (convenience wrapper).\n\n    This method is a convenience wrapper that calls the appropriate mode-specific method.\n    For better type safety and clarity, consider using the mode-specific methods directly:\n    - `send_cmd_mit()` for MIT mode\n    - `send_cmd_pos_vel()` for POS_VEL mode\n    - `send_cmd_vel()` for VEL mode\n    - `send_cmd_force_pos()` for FORCE_POS mode\n\n    Args:\n        target_position: Desired position (radians)\n        target_velocity: Desired velocity (rad/s) for MIT and VEL modes\n        stiffness: Stiffness (kp) for MIT mode\n        damping: Damping (kd) for MIT mode\n        feedforward_torque: Feedforward torque for MIT mode\n        control_mode: Control mode - \"MIT\" (default), \"POS_VEL\", \"VEL\", or \"FORCE_POS\"\n        velocity_limit: Velocity limit. Used as max speed for POS_VEL and as clipped limit (0-100 rad/s) for FORCE_POS\n        torque_limit_ratio: Normalized torque-limit coefficient (0.0-1.0) for\n            FORCE_POS mode. Effective torque clip:\n            tau_lim = torque_limit_ratio * T_max(motor_type).\n\n    Note:\n        Before using this method to send commands, ensure that the motor's control mode register (register 10)\n        is set to match the desired control_mode argument (\"MIT\", \"POS_VEL\", \"VEL\", or \"FORCE_POS\").\n        If the register does not match, the motor will not respond to commands and will not move.\n    \"\"\"\n    if control_mode == \"MIT\":\n        self.send_cmd_mit(\n            target_position, target_velocity, stiffness, damping, feedforward_torque\n        )\n    elif control_mode == \"POS_VEL\":\n        self.send_cmd_pos_vel(target_position, velocity_limit)\n    elif control_mode == \"VEL\":\n        self.send_cmd_vel(target_velocity)\n    elif control_mode == \"FORCE_POS\":\n        self.send_cmd_force_pos(target_position, velocity_limit, torque_limit_ratio)\n    else:\n        raise ValueError(\n            f\"Unknown control_mode: {control_mode}. Must be 'MIT', 'POS_VEL', 'VEL', or 'FORCE_POS'\"\n        )\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.send_cmd_force_pos","title":"send_cmd_force_pos","text":"<pre><code>send_cmd_force_pos(target_position: float = 0.0, velocity_limit: float = 0.0, torque_limit_ratio: float = 0.0) -&gt; None\n</code></pre> <p>Send FORCE_POS (Force Position) control command.</p> <p>Parameters:</p> Name Type Description Default <code>target_position</code> <code>float</code> <p>Desired position (radians)</p> <code>0.0</code> <code>velocity_limit</code> <code>float</code> <p>Velocity limit (rad/s, 0-100) for FORCE_POS mode</p> <code>0.0</code> <code>torque_limit_ratio</code> <code>float</code> <p>Normalized torque-limit coefficient for FORCE_POS mode. The effective torque clip is: tau_lim = torque_limit_ratio * T_max(motor_type) where T_max comes from the selected motor_type preset. Example: for motor_type \"4340\", T_max=28 Nm, so torque_limit_ratio=0.5 gives tau_lim=14 Nm.</p> <code>0.0</code> Note <p>Before using this method, ensure that the motor's control mode register (register 10) is set to FORCE_POS mode (value 4). Use <code>ensure_control_mode(\"FORCE_POS\")</code> or <code>set_control_mode(4)</code>.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def send_cmd_force_pos(\n    self,\n    target_position: float = 0.0,\n    velocity_limit: float = 0.0,\n    torque_limit_ratio: float = 0.0,\n) -&gt; None:\n    \"\"\"\n    Send FORCE_POS (Force Position) control command.\n\n    Args:\n        target_position: Desired position (radians)\n        velocity_limit: Velocity limit (rad/s, 0-100) for FORCE_POS mode\n        torque_limit_ratio: Normalized torque-limit coefficient for FORCE_POS mode.\n            The effective torque clip is:\n            tau_lim = torque_limit_ratio * T_max(motor_type)\n            where T_max comes from the selected motor_type preset.\n            Example: for motor_type \"4340\", T_max=28 Nm, so torque_limit_ratio=0.5\n            gives tau_lim=14 Nm.\n\n    Note:\n        Before using this method, ensure that the motor's control mode register (register 10)\n        is set to FORCE_POS mode (value 4). Use `ensure_control_mode(\"FORCE_POS\")` or `set_control_mode(4)`.\n    \"\"\"\n    self._check_motor_status()\n    # FORCE_POS Mode: CAN ID 0x300 + motor_id\n    # Clamp and scale velocity limit (0-100 rad/s -&gt; 0-10000)\n    v_des_clamped = max(0.0, min(100.0, velocity_limit))\n    v_des_scaled = int(v_des_clamped * 100)\n    v_des_scaled = min(10000, v_des_scaled)\n\n    # Clamp and scale torque limit ratio (0.0-1.0 -&gt; 0-10000)\n    i_des_clamped = max(0.0, min(1.0, torque_limit_ratio))\n    i_des_scaled = int(i_des_clamped * 10000)\n    i_des_scaled = min(10000, i_des_scaled)\n\n    # Pack: float (4 bytes) + uint16 (2 bytes) + uint16 (2 bytes)\n    data = struct.pack(\"&lt;fHH\", target_position, v_des_scaled, i_des_scaled)\n    arbitration_id = 0x300 + self.motor_id\n    self.send_raw(data, arbitration_id=arbitration_id)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.send_cmd_mit","title":"send_cmd_mit","text":"<pre><code>send_cmd_mit(target_position: float = 0.0, target_velocity: float = 0.0, stiffness: float = 0.0, damping: float = 0.0, feedforward_torque: float = 0.0) -&gt; None\n</code></pre> <p>Send MIT (Position + Velocity + Torque) control command.</p> <p>Parameters:</p> Name Type Description Default <code>target_position</code> <code>float</code> <p>Desired position (radians)</p> <code>0.0</code> <code>target_velocity</code> <code>float</code> <p>Desired velocity (rad/s)</p> <code>0.0</code> <code>stiffness</code> <code>float</code> <p>Stiffness (kp) for MIT mode</p> <code>0.0</code> <code>damping</code> <code>float</code> <p>Damping (kd) for MIT mode</p> <code>0.0</code> <code>feedforward_torque</code> <code>float</code> <p>Feedforward torque for MIT mode</p> <code>0.0</code> Note <p>Before using this method, ensure that the motor's control mode register (register 10) is set to MIT mode (value 1). Use <code>ensure_control_mode(\"MIT\")</code> or <code>set_control_mode(1)</code>.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def send_cmd_mit(\n    self,\n    target_position: float = 0.0,\n    target_velocity: float = 0.0,\n    stiffness: float = 0.0,\n    damping: float = 0.0,\n    feedforward_torque: float = 0.0,\n) -&gt; None:\n    \"\"\"\n    Send MIT (Position + Velocity + Torque) control command.\n\n    Args:\n        target_position: Desired position (radians)\n        target_velocity: Desired velocity (rad/s)\n        stiffness: Stiffness (kp) for MIT mode\n        damping: Damping (kd) for MIT mode\n        feedforward_torque: Feedforward torque for MIT mode\n\n    Note:\n        Before using this method, ensure that the motor's control mode register (register 10)\n        is set to MIT mode (value 1). Use `ensure_control_mode(\"MIT\")` or `set_control_mode(1)`.\n    \"\"\"\n    self._check_motor_status()\n    data = self.encode_cmd_msg(\n        target_position, target_velocity, feedforward_torque, stiffness, damping\n    )\n    self.send_raw(data)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.send_cmd_pos_vel","title":"send_cmd_pos_vel","text":"<pre><code>send_cmd_pos_vel(target_position: float = 0.0, velocity_limit: float = 0.0) -&gt; None\n</code></pre> <p>Send POS_VEL (Position + Velocity) control command.</p> <p>Parameters:</p> Name Type Description Default <code>target_position</code> <code>float</code> <p>Desired position (radians)</p> <code>0.0</code> <code>velocity_limit</code> <code>float</code> <p>Maximum velocity during motion (rad/s)</p> <code>0.0</code> Note <p>Before using this method, ensure that the motor's control mode register (register 10) is set to POS_VEL mode (value 2). Use <code>ensure_control_mode(\"POS_VEL\")</code> or <code>set_control_mode(2)</code>.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def send_cmd_pos_vel(\n    self,\n    target_position: float = 0.0,\n    velocity_limit: float = 0.0,\n) -&gt; None:\n    \"\"\"\n    Send POS_VEL (Position + Velocity) control command.\n\n    Args:\n        target_position: Desired position (radians)\n        velocity_limit: Maximum velocity during motion (rad/s)\n\n    Note:\n        Before using this method, ensure that the motor's control mode register (register 10)\n        is set to POS_VEL mode (value 2). Use `ensure_control_mode(\"POS_VEL\")` or `set_control_mode(2)`.\n    \"\"\"\n    self._check_motor_status()\n    # POS_VEL Mode: CAN ID 0x100 + motor_id\n    data = struct.pack(\"&lt;ff\", target_position, velocity_limit)\n    arbitration_id = 0x100 + self.motor_id\n    self.send_raw(data, arbitration_id=arbitration_id)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.send_cmd_vel","title":"send_cmd_vel","text":"<pre><code>send_cmd_vel(target_velocity: float = 0.0) -&gt; None\n</code></pre> <p>Send VEL (Velocity) control command.</p> <p>Parameters:</p> Name Type Description Default <code>target_velocity</code> <code>float</code> <p>Desired velocity (rad/s)</p> <code>0.0</code> Note <p>Before using this method, ensure that the motor's control mode register (register 10) is set to VEL mode (value 3). Use <code>ensure_control_mode(\"VEL\")</code> or <code>set_control_mode(3)</code>.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def send_cmd_vel(\n    self,\n    target_velocity: float = 0.0,\n) -&gt; None:\n    \"\"\"\n    Send VEL (Velocity) control command.\n\n    Args:\n        target_velocity: Desired velocity (rad/s)\n\n    Note:\n        Before using this method, ensure that the motor's control mode register (register 10)\n        is set to VEL mode (value 3). Use `ensure_control_mode(\"VEL\")` or `set_control_mode(3)`.\n    \"\"\"\n    self._check_motor_status()\n    # VEL Mode: CAN ID 0x200 + motor_id\n    data = struct.pack(\"&lt;f\", target_velocity) + b\"\\x00\" * 4\n    arbitration_id = 0x200 + self.motor_id\n    self.send_raw(data, arbitration_id=arbitration_id)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.send_raw","title":"send_raw","text":"<pre><code>send_raw(data: bytes, arbitration_id: int | None = None) -&gt; None\n</code></pre> <p>Send raw CAN message.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>CAN message data bytes (must be 8 bytes)</p> required <code>arbitration_id</code> <code>int | None</code> <p>CAN arbitration ID (defaults to motor_id if not specified)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data is not 8 bytes or arbitration_id is invalid</p> <code>OSError</code> <p>If CAN bus error occurs (e.g., Error Code 105 - No buffer space)</p> <code>CanError</code> <p>If CAN-specific error occurs</p> <code>AttributeError</code> <p>If bus is not initialized</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def send_raw(self, data: bytes, arbitration_id: int | None = None) -&gt; None:\n    \"\"\"\n    Send raw CAN message.\n\n    Args:\n        data: CAN message data bytes (must be 8 bytes)\n        arbitration_id: CAN arbitration ID (defaults to motor_id if not specified)\n\n    Raises:\n        ValueError: If data is not 8 bytes or arbitration_id is invalid\n        OSError: If CAN bus error occurs (e.g., Error Code 105 - No buffer space)\n        can.CanError: If CAN-specific error occurs\n        AttributeError: If bus is not initialized\n    \"\"\"\n    if len(data) != 8:\n        raise ValueError(f\"CAN message data must be 8 bytes, got {len(data)} bytes\")\n\n    if arbitration_id is None:\n        arbitration_id = self.motor_id\n\n    if arbitration_id &lt; 0 or arbitration_id &gt; 0x7FF:\n        raise ValueError(\n            f\"Invalid arbitration_id: {arbitration_id}. Must be in range 0-0x7FF\"\n        )\n\n    try:\n        msg = can.Message(\n            arbitration_id=arbitration_id, data=data, is_extended_id=False\n        )\n        self.bus.send(msg)\n    except OSError as e:\n        error_str = str(e)\n        errno = getattr(e, \"errno\", None)\n\n        # Error Code 105: No buffer space available\n        if (\n            errno == 105\n            or \"Error Code 105\" in error_str\n            or \"No buffer space available\" in error_str\n            or \"[Errno 105]\" in error_str\n        ):\n            raise OSError(\n                f\"CAN bus buffer full (Error Code 105) when sending to arbitration_id 0x{arbitration_id:03X}. \"\n                f\"This typically indicates: no motor connected, motor not powered, or CAN hardware issue. \"\n                f\"Original error: {e}\"\n            ) from e\n        # Other OSError cases\n        raise OSError(\n            f\"CAN bus system error when sending to arbitration_id 0x{arbitration_id:03X}: {e}\"\n        ) from e\n    except can.CanError as e:\n        raise can.CanError(\n            f\"CAN bus error when sending to arbitration_id 0x{arbitration_id:03X}: {e}\"\n        ) from e\n    except AttributeError as e:\n        if \"bus\" in str(e).lower() or \"send\" in str(e).lower():\n            raise AttributeError(\n                \"CAN bus not initialized. Bus may be closed or not connected.\"\n            ) from e\n        raise\n    except Exception as e:\n        raise RuntimeError(\n            f\"Unexpected error sending CAN message to arbitration_id 0x{arbitration_id:03X}: {e}\"\n        ) from e\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_acceleration","title":"set_acceleration","text":"<pre><code>set_acceleration(value: float) -&gt; None\n</code></pre> <p>Set acceleration (register 4).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_acceleration(self, value: float) -&gt; None:\n    \"\"\"Set acceleration (register 4).\"\"\"\n    self.write_register(4, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_can_baud_rate","title":"set_can_baud_rate","text":"<pre><code>set_can_baud_rate(baud_rate_code: int) -&gt; None\n</code></pre> <p>Set CAN baud rate using register 35 (can_br).</p> <p>Parameters:</p> Name Type Description Default <code>baud_rate_code</code> <code>int</code> <p>Baud rate code (0=125K, 1=200K, 2=250K, 3=500K, 4=1M)</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If baud_rate_code is not in valid range [0, 4]</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_can_baud_rate(self, baud_rate_code: int) -&gt; None:\n    \"\"\"\n    Set CAN baud rate using register 35 (can_br).\n\n    Args:\n        baud_rate_code: Baud rate code (0=125K, 1=200K, 2=250K, 3=500K, 4=1M)\n\n    Raises:\n        ValueError: If baud_rate_code is not in valid range [0, 4]\n    \"\"\"\n    if baud_rate_code not in CAN_BAUD_RATE_CODES:\n        raise ValueError(\n            f\"Invalid baud rate code: {baud_rate_code}. Must be in {list(CAN_BAUD_RATE_CODES.keys())}\"\n        )\n\n    self.write_register(35, baud_rate_code)  # Register 35 is can_br\n    self.store_parameters()  # Store to flash so it persists\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_can_timeout","title":"set_can_timeout","text":"<pre><code>set_can_timeout(timeout_ms: int) -&gt; None\n</code></pre> <p>Set CAN timeout alarm time (register 9).</p> <p>Parameters:</p> Name Type Description Default <code>timeout_ms</code> <code>int</code> <p>Timeout in milliseconds</p> required Note <p>Register 9 stores timeout in units of 50 microseconds: 1 register unit = 50 microseconds.</p> <p>Conversion formula: register_value = timeout_ms \u00d7 20</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_can_timeout(self, timeout_ms: int) -&gt; None:\n    \"\"\"\n    Set CAN timeout alarm time (register 9).\n\n    Args:\n        timeout_ms: Timeout in milliseconds\n\n    Note:\n        Register 9 stores timeout in units of 50 microseconds: **1 register unit = 50 microseconds**.\n\n        Conversion formula: register_value = timeout_ms \u00d7 20\n    \"\"\"\n    # Convert milliseconds to register units: 1 register unit = 50 microseconds\n    # timeout_ms * 1000 us/ms / 50 us/unit = timeout_ms * 20\n    register_value = timeout_ms * 20\n    self.write_register(9, register_value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_control_mode","title":"set_control_mode","text":"<pre><code>set_control_mode(value: int) -&gt; None\n</code></pre> <p>Set control mode (register 10).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_control_mode(self, value: int) -&gt; None:\n    \"\"\"Set control mode (register 10).\"\"\"\n    self.write_register(10, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_current_loop_bandwidth","title":"set_current_loop_bandwidth","text":"<pre><code>set_current_loop_bandwidth(value: float) -&gt; None\n</code></pre> <p>Set current loop control bandwidth (register 24).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_current_loop_bandwidth(self, value: float) -&gt; None:\n    \"\"\"Set current loop control bandwidth (register 24).\"\"\"\n    self.write_register(24, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_current_loop_enhancement","title":"set_current_loop_enhancement","text":"<pre><code>set_current_loop_enhancement(value: float) -&gt; None\n</code></pre> <p>Set current loop enhancement coefficient (register 33).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_current_loop_enhancement(self, value: float) -&gt; None:\n    \"\"\"Set current loop enhancement coefficient (register 33).\"\"\"\n    self.write_register(33, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_deceleration","title":"set_deceleration","text":"<pre><code>set_deceleration(value: float) -&gt; None\n</code></pre> <p>Set deceleration (register 5).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_deceleration(self, value: float) -&gt; None:\n    \"\"\"Set deceleration (register 5).\"\"\"\n    self.write_register(5, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_feedback_id","title":"set_feedback_id","text":"<pre><code>set_feedback_id(value: int) -&gt; None\n</code></pre> <p>Set feedback ID (register 7).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_feedback_id(self, value: int) -&gt; None:\n    \"\"\"Set feedback ID (register 7).\"\"\"\n    self.write_register(7, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_gear_efficiency","title":"set_gear_efficiency","text":"<pre><code>set_gear_efficiency(value: float) -&gt; None\n</code></pre> <p>Set gear torque efficiency (register 30).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_gear_efficiency(self, value: float) -&gt; None:\n    \"\"\"Set gear torque efficiency (register 30).\"\"\"\n    self.write_register(30, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_limits","title":"set_limits","text":"<pre><code>set_limits(*, p_min: Optional[float] = None, p_max: Optional[float] = None, v_min: Optional[float] = None, v_max: Optional[float] = None, t_min: Optional[float] = None, t_max: Optional[float] = None) -&gt; None\n</code></pre> <p>Update only the specified P/V/T limits. Omitted keys are left unchanged. kp and kd are fixed (KP_MIN/KP_MAX, KD_MIN/KD_MAX).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_limits(\n    self,\n    *,\n    p_min: Optional[float] = None,\n    p_max: Optional[float] = None,\n    v_min: Optional[float] = None,\n    v_max: Optional[float] = None,\n    t_min: Optional[float] = None,\n    t_max: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Update only the specified P/V/T limits. Omitted keys are left unchanged. kp and kd are fixed (KP_MIN/KP_MAX, KD_MIN/KD_MAX).\"\"\"\n    if p_min is not None:\n        self._p_min = p_min\n    if p_max is not None:\n        self._p_max = p_max\n    if v_min is not None:\n        self._v_min = v_min\n    if v_max is not None:\n        self._v_max = v_max\n    if t_min is not None:\n        self._t_min = t_min\n    if t_max is not None:\n        self._t_max = t_max\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_maximum_speed","title":"set_maximum_speed","text":"<pre><code>set_maximum_speed(value: float) -&gt; None\n</code></pre> <p>Set maximum speed (register 6).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_maximum_speed(self, value: float) -&gt; None:\n    \"\"\"Set maximum speed (register 6).\"\"\"\n    self.write_register(6, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_motor_type","title":"set_motor_type","text":"<pre><code>set_motor_type(motor_type: str) -&gt; None\n</code></pre> <p>Update motor type and P/V/T limits from a preset. Validates against MOTOR_TYPE_PRESETS.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_motor_type(self, motor_type: str) -&gt; None:\n    \"\"\"Update motor type and P/V/T limits from a preset. Validates against MOTOR_TYPE_PRESETS.\"\"\"\n    if motor_type not in MOTOR_TYPE_PRESETS:\n        raise ValueError(\n            f\"Unknown motor_type: {motor_type!r}. \"\n            f\"Known: {list(MOTOR_TYPE_PRESETS.keys())}\"\n        )\n    base = dict(MOTOR_TYPE_PRESETS[motor_type])\n    for k in _LIMITS_KEYS:\n        setattr(self, f\"_{k}\", base[k])\n    self.motor_type = motor_type\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_over_current_protection","title":"set_over_current_protection","text":"<pre><code>set_over_current_protection(value: float) -&gt; None\n</code></pre> <p>Set over-current protection value (register 3).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_over_current_protection(self, value: float) -&gt; None:\n    \"\"\"Set over-current protection value (register 3).\"\"\"\n    self.write_register(3, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_over_temperature_protection","title":"set_over_temperature_protection","text":"<pre><code>set_over_temperature_protection(value: float) -&gt; None\n</code></pre> <p>Set over-temperature protection value (register 2).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_over_temperature_protection(self, value: float) -&gt; None:\n    \"\"\"Set over-temperature protection value (register 2).\"\"\"\n    self.write_register(2, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_overvoltage_protection","title":"set_overvoltage_protection","text":"<pre><code>set_overvoltage_protection(value: float) -&gt; None\n</code></pre> <p>Set overvoltage protection value (register 29).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_overvoltage_protection(self, value: float) -&gt; None:\n    \"\"\"Set overvoltage protection value (register 29).\"\"\"\n    self.write_register(29, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_p_limits","title":"set_p_limits","text":"<pre><code>set_p_limits(p_min: float, p_max: float) -&gt; None\n</code></pre> <p>Set position limits used for encode/decode (MIT mode).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_p_limits(self, p_min: float, p_max: float) -&gt; None:\n    \"\"\"Set position limits used for encode/decode (MIT mode).\"\"\"\n    self._p_min, self._p_max = p_min, p_max\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_position_loop_ki","title":"set_position_loop_ki","text":"<pre><code>set_position_loop_ki(value: float) -&gt; None\n</code></pre> <p>Set position loop integral gain Ki (register 28).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_position_loop_ki(self, value: float) -&gt; None:\n    \"\"\"Set position loop integral gain Ki (register 28).\"\"\"\n    self.write_register(28, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_position_loop_kp","title":"set_position_loop_kp","text":"<pre><code>set_position_loop_kp(value: float) -&gt; None\n</code></pre> <p>Set position loop proportional gain Kp (register 27).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_position_loop_kp(self, value: float) -&gt; None:\n    \"\"\"Set position loop proportional gain Kp (register 27).\"\"\"\n    self.write_register(27, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_position_mapping_range","title":"set_position_mapping_range","text":"<pre><code>set_position_mapping_range(value: float) -&gt; None\n</code></pre> <p>Set position mapping range (register 21).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_position_mapping_range(self, value: float) -&gt; None:\n    \"\"\"Set position mapping range (register 21).\"\"\"\n    self.write_register(21, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_receive_id","title":"set_receive_id","text":"<pre><code>set_receive_id(value: int) -&gt; None\n</code></pre> <p>Set receive ID (register 8).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_receive_id(self, value: int) -&gt; None:\n    \"\"\"Set receive ID (register 8).\"\"\"\n    self.write_register(8, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_speed_loop_damping","title":"set_speed_loop_damping","text":"<pre><code>set_speed_loop_damping(value: float) -&gt; None\n</code></pre> <p>Set speed loop damping coefficient (register 31).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_speed_loop_damping(self, value: float) -&gt; None:\n    \"\"\"Set speed loop damping coefficient (register 31).\"\"\"\n    self.write_register(31, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_speed_loop_enhancement","title":"set_speed_loop_enhancement","text":"<pre><code>set_speed_loop_enhancement(value: float) -&gt; None\n</code></pre> <p>Set speed loop enhancement coefficient (register 34).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_speed_loop_enhancement(self, value: float) -&gt; None:\n    \"\"\"Set speed loop enhancement coefficient (register 34).\"\"\"\n    self.write_register(34, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_speed_loop_filter_bandwidth","title":"set_speed_loop_filter_bandwidth","text":"<pre><code>set_speed_loop_filter_bandwidth(value: float) -&gt; None\n</code></pre> <p>Set speed loop filter bandwidth (register 32).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_speed_loop_filter_bandwidth(self, value: float) -&gt; None:\n    \"\"\"Set speed loop filter bandwidth (register 32).\"\"\"\n    self.write_register(32, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_speed_loop_ki","title":"set_speed_loop_ki","text":"<pre><code>set_speed_loop_ki(value: float) -&gt; None\n</code></pre> <p>Set speed loop integral gain Ki (register 26).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_speed_loop_ki(self, value: float) -&gt; None:\n    \"\"\"Set speed loop integral gain Ki (register 26).\"\"\"\n    self.write_register(26, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_speed_loop_kp","title":"set_speed_loop_kp","text":"<pre><code>set_speed_loop_kp(value: float) -&gt; None\n</code></pre> <p>Set speed loop proportional gain Kp (register 25).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_speed_loop_kp(self, value: float) -&gt; None:\n    \"\"\"Set speed loop proportional gain Kp (register 25).\"\"\"\n    self.write_register(25, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_speed_mapping_range","title":"set_speed_mapping_range","text":"<pre><code>set_speed_mapping_range(value: float) -&gt; None\n</code></pre> <p>Set speed mapping range (register 22).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_speed_mapping_range(self, value: float) -&gt; None:\n    \"\"\"Set speed mapping range (register 22).\"\"\"\n    self.write_register(22, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_t_limits","title":"set_t_limits","text":"<pre><code>set_t_limits(t_min: float, t_max: float) -&gt; None\n</code></pre> <p>Set torque limits used for encode/decode (MIT mode).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_t_limits(self, t_min: float, t_max: float) -&gt; None:\n    \"\"\"Set torque limits used for encode/decode (MIT mode).\"\"\"\n    self._t_min, self._t_max = t_min, t_max\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_timeout_alarm","title":"set_timeout_alarm","text":"<pre><code>set_timeout_alarm(value: int) -&gt; None\n</code></pre> <p>Set timeout alarm time (register 9).</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>Timeout value in register units (1 unit = 50 microseconds)</p> required Note <p>This method writes the raw register value. For convenience, use <code>set_can_timeout()</code> which accepts milliseconds and handles the conversion automatically.</p> <p>Conversion: 1 register unit = 50 microseconds To convert from milliseconds: register_value = timeout_ms \u00d7 20</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_timeout_alarm(self, value: int) -&gt; None:\n    \"\"\"\n    Set timeout alarm time (register 9).\n\n    Args:\n        value: Timeout value in register units (1 unit = 50 microseconds)\n\n    Note:\n        This method writes the raw register value. For convenience, use `set_can_timeout()`\n        which accepts milliseconds and handles the conversion automatically.\n\n        Conversion: 1 register unit = 50 microseconds\n        To convert from milliseconds: register_value = timeout_ms \u00d7 20\n    \"\"\"\n    self.write_register(9, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_torque_coefficient","title":"set_torque_coefficient","text":"<pre><code>set_torque_coefficient(value: float) -&gt; None\n</code></pre> <p>Set torque coefficient (register 1).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_torque_coefficient(self, value: float) -&gt; None:\n    \"\"\"Set torque coefficient (register 1).\"\"\"\n    self.write_register(1, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_torque_mapping_range","title":"set_torque_mapping_range","text":"<pre><code>set_torque_mapping_range(value: float) -&gt; None\n</code></pre> <p>Set torque mapping range (register 23).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_torque_mapping_range(self, value: float) -&gt; None:\n    \"\"\"Set torque mapping range (register 23).\"\"\"\n    self.write_register(23, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_under_voltage_protection","title":"set_under_voltage_protection","text":"<pre><code>set_under_voltage_protection(value: float) -&gt; None\n</code></pre> <p>Set under-voltage protection value (register 0).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_under_voltage_protection(self, value: float) -&gt; None:\n    \"\"\"Set under-voltage protection value (register 0).\"\"\"\n    self.write_register(0, value)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_v_limits","title":"set_v_limits","text":"<pre><code>set_v_limits(v_min: float, v_max: float) -&gt; None\n</code></pre> <p>Set velocity limits used for encode/decode (MIT mode).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_v_limits(self, v_min: float, v_max: float) -&gt; None:\n    \"\"\"Set velocity limits used for encode/decode (MIT mode).\"\"\"\n    self._v_min, self._v_max = v_min, v_max\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_zero_command","title":"set_zero_command","text":"<pre><code>set_zero_command() -&gt; None\n</code></pre> <p>Send zero command (pos=0, vel=0, torq=0, kp=0, kd=0).</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_zero_command(self) -&gt; None:\n    \"\"\"Send zero command (pos=0, vel=0, torq=0, kp=0, kd=0).\"\"\"\n    self.send_cmd_mit(\n        target_position=0.0,\n        target_velocity=0.0,\n        stiffness=0.0,\n        damping=0.0,\n        feedforward_torque=0.0,\n    )\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.set_zero_position","title":"set_zero_position","text":"<pre><code>set_zero_position() -&gt; None\n</code></pre> <p>Set the current output shaft position to zero.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def set_zero_position(self) -&gt; None:\n    \"\"\"Set the current output shaft position to zero.\"\"\"\n    self.send_raw(self.encode_save_position_zero_msg())\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.store_parameters","title":"store_parameters","text":"<pre><code>store_parameters() -&gt; None\n</code></pre> <p>Store all parameters to flash memory. After successful write, all parameters will be written to the chip.</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def store_parameters(self) -&gt; None:\n    \"\"\"\n    Store all parameters to flash memory.\n    After successful write, all parameters will be written to the chip.\n    \"\"\"\n    self._send_register_cmd(0xAA, 0x01)\n</code></pre>","tags":["api","reference","core"]},{"location":"api/motor/#damiao_motor.core.motor.DaMiaoMotor.write_register","title":"write_register","text":"<pre><code>write_register(rid: int, value: float | int) -&gt; None\n</code></pre> <p>Write a value to a register.</p> <p>Parameters:</p> Name Type Description Default <code>rid</code> <code>int</code> <p>Register ID (0-81)</p> required <code>value</code> <code>float | int</code> <p>Value to write (float or int)</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If register ID is not in the register table</p> <code>ValueError</code> <p>If register is read-only or value is out of range</p> Source code in <code>damiao_motor/core/motor.py</code> <pre><code>def write_register(self, rid: int, value: float | int) -&gt; None:\n    \"\"\"\n    Write a value to a register.\n\n    Args:\n        rid: Register ID (0-81)\n        value: Value to write (float or int)\n\n    Raises:\n        KeyError: If register ID is not in the register table\n        ValueError: If register is read-only or value is out of range\n    \"\"\"\n    # Check if register exists in table\n    if rid not in REGISTER_TABLE:\n        raise KeyError(f\"Register {rid} not found in register table\")\n\n    reg_info = REGISTER_TABLE[rid]\n\n    # Check if register is writable\n    if reg_info.access != \"RW\":\n        raise ValueError(\n            f\"Register {rid} ({reg_info.variable}) is read-only (access: {reg_info.access})\"\n        )\n\n    # Encode value to 4 bytes using data type from register table\n    if reg_info.data_type == \"float\":\n        data_bytes = struct.pack(\"&lt;f\", float(value))\n    elif reg_info.data_type == \"uint32\":\n        data_bytes = struct.pack(\"&lt;I\", int(value))\n    else:\n        raise ValueError(\n            f\"Unknown data_type: {reg_info.data_type} for register {rid}\"\n        )\n\n    # Send write command\n    self._send_register_cmd(0x55, rid, data_bytes)\n</code></pre>","tags":["api","reference","core"]},{"location":"concept/can/","title":"CAN Bus Fundamentals","text":"<p>This document explains the CAN (Controller Area Network) bus fundamentals as they relate to DaMiao motors.</p>","tags":["concept","can","hardware"]},{"location":"concept/can/#what-is-can-bus","title":"What is CAN Bus?","text":"<p>CAN bus is a robust, multi-master communication protocol designed for real-time control applications. It's widely used in automotive and industrial automation systems, including robotics.</p>","tags":["concept","can","hardware"]},{"location":"concept/can/#why-can-for-motors","title":"Why CAN for Motors?","text":"<p>CAN bus is ideal for motor control because:</p> <ul> <li>Reliability: Built-in error detection and fault tolerance</li> <li>Real-time: Deterministic message delivery with priority-based arbitration</li> <li>Multi-device: Multiple motors can share a single bus</li> <li>Noise immunity: Differential signaling resists electrical interference</li> <li>Standardized: Well-established protocol with broad hardware support</li> </ul>","tags":["concept","can","hardware"]},{"location":"concept/can/#can-bus-basics","title":"CAN Bus Basics","text":"<p>Physical Layer</p> <ul> <li>Differential signaling: Two wires (CAN_H and CAN_L) carry complementary signals</li> <li>Termination: 120\u03a9 resistors required at both ends of the bus</li> <li>Bitrate: Configurable (typically 1 Mbps for DaMiao motors)</li> <li>Topology: Linear bus (all devices connected in parallel)</li> </ul> <p>Message Format</p> <p>CAN messages consist of:</p> <ul> <li>Arbitration ID: 11-bit identifier (0x000-0x7FF) that determines message priority</li> <li>Data: Up to 8 bytes of payload</li> <li>Control bits: DLC (Data Length Code), RTR (Remote Transmission Request), etc.</li> </ul> <p>Arbitration</p> <p>When multiple devices transmit simultaneously:</p> <ul> <li>Lower arbitration IDs have higher priority</li> <li>Devices with lower priority automatically back off</li> <li>No data is lost during arbitration</li> <li>Winner transmits immediately</li> </ul>","tags":["concept","can","hardware"]},{"location":"concept/can/#damiao-motor-can-configuration","title":"DaMiao Motor CAN Configuration","text":"<p>Bitrate</p> <p>DaMiao motors typically use 1 Mbps (1,000,000 bits per second). The bitrate must match between all devices on the bus.</p> <p>Arbitration IDs</p> <p>DaMiao motors use different arbitration IDs for different purposes:</p> Purpose Arbitration ID Format Example (motor_id=1) MIT Control <code>motor_id</code> 0x001 POS_VEL Control <code>0x100 + motor_id</code> 0x101 VEL Control <code>0x200 + motor_id</code> 0x201 FORCE_POS Control <code>0x300 + motor_id</code> 0x301 Register Operations <code>0x7FF</code> 0x7FF Feedback <code>feedback_id</code> (MST_ID) Variable <p>Message Length</p> <p>All DaMiao motor messages are 8 bytes (standard CAN frame length).</p>","tags":["concept","can","hardware"]},{"location":"concept/can/#socketcan-on-linux","title":"SocketCAN on Linux","text":"<p>The driver uses SocketCAN, the Linux CAN subsystem:</p> <ul> <li>Interface naming: <code>can0</code>, <code>can1</code>, etc.</li> <li>Configuration: Standard Linux network tools (<code>ip link</code>)</li> <li>Access: Standard socket API</li> </ul> <p>Basic Setup</p> <pre><code># Bring up CAN interface\nsudo ip link set can0 up type can bitrate 1000000\n\n# Check status\nip link show can0\n\n# Monitor traffic\ncandump can0\n</code></pre>","tags":["concept","can","hardware"]},{"location":"concept/can/#bus-topology","title":"Bus Topology","text":"<pre><code>[Computer] ----[CAN Interface]----[CAN Bus]----[Motor 1]\n                                              [Motor 2]\n                                              [Motor 3]\n</code></pre> <p>Requirements</p> <ul> <li>Termination resistors: 120\u03a9 at both ends of the bus</li> <li>Bitrate matching: All devices must use the same bitrate</li> <li>Proper wiring: CAN_H and CAN_L must be connected correctly</li> </ul>","tags":["concept","can","hardware"]},{"location":"concept/can/#error-handling","title":"Error Handling","text":"<p>CAN bus includes built-in error detection:</p> <ul> <li>CRC (Cyclic Redundancy Check): Detects transmission errors</li> <li>ACK (Acknowledgment): Confirms successful reception</li> <li>Error frames: Automatically transmitted on error detection</li> <li>Bus-off: Device disconnects after repeated errors</li> </ul>","tags":["concept","can","hardware"]},{"location":"concept/can/#best-practices","title":"Best Practices","text":"<ol> <li>Termination: Always use 120\u03a9 resistors at both bus ends</li> <li>Bitrate: Verify all devices use the same bitrate</li> <li>Cable length: Keep bus length reasonable (&lt; 40m for 1 Mbps)</li> <li>Grounding: Ensure proper ground connections</li> <li>Shielding: Use shielded cables in noisy environments</li> </ol>","tags":["concept","can","hardware"]},{"location":"concept/can/#troubleshooting","title":"Troubleshooting","text":"<p>No Communication</p> <ul> <li>Check CAN interface is up: <code>ip link show can0</code></li> <li>Verify bitrate matches motor configuration</li> <li>Check termination resistors are present</li> <li>Verify motor is powered on</li> </ul> <p>Intermittent Communication</p> <ul> <li>Check for loose connections</li> <li>Verify cable quality and length</li> <li>Check for electrical interference</li> <li>Verify termination resistors</li> </ul> <p>Error Messages</p> <ul> <li>Error Code 105: No buffer space - motor not responding or not powered</li> <li>Timeout errors: Motor not receiving commands or not responding</li> <li>Bus errors: Physical layer issues (wiring, termination, bitrate mismatch)</li> </ul>","tags":["concept","can","hardware"]},{"location":"concept/can/#further-reading","title":"Further Reading","text":"<ul> <li>Motor Control Modes</li> <li>SocketCAN Documentation</li> <li>CAN-utils Documentation</li> </ul>","tags":["concept","can","hardware"]},{"location":"concept/communication-protocol/","title":"Communication Protocol","text":"<p>This document describes the CAN bus communication protocol used by DaMiao motors.</p>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#overview","title":"Overview","text":"<p>DaMiao motors communicate over CAN bus using a custom protocol. The protocol supports:</p> <ul> <li>Command messages: Send control commands to motors</li> <li>Feedback messages: Receive motor state information</li> <li>Register operations: Read/write motor configuration registers</li> </ul>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#message-types","title":"Message Types","text":"<p>1. Control Commands</p> <p>Control commands send motion commands to motors. Each control mode uses a different arbitration ID and fixed 8-byte payload.</p> Mode Arbitration ID Payload MIT <code>motor_id</code> Packed position/velocity/stiffness/damping/feedforward torque POS_VEL <code>0x100 + motor_id</code> <code>Byte 0-3</code>: position (<code>float</code>), <code>Byte 4-7</code>: velocity limit (<code>float</code>) VEL <code>0x200 + motor_id</code> <code>Byte 0-3</code>: target velocity (<code>float</code>), <code>Byte 4-7</code>: padding (<code>0x00</code>) FORCE_POS <code>0x300 + motor_id</code> <code>Byte 0-3</code>: position (<code>float</code>), <code>Byte 4-5</code>: velocity limit (<code>uint16</code>), <code>Byte 6-7</code>: torque limit ratio (<code>uint16</code>) <p>2. System Commands</p> <p>System commands use <code>arbitration_id = motor_id</code> and fixed 8-byte payloads:</p> Command Data Enable motor <code>[FF, FF, FF, FF, FF, FF, FF, FC]</code> Disable motor <code>[FF, FF, FF, FF, FF, FF, FF, FD]</code> Set zero position <code>[FF, FF, FF, FF, FF, FF, FF, FE]</code> Clear error <code>[FF, FF, FF, FF, FF, FF, FF, FB]</code> <p>3. Register Operations</p> <p>Register operations use a unified format with arbitration ID <code>0x7FF</code>:</p> Operation Byte 2 Byte 3 Byte 4-7 Read <code>0x33</code> Register ID (<code>RID</code>) Don't care (<code>0x00</code>) Write <code>0x55</code> Register ID (<code>RID</code>) Register value (4 bytes) Store <code>0xAA</code> Register ID (<code>RID</code>, usually <code>0x00</code>) Don't care (<code>0x00</code>) <p>Common prefix: <code>Byte 0-1 = CAN ID</code> (low byte, high byte).</p> <p>4. Feedback Messages</p> <p>Motors continuously send 8-byte state frames with <code>arbitration_id = feedback_id</code> (MST_ID, register 7):</p> Bytes Meaning <code>0</code> Status (high 4 bits) + Motor ID (low 4 bits) <code>1-2</code> Position (16-bit mapped) <code>3-4</code> Velocity (12-bit mapped) <code>5</code> Torque (12-bit mapped, split across bytes 4/5) <code>6</code> MOSFET temperature (\u00b0C) <code>7</code> Rotor temperature (\u00b0C)","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#status-codes","title":"Status Codes","text":"Code Name Description <code>0x0</code> DISABLED Motor is disabled <code>0x1</code> ENABLED Motor is enabled and ready <code>0x8</code> OVER_VOLTAGE Over-voltage protection triggered (threshold: OV_Value reg 29) <code>0x9</code> UNDER_VOLTAGE Under-voltage protection triggered (threshold: UV_Value reg 0) <code>0xA</code> OVER_CURRENT Over-current protection triggered (threshold: OC_Value reg 3) <code>0xB</code> MOS_OVER_TEMP MOSFET over-temperature protection triggered (threshold: OT_Value reg 2) <code>0xC</code> ROTOR_OVER_TEMP Rotor over-temperature protection triggered (threshold: OT_Value reg 2) <code>0xD</code> LOST_COMM Communication timeout/loss detected (related: TIMEOUT reg 9) <code>0xE</code> OVERLOAD Motor overload detected <p>5. Register Reply Messages</p> <p>Register read replies use <code>arbitration_id = feedback_id</code> (MST_ID), 8-byte payload:</p> Bytes Meaning <code>0-2</code> CAN ID encoding <code>3</code> Register ID (<code>RID</code>) <code>4-7</code> Register value (4 bytes)","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#data-encoding","title":"Data Encoding","text":"<p>Position/Velocity/Torque Encoding</p> <p>Position, velocity, and torque values are encoded using a mapping function:</p> <pre><code>uint_value = (float_value - min) / (max - min) * (2^bits - 1)\n</code></pre> <p>Where: - <code>min</code> and <code>max</code> are motor-specific limits (from motor type presets; see PMAX / VMAX / TMAX defaults) - <code>bits</code> is the bit width (16 for position, 12 for velocity/torque)</p> <p>Decoding reverses this process:</p> <pre><code>float_value = min + (uint_value / (2^bits - 1)) * (max - min)\n</code></pre> <p>Stiffness/Damping Encoding</p> <p>Stiffness (kp) and damping (kd) use fixed ranges:</p> <ul> <li>Stiffness: 0-500 (12-bit encoding)</li> <li>Damping: 0-5 (12-bit encoding)</li> </ul>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#message-timing","title":"Message Timing","text":"<p>Command Frequency</p> <ul> <li>Recommended: 100-1000 Hz</li> <li>Minimum: ~10 Hz (for basic control)</li> <li>Maximum: Limited by CAN bus bandwidth</li> </ul> <p>Feedback Frequency</p> <ul> <li>Motors send feedback automatically</li> <li>Typical frequency: 100-1000 Hz (depends on motor firmware)</li> <li>Feedback is asynchronous (not tied to command timing)</li> </ul> <p>Register Operations</p> <ul> <li>Register reads/writes are request-reply operations</li> <li>Typical timeout: 100-500 ms</li> <li>Store operations may take longer (flash write)</li> </ul>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#multi-motor-communication","title":"Multi-Motor Communication","text":"<p>Multiple motors can share the same CAN bus:</p> <ol> <li>Each motor has a unique <code>motor_id</code> (ESC_ID, register 8)</li> <li>Each motor has a unique <code>feedback_id</code> (MST_ID, register 7)</li> <li>Commands are addressed to specific <code>motor_id</code></li> <li>Feedback is identified by <code>feedback_id</code></li> </ol> <p>Example: Three Motors</p> <pre><code>Motor 1: motor_id=0x01, feedback_id=0x11\nMotor 2: motor_id=0x02, feedback_id=0x12\nMotor 3: motor_id=0x03, feedback_id=0x13\n\n[MIT mode](motor-control-modes.md#mit-mode) commands:\n  Motor 1: arbitration_id = 0x001\n  Motor 2: arbitration_id = 0x002\n  Motor 3: arbitration_id = 0x003\n\nFeedback:\n  Motor 1: arbitration_id = 0x011\n  Motor 2: arbitration_id = 0x012\n  Motor 3: arbitration_id = 0x013\n</code></pre>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#error-handling","title":"Error Handling","text":"<p>Timeout Protection</p> <ul> <li>Register operations have timeout protection</li> <li>If no reply received within timeout, operation fails</li> <li>Motor has CAN timeout alarm (TIMEOUT register 9); motor disables if no commands are received</li> <li>Timeout-related status is reported as LOST_COMM (<code>0xD</code>)</li> </ul> <p>Error States</p> <ul> <li>Motor enters error state on various conditions (overcurrent, overtemperature, etc.)</li> <li>Error state is reported in feedback status byte</li> <li>Use clear error command to reset error state</li> </ul>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#protocol-limitations","title":"Protocol Limitations","text":"<ol> <li>Message size: Fixed 8 bytes (CAN limitation)</li> <li>Arbitration ID range: 0x000-0x7FF (11-bit standard CAN)</li> <li>Bitrate: Must match across all devices</li> <li>Real-time: No guaranteed delivery time (best-effort)</li> </ol>","tags":["concept","protocol","advanced"]},{"location":"concept/communication-protocol/#further-reading","title":"Further Reading","text":"<ul> <li>See Motor Control Modes for control mode details</li> <li>See CAN Bus Fundamentals for CAN bus basics</li> <li>For interactive understanding of control modes, use <code>damiao gui</code></li> <li>See API Reference for implementation details</li> </ul>","tags":["concept","protocol","advanced"]},{"location":"concept/motor-control-modes/","title":"Motor Control Modes","text":"<p>DaMiao motors support four different control modes, each optimized for different use cases.</p> <p>Quick links: MIT mode | POS_VEL mode | VEL mode | FORCE_POS mode</p> <p>Recommended learning path</p> <p>To better understand the control modes in practice, use <code>damiao gui</code> and switch between modes while observing live feedback and charts.</p>","tags":["concept","control-modes","reference"]},{"location":"concept/motor-control-modes/#overview","title":"Overview","text":"<p>Control modes determine how the motor interprets command messages. The control mode is set via register 10 (CTRL_MODE) and must match the command format being sent.</p> <p>API method: <code>DaMiaoMotor.ensure_control_mode()</code></p> <p>Mode parameters marked as \"Motor-specific\" use the mapping limits for the selected motor type. See PMAX / VMAX / TMAX defaults. These registers are writable, but changing them is generally not recommended.</p> <p>The <code>ensure_control_mode()</code> method automatically:</p> <ol> <li> <p>Reads the current mode from register 10</p> </li> <li> <p>Writes the new mode if different</p> </li> <li> <p>Verifies the write was successful</p> </li> </ol> <p>Low Level Torque Control (Current-based)</p> <p>All four modes eventually do the same low-level job: they run a current feedback loop inside the motor controller.</p> <p>In simple terms:</p> <ul> <li> <p>The selected mode (MIT/POS_VEL/VEL/FORCE_POS) decides what current the motor should produce.</p> </li> <li> <p>That target current is sent to a fast inner controller.</p> </li> <li> <p>The inner controller continuously compares target current vs measured current and corrects PWM voltage to reduce the error.</p> </li> <li> <p>\\(i_{q,\\mathrm{ref}}\\): the target for the torque-producing current.   Larger magnitude means stronger torque. Sign decides rotation direction.</p> </li> <li> <p>\\(i_{d,\\mathrm{ref}}\\): the target for the flux-axis current.   In these modes it is set to <code>0</code>, meaning \"do not add extra d-axis current.\"</p> </li> </ul> <p>Note</p> <p>The motor tracks the calculated \\(i_{q,\\mathrm{ref}}\\) to produce the desired torque, while keeping the d-axis current at \\(i_{d,\\mathrm{ref}} = 0\\).</p> Mode Easy interpretation of \\(i_{q,\\mathrm{ref}}\\) \\(i_{d,\\mathrm{ref}}\\) MIT Calculated from position/velocity error + feedforward torque, then converted to current <code>0</code> POS_VEL Position loop outputs a speed target, speed loop converts that speed error to current <code>0</code> VEL Speed loop directly converts velocity error to current <code>0</code> FORCE_POS Position loop and speed loop compute current, then it is clipped by current/force limit <code>0</code>","tags":["concept","control-modes","reference"]},{"location":"concept/motor-control-modes/#mit-mode","title":"MIT Mode (Impedance Control)","text":"<p>MIT mode (named after MIT's Cheetah robot) provides impedance control with position, velocity, stiffness, damping, and feedforward torque.</p> <p>API method: <code>DaMiaoMotor.send_cmd_mit()</code></p> Parameter Range Description <code>target_position</code> Motor-specific Desired position (radians) <code>target_velocity</code> Motor-specific Desired velocity (rad/s) <code>stiffness</code> (kp) 0-500 Position gain (stiffness) <code>damping</code> (kd) 0-5 Velocity gain (damping) <code>feedforward_torque</code> Motor-specific Feedforward torque (Nm) <p></p> \\[ T_{\\text{ref}} = K_p \\cdot (p_{\\text{des}} - \\theta_m) + K_d \\cdot (v_{\\text{des}} - \\dot{\\theta}_m) + \\tau_{ff} \\] \\[ i_{q,\\text{ref}} = \\frac{T_{\\text{ref}}}{K_T}, \\quad i_{d,\\text{ref}} = 0 \\] <p>where \\(K_T\\) comes from KT_Value (register 1).</p>","tags":["concept","control-modes","reference"]},{"location":"concept/motor-control-modes/#pos-vel-mode","title":"POS_VEL Mode (Position + Velocity-Limit)","text":"<p>POS_VEL mode provides position-velocity control with trapezoidal motion profiles. The motor moves toward the target position, limiting velocity to the specified maximum, with automatic acceleration and deceleration.</p> <p>API method: <code>DaMiaoMotor.send_cmd_pos_vel()</code></p> Parameter Range Description <code>target_position</code> Motor-specific Desired position (radians) <code>velocity_limit</code> Motor-specific Maximum velocity during motion (rad/s) <p></p> \\[ v_{\\text{des}} = \\text{clip}\\!\\left(K_{p,\\text{apr}} (p_{\\text{des}} - \\theta_m) + K_{i,\\text{apr}} \\int (p_{\\text{des}} - \\theta_m) \\, dt,\\; -v_{\\text{limit}},\\; v_{\\text{limit}}\\right) \\] <p>In the control-law diagram, <code>velocity_limit</code> directly sets the clip bounds \\(\\pm v_{\\text{limit}}\\).</p> \\[ i_{q,\\text{ref}} = K_{p,\\text{asr}} (v_{\\text{des}} - \\dot{\\theta}_m) + K_{i,\\text{asr}} \\int (v_{\\text{des}} - \\dot{\\theta}_m) \\, dt, \\quad i_{d,\\text{ref}} = 0 \\] <p>where \\(v_{\\text{limit}}\\) is the commanded <code>velocity_limit</code>, KP_APR (reg 27), KI_APR (reg 28) are position loop gains, and KP_ASR (reg 25), KI_ASR (reg 26) are speed loop gains.</p>","tags":["concept","control-modes","reference"]},{"location":"concept/motor-control-modes/#vel-mode","title":"VEL Mode (Velocity)","text":"<p>VEL mode provides pure velocity control. The motor maintains the commanded velocity. Positive values rotate in one direction, negative values in the opposite direction.</p> <p>API method: <code>DaMiaoMotor.send_cmd_vel()</code></p> Parameter Range Description <code>target_velocity</code> Motor-specific Desired velocity (rad/s) <p></p> \\[ i_{q,\\text{ref}} = K_{p,\\text{asr}} (v_{\\text{des}} - \\dot{\\theta}_m) + K_{i,\\text{asr}} \\int (v_{\\text{des}} - \\dot{\\theta}_m) \\, dt, \\quad i_{d,\\text{ref}} = 0 \\] <p>where KP_ASR (reg 25) and KI_ASR (reg 26) are speed loop gains.</p>","tags":["concept","control-modes","reference"]},{"location":"concept/motor-control-modes/#force-pos-mode","title":"FORCE_POS Mode (Force-Limited Position)","text":"<p>FORCE_POS mode (Force-Position Hybrid) provides position control with velocity and torque-limit-ratio constraints. The motor moves toward the target position while respecting these limits, providing safe position control with force limiting.</p> <p>API method: <code>DaMiaoMotor.send_cmd_force_pos()</code></p> Parameter Range Description <code>target_position</code> Motor-specific Desired position (radians) <code>velocity_limit</code> 0-100 rad/s Maximum velocity during motion <code>torque_limit_ratio</code> 0.0-1.0 Normalized torque-limit coefficient <p></p> \\[ v_{\\text{des}} = \\text{clip}\\!\\left(K_{p,\\text{apr}} (p_{\\text{des}} - \\theta_m) + K_{i,\\text{apr}} \\int (p_{\\text{des}} - \\theta_m) \\, dt,\\; -v_{\\text{limit}},\\; v_{\\text{limit}}\\right) \\] \\[ i_{q,\\text{ref}} = \\text{clip}\\!\\left(K_{p,\\text{asr}} (v_{\\text{des}} - \\dot{\\theta}_m) + K_{i,\\text{asr}} \\int (v_{\\text{des}} - \\dot{\\theta}_m) \\, dt,\\; -\\tau_{\\text{lim}},\\; \\tau_{\\text{lim}}\\right), \\quad i_{d,\\text{ref}} = 0 \\] <p>In FORCE_POS mode:</p> \\[ \\tau_{\\text{lim}} = \\text{torque_limit_ratio} \\cdot T_{\\max} \\] <p>Here \\(T_{\\max}\\) is the max torque for the selected motor type (for example, for <code>4340</code>, \\(T_{\\max}=28\\) Nm, so <code>torque_limit_ratio=0.5</code> gives \\(\\tau_{\\text{lim}}=14\\) Nm).</p> <p>Also, \\(v_{\\text{limit}}\\) is the commanded <code>velocity_limit</code>, KP_APR (reg 27), KI_APR (reg 28) are position loop gains, and KP_ASR (reg 25), KI_ASR (reg 26) are speed loop gains.</p>","tags":["concept","control-modes","reference"]},{"location":"concept/registers/","title":"Registers","text":"<p>This page documents all motor registers available in the DaMiao motor.</p>","tags":["concept","reference","registers"]},{"location":"concept/registers/#how-it-works","title":"How it works?","text":"<p>Register Persistence (RAM vs Flash)</p> <p>When you write a register, it is applied immediately, but by default it is a runtime value (RAM).</p> <ul> <li>RAM write: takes effect now, but is lost after power cycle.</li> <li>Flash write: survives power cycle.</li> </ul> <p>Python API (<code>damiao_motor/core/motor.py</code>)</p> <p>Use these methods on <code>DaMiaoMotor</code>:</p> <ul> <li><code>write_register(rid, value)</code> to write one register.</li> <li>Most <code>set_*</code> helper methods (for example <code>set_control_mode</code>, <code>set_speed_loop_kp</code>, <code>set_can_timeout</code>) internally call <code>write_register</code>.</li> <li><code>store_parameters()</code> to save current parameters to flash.</li> <li><code>set_can_baud_rate(...)</code> writes register <code>35</code> and then stores to flash automatically.</li> </ul> <pre><code># Write to register (RAM, immediate but NOT persistent)\nmotor.write_register(25, 20.0)  # KP_ASR\n\n# Persist current parameters to flash\nmotor.store_parameters()\n</code></pre> <p>Web GUI</p> <ul> <li>Editing a register in the Web GUI writes it at runtime first.</li> <li>Click <code>Store Parameters</code> to write current parameters to flash.</li> <li>In current implementation, changing register <code>7</code> (<code>MST_ID</code>) or <code>8</code> (<code>ESC_ID</code>) also triggers a flash store automatically.</li> </ul> <p></p> <p>CLI</p> <p>From current CLI implementation:</p> Command Register write Flash persistence <code>damiao set-motor-id</code> Writes register <code>8</code> (<code>ESC_ID</code>) Yes (calls <code>store_parameters()</code>) <code>damiao set-feedback-id</code> Writes register <code>7</code> (<code>MST_ID</code>) Yes (calls <code>store_parameters()</code>) <code>damiao set-can-timeout</code> Writes register <code>9</code> (<code>TIMEOUT</code>) Yes (calls <code>store_parameters()</code>) <p>Other CLI control commands (<code>send-cmd-*</code>, <code>set-zero-command</code>, <code>set-zero-position</code>) do not store parameters to flash.</p> <p>CAN Baud Rate Codes</p> <p>The <code>CAN_BAUD_RATE_CODES</code> dictionary maps baud rate codes to actual baud rates:</p> Code Baud Rate 0 125,000 (125K) 1 200,000 (200K) 2 250,000 (250K) 3 500,000 (500K) 4 1,000,000 (1M) <pre><code>from damiao_motor import CAN_BAUD_RATE_CODES\n\n# Access baud rate codes\nfor code, baud_rate in CAN_BAUD_RATE_CODES.items():\n    print(f\"Code {code}: {baud_rate} bps\")\n</code></pre> <p>Usage Examples</p> <pre><code>from damiao_motor import DaMiaoController\n\ncontroller = DaMiaoController(channel=\"can0\")\nmotor = controller.add_motor(motor_id=0x01, feedback_id=0x00, motor_type=\"4340\")\n\n# Read a specific register\nvalue = motor.get_register(0x00)  # Read UV_Value\n\n# Check if read was successful\nif value is not None:\n    print(f\"Value: {value}\")\n</code></pre> <pre><code># Write to a register (only RW registers can be written)\nmotor.write_register(7, 0x01)  # Set MST_ID to 1 (RAM)\n\n# Keep the change after power cycle\nmotor.store_parameters()\n</code></pre> <pre><code>from damiao_motor import REGISTER_TABLE\n\n# Access register information\nfor register_id, info in REGISTER_TABLE.items():\n    print(f\"Register {register_id:2d} (0x{register_id:02X}): \"\n          f\"{info.variable:12s} - {info.description} \"\n          f\"[{info.access}]\")\n</code></pre> <p>Safety Notes</p> <p>Register Safety</p> <ul> <li>Some registers affect motor behavior immediately</li> <li>Always verify register values before writing</li> <li>Read-only (RO) registers cannot be written</li> <li>Refer to motor firmware documentation for detailed register behavior</li> <li>Test register changes in a safe environment</li> </ul>","tags":["concept","reference","registers"]},{"location":"concept/registers/#register-table","title":"Register Table","text":"ID Variable Description Access Range Type 0 <code>UV_Value</code> Under-voltage protection value (see UNDER_VOLTAGE <code>0x9</code>) RW (10.0, 3.4E38] float 1 <code>KT_Value</code> Torque coefficient \\(K_T\\) used in MIT mode RW [0.0, 3.4E38] float 2 <code>OT_Value</code> Over-temperature protection value (see MOS/ROTOR over-temp) RW [80.0, 200) float 3 <code>OC_Value</code> Over-current protection value (see OVER_CURRENT <code>0xA</code>) RW (0.0, 1.0) float 4 <code>ACC</code> Acceleration RW (0.0, 3.4E38) float 5 <code>DEC</code> Deceleration RW [-3.4E38, 0.0) float 6 <code>MAX_SPD</code> Maximum speed RW (0.0, 3.4E38] float ID Variable Description Access Range Type 7 <code>MST_ID</code> Feedback ID RW [0, 0x7FF] uint32 8 <code>ESC_ID</code> Receive ID RW [0, 0x7FF] uint32 9 <code>TIMEOUT</code> Timeout alarm time (see LOST_COMM <code>0xD</code>) RW [0, 2^32-1] uint32 10 <code>CTRL_MODE</code> Control mode RW [1, 4] uint32 ID Variable Description Access Range Type 11 <code>Damp</code> Motor viscous damping coefficient RO / float 12 <code>Inertia</code> Motor moment of inertia RO / float 13 <code>hw_ver</code> Reserved RO / uint32 14 <code>sw_ver</code> Software version number RO / uint32 15 <code>SN</code> Reserved RO / uint32 16 <code>NPP</code> Motor pole pairs RO / uint32 17 <code>Rs</code> Motor phase resistance RO / float 18 <code>Ls</code> Motor phase inductance RO / float 19 <code>Flux</code> Motor flux linkage value RO / float 20 <code>Gr</code> Gear reduction ratio RO / float ID Variable Description Access Range Type 21 <code>PMAX</code> Position mapping range RW (0.0, 3.4E38] float 22 <code>VMAX</code> Speed mapping range RW (0.0, 3.4E38] float 23 <code>TMAX</code> Torque mapping range RW (0.0, 3.4E38] float <p>PMAX / VMAX / TMAX Defaults</p> <p>Registers <code>21</code> (<code>PMAX</code>), <code>22</code> (<code>VMAX</code>), and <code>23</code> (<code>TMAX</code>) are writable and can be changed with register writes (API/CLI/GUI).</p> <p>Recommended Practice</p> <p>These mapping limits should normally stay at their default motor-type values. The SDK uses motor-type presets in <code>damiao_motor/core/motor.py</code> (<code>MOTOR_TYPE_PRESETS</code>, built from <code>_MOTOR_LIMIT_PARAM</code>) for command encoding and feedback decoding. If motor register mapping limits are changed without keeping SDK limits consistent, command/feedback scaling can become inconsistent.</p> <p>Default values in code (<code>_MOTOR_LIMIT_PARAM</code>): </p> Motor type PMAX VMAX TMAX <code>3507</code> 12.566 50 5 <code>4310</code> 12.5 30 10 <code>4310P</code> 12.5 50 10 <code>4340</code> 12.5 10 28 <code>4340P</code> 12.5 10 28 <code>6006</code> 12.5 45 20 <code>8006</code> 12.5 45 40 <code>8009</code> 12.5 45 54 <code>10010L</code> 12.5 25 200 <code>10010</code> 12.5 20 200 <code>H3510</code> 12.5 280 1 <code>G6215</code> 12.5 45 10 <code>H6220</code> 12.5 45 10 <code>JH11</code> 12.5 10 12 <code>6248P</code> 12.566 20 120 ID Variable Description Access Range Type 24 <code>I_BW</code> Current loop control bandwidth RW [100.0, 10000.0] float 25 <code>KP_ASR</code> Speed loop Kp (used in POS_VEL, VEL, FORCE_POS) RW [0.0, 3.4E38] float 26 <code>KI_ASR</code> Speed loop Ki (used in POS_VEL, VEL, FORCE_POS) RW [0.0, 3.4E38] float 27 <code>KP_APR</code> Position loop Kp (used in POS_VEL, FORCE_POS) RW [0.0, 3.4E38] float 28 <code>KI_APR</code> Position loop Ki (used in POS_VEL, FORCE_POS) RW [0.0, 3.4E38] float ID Variable Description Access Range Type 29 <code>OV_Value</code> Overvoltage protection value (see OVER_VOLTAGE <code>0x8</code>) RW TBD float 30 <code>GREF</code> Gear torque efficiency RW (0.0, 1.0] float 31 <code>Deta</code> Speed loop damping coefficient RW [1.0, 30.0] float 32 <code>V_BW</code> Speed loop filter bandwidth RW (0.0, 500.0) float ID Variable Description Access Range Type 33 <code>IQ_c1</code> Current loop enhancement coefficient RW [100.0, 10000.0] float 34 <code>VL_c1</code> Speed loop enhancement coefficient RW (0.0, 10000.0] float ID Variable Description Access Range Type 35 <code>can_br</code> CAN baud rate code RW [0, 4] uint32 36 <code>sub_ver</code> Sub-version number RO / uint32 ID Variable Description Access Range Type 50 <code>u_off</code> U-phase offset RO - float 51 <code>v_off</code> V-phase offset RO - float 52 <code>k1</code> Compensation factor 1 RO - float 53 <code>k2</code> Compensation factor 2 RO - float 54 <code>m_off</code> Angle offset RO - float 55 <code>dir</code> Direction RO - float ID Variable Description Access Range Type 80 <code>p_m</code> Motor position RO - float 81 <code>xout</code> Output shaft position RO - float","tags":["concept","reference","registers"]},{"location":"hardware-setup/can-set-up/","title":"CAN Setup","text":"<p>This guide covers setting up the CAN interface for use with DaMiao motors.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#prerequisites","title":"Prerequisites","text":"<ul> <li>Linux operating system</li> <li>CAN interface hardware (USB-CAN adapter, CAN-capable board, etc.)</li> <li>SocketCAN drivers</li> </ul>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#basic-can-setup","title":"Basic CAN Setup","text":"","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#1-check-can-interface","title":"1. Check CAN Interface","text":"<p>List available network interfaces:</p> <pre><code>ip link show\n</code></pre> <p>Look for <code>can0</code>, <code>can1</code>, or similar interfaces.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#2-bring-up-can-interface","title":"2. Bring Up CAN Interface","text":"<pre><code>sudo ip link set can0 up type can bitrate 1000000\n</code></pre> <p>This sets up <code>can0</code> with a 1 Mbps bitrate.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#3-verify-interface","title":"3. Verify Interface","text":"<pre><code>ip link show can0\n</code></pre> <p>You should see the interface is <code>UP</code>.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#persistent-interface-name-fixed-device-name","title":"Persistent Interface Name (Fixed Device Name)","text":"<p>If you use multiple CAN adapters, Linux may swap <code>can0</code>/<code>can1</code> order across reboots. Use a udev rule to assign a fixed name to a specific adapter.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#1-find-a-unique-identifier","title":"1. Find a Unique Identifier","text":"<pre><code># Replace can0 with your current interface\nudevadm info -a -p /sys/class/net/can0 | grep -E \"ATTRS\\\\{serial\\\\}|ATTRS\\\\{idVendor\\\\}|ATTRS\\\\{idProduct\\\\}\"\n</code></pre> <p>Pick a stable value such as <code>ATTRS{serial}</code>.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#2-create-a-udev-rule","title":"2. Create a udev Rule","text":"<pre><code>sudo tee /etc/udev/rules.d/70-can-persistent.rules &gt;/dev/null &lt;&lt;'EOF'\nSUBSYSTEM==\"net\", ACTION==\"add\", KERNEL==\"can*\", ATTRS{serial}==\"YOUR_SERIAL_HERE\", NAME=\"can_damiao\"\nEOF\n</code></pre> <p>Notes:</p> <ul> <li>Replace <code>YOUR_SERIAL_HERE</code> with your adapter serial.</li> <li><code>can_damiao</code> is an example; interface names must be 15 characters or fewer.</li> </ul>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#3-reload-rules-and-reconnect-adapter","title":"3. Reload Rules and Reconnect Adapter","text":"<pre><code>sudo udevadm control --reload-rules\n</code></pre> <p>Then unplug/replug the adapter (or reboot).</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#4-use-the-fixed-name","title":"4. Use the Fixed Name","text":"<pre><code>sudo ip link set can_damiao up type can bitrate 1000000\ndamiao scan --channel can_damiao\n</code></pre>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#testing-can-interface","title":"Testing CAN Interface","text":"","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#using-candump","title":"Using candump","text":"<pre><code>sudo apt-get install can-utils\nsudo candump can0\n</code></pre> <p>This will show all CAN messages on the bus.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#using-damiao-scan","title":"Using damiao scan","text":"<pre><code>damiao scan --channel can0\n</code></pre>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#troubleshooting","title":"Troubleshooting","text":"","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#interface-not-found","title":"Interface Not Found","text":"<ul> <li>Check hardware connection</li> <li>Verify drivers are loaded: <code>lsmod | grep can</code></li> <li>Check dmesg for errors: <code>dmesg | grep can</code></li> </ul>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#permission-errors","title":"Permission Errors","text":"<p>You may need to run with <code>sudo</code> or add your user to a group with CAN access:</p> <pre><code>sudo usermod -a -G dialout $USER\n</code></pre> <p>Then log out and back in.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#bitrate-mismatch","title":"Bitrate Mismatch","text":"<p>Ensure the CAN bitrate matches your motor configuration. Check motor firmware settings.</p>","tags":["hardware","setup","can"]},{"location":"hardware-setup/can-set-up/#multiple-can-interfaces","title":"Multiple CAN Interfaces","text":"<p>If you have multiple CAN interfaces:</p> <pre><code>sudo ip link set can0 up type can bitrate 1000000\nsudo ip link set can1 up type can bitrate 1000000\n</code></pre> <p>Then specify the channel in your code:</p> <pre><code>controller = DaMiaoController(channel=\"can1\", bustype=\"socketcan\")\n</code></pre>","tags":["hardware","setup","can"]},{"location":"hardware-setup/motor-connection/","title":"Motor Connection","text":"<p>This guide covers the physical connection of DaMiao motors to your system.</p>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#overview","title":"Overview","text":"<p>DaMiao motors connect to your computer via CAN bus. This requires:</p> <ul> <li>CAN interface hardware (USB-CAN adapter, CAN-capable board, etc.)</li> <li>CAN bus wiring (CAN_H, CAN_L, GND)</li> <li>Termination resistors (120\u03a9 at both ends)</li> <li>Power supply for the motors</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#can-interface-options","title":"CAN Interface Options","text":"<ul> <li>CANable/CandleLight: Open-source USB-CAN adapter</li> <li>Raspberry Pi: With CAN HAT (e.g., Waveshare CAN HAT)</li> <li>Jetson: With CAN expansion boards</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#requirements","title":"Requirements","text":"<ul> <li>SocketCAN support: Must have Linux kernel driver</li> <li>1 Mbps capability: Should support 1 Mbps bitrate</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#wiring","title":"Wiring","text":"","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#can-bus-wiring","title":"CAN Bus Wiring","text":"<p>CAN bus uses two wires:</p> Wire Description CAN_H CAN High signal CAN_L CAN Low signal","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#connection-diagram","title":"Connection Diagram","text":"<pre><code>[Computer/CAN Interface]\n    |\n    | CAN_H \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    | CAN_L \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    |                      \u2502\n    |                  [Motor 1]\n    |                      \u2502\n    | CAN_H \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    | CAN_L \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    |                      \u2502\n    |                  [Motor 2]\n    |                      \u2502\n    | CAN_H \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    | CAN_L \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    |                      \u2502\n    |                  [Motor 3]\n    |                      \u2502\n    |                  120\u03a9 (Termination)\n</code></pre>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#termination-resistors","title":"Termination Resistors","text":"<p>Critical: Termination resistors (120\u03a9) must be installed at both ends of the bus.</p> <ul> <li>Location: First and last device on the bus</li> <li>Value: 120\u03a9 (standard CAN bus impedance)</li> <li>Type: Standard resistor, can be through-hole or SMD</li> <li>Connection: Between CAN_H and CAN_L</li> </ul> <p>Without termination resistors, signal reflections will cause communication errors.</p>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#power-supply","title":"Power Supply","text":"<p>Motors require a separate power supply:</p> <ul> <li>Voltage: Check motor specifications (typically 24V or 48V)</li> <li>Current: Must supply enough current for all motors</li> </ul> <p>Power Safety</p> <ul> <li>Ensure power supply matches motor voltage rating</li> <li>Use appropriate fuses/circuit breakers</li> <li>Verify polarity before connecting</li> <li>Keep power and signal grounds connected</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#motor-id-configuration","title":"Motor ID Configuration","text":"<p>Each motor on the bus must have a unique ID:</p> <ul> <li>ESC_ID (Register 8): Motor receive ID (for commands)</li> <li>MST_ID (Register 7): Motor feedback ID (for feedback messages)</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#default-ids","title":"Default IDs","text":"<p>Motors typically come with default IDs. Check motor documentation or use the scan command:</p> <pre><code># Motor type is optional (defaults to 4310)\ndamiao scan\n</code></pre>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#changing-motor-ids","title":"Changing Motor IDs","text":"<p>Use the CLI to change motor IDs:</p> <pre><code># Change receive ID (ESC_ID)\ndamiao set-motor-id --current 1 --target 2 --motor-type 4340\n\n# Change feedback ID (MST_ID)\ndamiao set-feedback-id --current 1 --target 3 --motor-type 4340\n</code></pre> <p>ID Selection</p> <ul> <li>Each motor on the same bus must have a unique ESC_ID and MST_ID</li> <li>Use sequential IDs for simplicity (0x01, 0x02, 0x03, ...)</li> <li>Lower ID number will have higher priority in physical layer.</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#power-considerations","title":"Power Considerations","text":"<ul> <li>Total current: Sum of all motor currents</li> <li>Voltage drop: Longer bus may have voltage drop</li> <li>Power distribution: Consider power distribution if motors are far apart</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#testing-connections","title":"Testing Connections","text":"<p>Use one of the following options to validate your setup.</p>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#option-1-gui-recommended","title":"Option 1: GUI (Recommended)","text":"<pre><code># Start the Web GUI\ndamiao gui\n</code></pre> <p>In the GUI, follow these steps:</p> <ol> <li>Connect and scan motors: Click Connect, then Scan Motors. See GUI Connection.</li> <li>Configure the motor: Select motor type, IDs, and relevant registers. See GUI Register Parameters.</li> <li>Test motor control: Select control mode and send test commands while monitoring feedback. See GUI Motor Control.</li> </ol>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#option-2-cli-if-strictly-headless","title":"Option 2: CLI (If strictly headless)","text":"","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#1-verify-can-interface","title":"1. Verify CAN Interface","text":"<pre><code># Check interface is up\nip link show can0\n\n# Should show: state UP\n</code></pre>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#2-scan-for-motors","title":"2. Scan for Motors","text":"<pre><code># Scan for connected motors (motor-type is optional)\ndamiao scan\n\n# Should detect all connected motors\n</code></pre>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#3-test-communication","title":"3. Test Communication","text":"<pre><code># Send zero command to verify communication\ndamiao set-zero-command --id 1 --motor-type 4340\n</code></pre>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#4-monitor-can-traffic","title":"4. Monitor CAN Traffic","text":"<pre><code># Install can-utils if needed\nsudo apt-get install can-utils\n\n# Monitor all CAN messages\ncandump can0\n</code></pre>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#troubleshooting","title":"Troubleshooting","text":"","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#no-motors-detected","title":"No Motors Detected","text":"<ul> <li>Check power: Verify motors are powered on</li> <li>Check wiring: Verify CAN_H, CAN_L, GND connections</li> <li>Check termination: Verify 120\u03a9 resistors are installed</li> <li>Check bitrate: Verify bitrate matches motor configuration</li> <li>Check IDs: Verify motor IDs are in scan range</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#intermittent-communication","title":"Intermittent Communication","text":"<ul> <li>Loose connections: Check all connections are secure</li> <li>Cable quality: Verify cable is suitable for CAN bus</li> <li>Bus length: Keep bus length reasonable (&lt; 40m for 1 Mbps)</li> <li>Termination: Verify termination resistors are correct</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#communication-errors","title":"Communication Errors","text":"<ul> <li>Bitrate mismatch: All devices must use same bitrate</li> <li>ID conflicts: Each motor must have unique IDs</li> <li>Bus errors: Check for physical layer issues</li> <li>Power issues: Verify power supply is adequate</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#motor-not-responding","title":"Motor Not Responding","text":"<ul> <li>Enable motor: Use <code>enable_all()</code> or enable command</li> <li>Check status: Read motor status from feedback</li> <li>Clear errors: Use clear error command if motor in error state</li> <li>Verify mode: Ensure control mode matches command type</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#safety-considerations","title":"Safety Considerations","text":"<p>Safety First</p> <ul> <li>Always ensure motors are securely mounted before powering on</li> <li>Keep clear of moving parts during testing</li> <li>Use low values initially to verify motor response</li> <li>Have emergency stop mechanism available</li> <li>Test in safe environment before production use</li> </ul>","tags":["hardware","setup","wiring"]},{"location":"hardware-setup/motor-connection/#further-reading","title":"Further Reading","text":"<ul> <li>CAN Setup - Software configuration</li> <li>Communication Protocol - Protocol details</li> <li>Motor Control Modes - Control mode information</li> <li>Web GUI - Recommended for understanding control modes interactively with <code>damiao gui</code></li> </ul>","tags":["hardware","setup","wiring"]},{"location":"package-usage/cli-tool/","title":"CLI Tool Reference","text":"<p>The <code>damiao</code> command-line tool provides a unified interface for scanning, configuring, and controlling DaMiao motors.</p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#getting-help","title":"Getting Help","text":"<p>To see all available commands:</p> <pre><code>damiao --help\n</code></pre> <p>To get help for a specific command:</p> <pre><code>damiao &lt;command&gt; --help\n</code></pre> <p>Understand modes faster</p> <p>To better understand control mode behavior, use <code>damiao gui</code> for interactive switching and live feedback, then use CLI commands for repeatable workflows.</p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#register-persistence-ram-vs-flash","title":"Register Persistence (RAM vs Flash)","text":"<p>Register writes are applied immediately at runtime. To keep them after power cycle, they must be stored to flash.</p> <p>Based on current CLI code behavior:</p> Command Register write Persistence behavior <code>damiao set-motor-id</code> Writes register <code>8</code> (<code>ESC_ID</code>) Also calls <code>store_parameters()</code> -&gt; persisted to flash <code>damiao set-feedback-id</code> Writes register <code>7</code> (<code>MST_ID</code>) Also calls <code>store_parameters()</code> -&gt; persisted to flash <code>damiao set-can-timeout</code> Writes register <code>9</code> (<code>TIMEOUT</code>) Also calls <code>store_parameters()</code> -&gt; persisted to flash <p>All other CLI commands are control/status operations and do not store register parameters to flash.</p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#commands","title":"Commands","text":"","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#scan","title":"scan","text":"<p>Scan for connected motors on the CAN bus.</p> <pre><code>damiao scan [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--ids</code> <code>ID [ID ...]</code> Motor IDs to test (e.g., <code>--ids 1 2 3</code>). If not specified, tests IDs 0x01-0x10. <code>--duration</code> <code>FLOAT</code> Duration to listen for responses in seconds (default: 0.5) <code>--debug</code> flag Print all raw CAN messages for debugging <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># Scan default ID range (0x01-0x10) - motor-type is optional\ndamiao scan\n\n# Scan specific motor IDs\ndamiao scan --ids 1 2 3\n\n# Scan with longer listen duration\ndamiao scan --duration 2.0\n\n# Scan with specific motor type (optional, defaults to 4310)\ndamiao scan --motor-type 4340\n\n# Scan with debug output\ndamiao scan --debug\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#send-cmd-mit","title":"send-cmd-mit","text":"<p>Send MIT mode command to motor. Loops continuously until Ctrl+C. See Motor Control Modes for control mode details.</p> <pre><code>damiao send-cmd-mit [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--id</code> <code>INT</code> Motor ID (required) <code>--position</code> <code>FLOAT</code> Desired position (radians) (required) <code>--velocity</code> <code>FLOAT</code> Desired velocity (rad/s) (required) <code>--stiffness</code> <code>FLOAT</code> Stiffness (kp), range 0\u2013500 (default: 0.0) <code>--damping</code> <code>FLOAT</code> Damping (kd), range 0\u20135 (default: 0.0) <code>--feedforward-torque</code> <code>FLOAT</code> Feedforward torque (default: 0.0) <code>--frequency</code> <code>FLOAT</code> Command frequency in Hz (default: 100.0) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># MIT mode with all parameters\ndamiao send-cmd-mit --id 1 --position 1.5 --velocity 0.0 --stiffness 3.0 --damping 0.5\n\n# With custom frequency\ndamiao send-cmd-mit --id 1 --position 1.5 --velocity 0.0 --stiffness 3.0 --damping 0.5 --frequency 50.0\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#send-cmd-pos-vel","title":"send-cmd-pos-vel","text":"<p>Send POS_VEL mode command to motor. Loops continuously until Ctrl+C. See Motor Control Modes for control mode details.</p> <pre><code>damiao send-cmd-pos-vel [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--id</code> <code>INT</code> Motor ID (required) <code>--position</code> <code>FLOAT</code> Desired position (radians) (required) <code>--velocity-limit</code> <code>FLOAT</code> Maximum velocity during motion (rad/s) (required) <code>--frequency</code> <code>FLOAT</code> Command frequency in Hz (default: 100.0) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># POS_VEL mode\ndamiao send-cmd-pos-vel --id 1 --position 1.5 --velocity-limit 2.0\n\n# With custom frequency\ndamiao send-cmd-pos-vel --id 1 --position 1.5 --velocity-limit 2.0 --frequency 50.0\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#send-cmd-vel","title":"send-cmd-vel","text":"<p>Send VEL mode command to motor. Loops continuously until Ctrl+C. See Motor Control Modes for control mode details.</p> <pre><code>damiao send-cmd-vel [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--id</code> <code>INT</code> Motor ID (required) <code>--velocity</code> <code>FLOAT</code> Desired velocity (rad/s) (required) <code>--frequency</code> <code>FLOAT</code> Command frequency in Hz (default: 100.0) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># VEL mode\ndamiao send-cmd-vel --id 1 --velocity 3.0\n\n# With custom frequency\ndamiao send-cmd-vel --id 1 --velocity 3.0 --frequency 50.0\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#send-cmd-force-pos","title":"send-cmd-force-pos","text":"<p>Send FORCE_POS mode command to motor. Loops continuously until Ctrl+C. See Motor Control Modes for control mode details.</p> <pre><code>damiao send-cmd-force-pos [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--id</code> <code>INT</code> Motor ID (required) <code>--position</code> <code>FLOAT</code> Desired position (radians) (required) <code>--velocity-limit</code> <code>FLOAT</code> Velocity limit (rad/s, 0-100) (required) <code>--torque-limit-ratio</code> <code>FLOAT</code> Normalized torque-limit coefficient (0.0-1.0), where <code>tau_lim = torque_limit_ratio * T_max(motor_type)</code> (required) <code>--frequency</code> <code>FLOAT</code> Command frequency in Hz (default: 100.0) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># FORCE_POS mode\ndamiao send-cmd-force-pos --id 1 --position 1.5 --velocity-limit 50.0 --torque-limit-ratio 0.8\n\n# With custom frequency\ndamiao send-cmd-force-pos --id 1 --position 1.5 --velocity-limit 50.0 --torque-limit-ratio 0.8 --frequency 50.0\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#set-zero-command","title":"set-zero-command","text":"<p>Send zero command to a motor (pos=0, vel=0, torq=0, kp=0, kd=0). Loops continuously until Ctrl+C.</p> <pre><code>damiao set-zero-command [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--id</code> <code>INT</code> Motor ID to send zero command to (required) <code>--frequency</code> <code>FLOAT</code> Command frequency in Hz (default: 100.0) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># Send zero command continuously\ndamiao set-zero-command --id 1\n\n# With custom frequency\ndamiao set-zero-command --id 1 --frequency 50.0\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#set-zero-position","title":"set-zero-position","text":"<p>Set the current output shaft position to zero.</p> <pre><code>damiao set-zero-position [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--id</code> <code>INT</code> Motor ID (required) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># Set current position to zero\ndamiao set-zero-position --id 1\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#set-can-timeout","title":"set-can-timeout","text":"<p>Set CAN timeout alarm time (register 9).</p> <pre><code>damiao set-can-timeout [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--id</code> <code>INT</code> Motor ID (required) <code>--timeout</code> <code>INT</code> Timeout in milliseconds (ms) (required) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># Set CAN timeout to 1000 ms\ndamiao set-can-timeout --id 1 --timeout 1000\n</code></pre></p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#set-motor-id","title":"set-motor-id","text":"<p>Change the motor's receive ID (ESC_ID, register 8). This is the ID used to send commands to the motor.</p> <pre><code>damiao set-motor-id [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--current</code> <code>INT</code> Current motor ID (to connect to the motor) (required) <code>--target</code> <code>INT</code> Target motor ID (new receive ID) (required) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># Change motor ID from 1 to 2\ndamiao set-motor-id --current 1 --target 2\n</code></pre></p> <p>Note</p> <p>After changing the motor ID, you will need to use the new ID to communicate with the motor.</p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#set-feedback-id","title":"set-feedback-id","text":"<p>Change the motor's feedback ID (MST_ID, register 7). This is the ID used to identify feedback messages from the motor.</p> <pre><code>damiao set-feedback-id [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--current</code> <code>INT</code> Current motor ID (to connect to the motor) (required) <code>--target</code> <code>INT</code> Target feedback ID (new MST_ID) (required) <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000) <p>Examples: <pre><code># Change feedback ID to 3 (using motor ID 1 to connect)\ndamiao set-feedback-id --current 1 --target 3\n</code></pre></p> <p>Note</p> <p>The motor will now respond with feedback using the new feedback ID.</p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#gui","title":"gui","text":"<p>Launch the web-based GUI for viewing and controlling DaMiao motors.</p> <pre><code>damiao gui [OPTIONS]\n</code></pre> <p>Options:</p> Option Type Description <code>--host</code> <code>STR</code> Host to bind to (default: 127.0.0.1) <code>--port</code> <code>INT</code> Port to bind to (default: 5000) <code>--debug</code> flag Enable debug mode <code>--production</code> flag Use production WSGI server (requires waitress) <p>Examples: <pre><code># Start GUI on default host and port (http://127.0.0.1:5000)\ndamiao gui\n\n# Start GUI on custom port\ndamiao gui --port 8080\n\n# Start GUI on all interfaces\ndamiao gui --host 0.0.0.0\n\n# Start GUI with production server\ndamiao gui --production\n</code></pre></p> <p>Backward Compatibility</p> <p>Use <code>damiao gui</code> to launch the GUI.</p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#global-options","title":"Global Options","text":"<p>All commands support the following global options:</p> Option Type Description <code>--channel</code> <code>STR</code> CAN channel (default: can0) <code>--bustype</code> <code>STR</code> CAN bus type (default: socketcan) <code>--bitrate</code> <code>INT</code> CAN bitrate in bits per second (default: 1000000). Only used when bringing up interface. <p>These options can be specified either before or after the subcommand:</p> <pre><code>damiao --channel can1 scan\ndamiao scan --channel can1\n</code></pre>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#real-time-feedback","title":"Real-time Feedback","text":"<p>All looping send commands (<code>send-cmd-mit</code>, <code>send-cmd-pos-vel</code>, <code>send-cmd-vel</code>, <code>send-cmd-force-pos</code>, <code>set-zero-command</code>) continuously print motor state information:</p> <pre><code>State: 1 (ENABLED) | Pos:   1.234 rad | Vel:   0.567 rad/s | Torq:   0.123 Nm | T_mos: 45.0\u00b0C | T_rotor: 50.0\u00b0C\n</code></pre> <p>The state information includes: - State: Status code and human-readable status name - Pos: Current position (radians) - Vel: Current velocity (rad/s) - Torq: Current torque (Nm) - T_mos: MOSFET temperature (\u00b0C) - T_rotor: Rotor temperature (\u00b0C)</p>","tags":["usage","cli","reference"]},{"location":"package-usage/cli-tool/#safety-notes","title":"Safety Notes","text":"<p>Safety First</p> <ul> <li>Always ensure motors are securely mounted before sending commands</li> <li>Start with zero commands or low values to verify motor response</li> <li>Monitor motor temperatures during operation</li> <li>Use Ctrl+C to stop looping commands immediately</li> <li>Test in a safe environment before production use</li> </ul>","tags":["usage","cli","reference"]},{"location":"package-usage/web-gui/","title":"Web GUI","text":"<p>The <code>damiao gui</code> command provides a web-based interface to connect to the CAN bus, scan for DaMiao motors, run commands, view and edit registers, and plot position, velocity, and torque in real time.</p> <p></p>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#installation","title":"Installation","text":"<p>Install the package; the <code>damiao</code> command will be available in your PATH:</p> <pre><code>pip install damiao-motor\n</code></pre>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#starting-the-gui","title":"Starting the GUI","text":"<pre><code>damiao gui\n</code></pre> <p>Open http://127.0.0.1:5000 in your browser.</p> <p>Recommended for control modes</p> <p>To better understand control modes, use <code>damiao gui</code> to switch between MIT/POS_VEL/VEL/FORCE_POS and observe parameter visibility and live charts.</p>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#command-options","title":"Command options","text":"Option Description <code>--host</code> Host (default: 127.0.0.1) <code>--port</code> Port (default: 5000) <code>--debug</code> Enable debug mode <code>--production</code> Use production server (requires <code>pip install waitress</code>) <p>Examples:</p> <pre><code>damiao gui --port 8080\ndamiao gui --host 0.0.0.0\ndamiao gui --production\n</code></pre>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#interface-layout","title":"Interface layout","text":"<p>The page is split into:</p> <ul> <li>Top bar: Connection (CAN channel, Connect, Disconnect).</li> <li>Left column: Motor Selection, Motor Control (Control Parameters + Motor Feedback), Register Parameters.</li> <li>Right column: Chart Visualizations (Position, Velocity, Torque).</li> </ul>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#connection","title":"Connection","text":"<ul> <li>CAN Channel: Choose an interface (e.g. can0, vcan0). A refresh button reloads the list.</li> <li>Connect: Connects to the selected channel.</li> <li>Disconnect: Disconnects and clears detected motors.</li> </ul> <p>A status log shows connection and scan progress (e.g. Connecting\u2026, Connected to CAN bus: can0, Scanning for motors\u2026, Found N motor(s), Registers loaded).</p> <p></p>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#motor-selection","title":"Motor Selection","text":"<ul> <li>Scan Motors: Scans for motors and lists those that respond.</li> <li>Motor dropdown: Select a motor\u2026 when none is chosen; otherwise Motor ID: 0xXX | Arb ID: 0xYY for each detected motor. Selecting a motor updates the Control panel, Register Parameters, and charts.</li> </ul>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#motor-control","title":"Motor Control","text":"<p>When a motor is selected, the left column shows Control Parameters and Motor Feedback.</p>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#control-parameters","title":"Control Parameters","text":"<ul> <li>Motor type: Choose the motor model (e.g. 4310, 4340, 6006, 8006, 8009, 10010/L, H3510, G6215, H6220, JH11, 6248P, 3507).</li> <li>Control Mode: MIT, POS_VEL, VEL, FORCE_POS. Row visibility depends on mode: Position, Velocity, Stiffness, Damping, Torque for MIT; Position + Velocity Limit for POS_VEL; Velocity for VEL; Vel Limit and Torque Limit Ratio for FORCE_POS.</li> <li>FORCE_POS Torque Limit Ratio meaning: <code>torque_limit_ratio</code> is normalized (0.0-1.0). The effective torque clip is <code>tau_lim = torque_limit_ratio * T_max(motor_type)</code>.</li> <li>Enable / Disable: Enable or disable the motor.</li> <li>Send Command: Applies the current control parameters. Single: once. Continuous: at the set Command Frequency (1\u20131000 Hz).</li> <li>Stop Command: Stops Continuous mode and disables the motor.</li> <li>Set Zero: Saves the current position as zero.</li> <li>Clear Error: Clears the motor error.</li> </ul>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#motor-feedback","title":"Motor Feedback","text":"<ul> <li>Status (e.g. ENABLED, DISABLED) and live Position, Velocity, Torque, MOS Temp, Rotor Temp for the selected motor.</li> </ul>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#register-parameters","title":"Register Parameters","text":"<ul> <li>Table: Description, Value, Type, Action. Read-only (RO) registers have no Edit. Writable (RW) registers: click Edit, change the value, then Save or Cancel.</li> <li>Special UIs: Feedback ID and Motor ID use hex input; Control mode and CAN baud rate use dropdowns. Changing Feedback ID or Motor ID triggers a rescan so the motor list stays correct.</li> </ul>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#chart-visualizations","title":"Chart Visualizations","text":"<p>Three line charts: Position (rad), Velocity (rad/s), Torque (Nm). Live data when a motor is selected (and when sending commands in Continuous mode).</p> <p>For each chart:</p> <ul> <li>Export Data: Save the visible data as CSV.</li> <li>Grid: Toggle grid on/off.</li> <li>Duration (s): Time window on the X-axis.</li> <li>Y Min / Y Max: Set Y-axis limits, or \"Auto\".</li> <li>Reset Limits: Restore Y-axis to the motor\u2019s limits or auto.</li> <li>Points: Toggle data points.</li> </ul> <p>Charts support zoom (scroll or pinch). Each chart shows live data over the set time window.</p> <p></p>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#export-chart-data","title":"Export Chart Data","text":"<p>Clicking Export Data on a chart opens a modal: enter a file name and Save to download a CSV of the chart\u2019s visible data. The file is saved to your default download folder.</p> <p></p>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#register-editing-details","title":"Register editing (details)","text":"<ul> <li>RO: Shown in gray; no Edit button.</li> <li>RW: Click Edit, change the value (or choose from the dropdown for Control mode and CAN baud rate), then Save or Cancel. Changing Feedback ID or Motor ID triggers a rescan so the motor list stays correct.</li> </ul>","tags":["usage","gui","web"]},{"location":"package-usage/web-gui/#safety-notes","title":"Safety notes","text":"<p>Safety First</p> <ul> <li>Verify CAN interface and motor wiring before Connect.</li> <li>Ensure the motor is securely mounted and the area is clear before Enable and Continuous commands.</li> <li>Always verify register values before writing; some changes take effect immediately.</li> <li>Changing Motor ID or Feedback ID changes how the motor is identified; the GUI rescans automatically.</li> <li>Test register and command changes in a safe environment before production use.</li> </ul>","tags":["usage","gui","web"]}]}