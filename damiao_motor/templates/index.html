<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DaMiao Motor Parameter Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 30px;
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #666;
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 30px;
        }
        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }
        .motor-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background: #0056b3;
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .btn-success:hover {
            background: #218838;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background: #c82333;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #5a6268;
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }
        .toast {
            padding: 12px 20px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 300px;
            max-width: 500px;
            pointer-events: auto;
            animation: slideInRight 0.3s ease-out, fadeOut 0.3s ease-in 2.7s;
            animation-fill-mode: both;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            font-weight: 500;
        }
        .toast.success {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid #28a745;
        }
        .toast.error {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid #dc3545;
        }
        .toast.info {
            background: #d1ecf1;
            color: #0c5460;
            border-left: 4px solid #17a2b8;
        }
        .toast-icon {
            font-size: 18px;
            flex-shrink: 0;
        }
        .toast-message {
            flex: 1;
        }
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(100%);
            }
        }
        .register-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .register-table th {
            background: #f8f9fa;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #495057;
            border-bottom: 2px solid #dee2e6;
            position: sticky;
            top: 0;
        }
        .register-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #e9ecef;
        }
        .register-table tr:hover {
            background: #f8f9fa;
        }
        .register-table tr.read-only {
            background: #f8f9fa;
            opacity: 0.8;
        }
        .value-cell {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .value-display {
            flex: 1;
        }
        .value-edit {
            display: none;
            flex: 1;
        }
        .value-edit input {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        .value-edit input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        .edit-btn, .save-btn, .cancel-btn {
            padding: 4px 12px;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .edit-btn {
            background: #ffc107;
            color: #000;
        }
        .edit-btn:hover {
            background: #e0a800;
        }
        .save-btn {
            background: #28a745;
            color: white;
        }
        .save-btn:hover {
            background: #218838;
        }
        .cancel-btn {
            background: #6c757d;
            color: white;
        }
        .cancel-btn:hover {
            background: #5a6268;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .config-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .config-section label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #495057;
        }
        .config-section input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .value-edit select {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        .value-edit select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        .motor-control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
        }
        .control-group h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
        }
        .control-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }
        .control-row label {
            min-width: 120px;
            font-weight: 500;
            color: #495057;
        }
        .control-row input[type="number"],
        .control-row select {
            flex: 1;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        .control-row input[type="number"]:focus,
        .control-row select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        .feedback-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .feedback-item {
            background: white;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        .feedback-item label {
            display: block;
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 5px;
        }
        .feedback-item .value {
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 600;
        }
        .status-badge.enabled {
            background: #d4edda;
            color: #155724;
        }
        .status-badge.disabled {
            background: #f8d7da;
            color: #721c24;
        }
        .status-badge.error {
            background: #fff3cd;
            color: #856404;
        }
        .motor-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        .auto-refresh-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }
        .auto-refresh-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .motor-actions-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
            align-items: center;
        }
        .motor-actions-row.full-width {
            width: 100%;
        }
        .toggle-switch-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 10px;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 24px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }
        .toggle-switch input:checked + .toggle-slider {
            background-color: #007bff;
        }
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        .toggle-label {
            font-size: 14px;
            font-weight: 500;
            color: #495057;
        }
        @media (max-width: 768px) {
            .motor-control-panel {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DaMiao Motor Parameter Editor</h1>
        <p class="subtitle">View and modify motor register parameters via CAN bus</p>
        
        <div class="toast-container" id="toastContainer"></div>
        
        <div class="section">
            <div class="section-title">Connection</div>
            <div class="config-section">
                <label for="can_channel">CAN Channel:</label>
                <input type="text" id="can_channel" value="can0" placeholder="can0">
                <button class="btn btn-primary" onclick="connect()">Connect</button>
                <button class="btn btn-secondary" onclick="disconnect()">Disconnect</button>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">Motor Selection</div>
            <div class="motor-selector">
                <button class="btn btn-primary" onclick="scanMotors()">Scan Motors</button>
                <button class="btn btn-success" onclick="refreshRegisters()" id="refreshBtn" disabled>Refresh Registers</button>
                <select id="motorSelect" onchange="loadMotorRegisters()" style="padding: 10px; border-radius: 5px; border: 1px solid #ced4da; min-width: 200px;" disabled>
                    <option value="">Select a motor...</option>
                </select>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">Motor Control</div>
            <div id="motorControlContainer">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Select a motor to control</p>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">Register Parameters</div>
            <div id="registerTableContainer">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Select a motor to view registers</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentMotorId = null;
        let originalValues = {};

        function showStatus(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            if (!container) {
                console.log(`[${type.toUpperCase()}] ${message}`);
                return;
            }

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            // Add icon based on type
            const icon = document.createElement('span');
            icon.className = 'toast-icon';
            if (type === 'success') {
                icon.textContent = '✓';
            } else if (type === 'error') {
                icon.textContent = '✕';
            } else {
                icon.textContent = 'ℹ';
            }
            
            const messageSpan = document.createElement('span');
            messageSpan.className = 'toast-message';
            messageSpan.textContent = message;
            
            toast.appendChild(icon);
            toast.appendChild(messageSpan);
            container.appendChild(toast);
            
            // Remove toast after animation completes (3 seconds total)
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 3000);
        }

        async function connect() {
            const channel = document.getElementById('can_channel').value;
            if (!channel) {
                showStatus('Please enter a CAN channel (e.g., can0)', 'error');
                return;
            }
            
            const connectBtn = event.target;
            const originalText = connectBtn.textContent;
            connectBtn.disabled = true;
            connectBtn.textContent = 'Connecting...';
            showStatus('Connecting to CAN bus...', 'info');
            
            try {
                const response = await fetch('/api/connect', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({channel: channel})
                });
                const data = await response.json();
                if (data.success) {
                    showStatus('Connected to CAN bus: ' + channel, 'success');
                } else {
                    showStatus('Connection failed: ' + data.error, 'error');
                }
            } catch (error) {
                console.error('Connect error:', error);
                showStatus('Error: ' + error.message, 'error');
            } finally {
                connectBtn.disabled = false;
                connectBtn.textContent = originalText;
            }
        }

        async function disconnect() {
            try {
                // Stop auto-refresh if running
                if (motorStateInterval) {
                    clearInterval(motorStateInterval);
                    motorStateInterval = null;
                }
                
                // Stop continuous mode if running
                stopContinuousMode();
                
                const response = await fetch('/api/disconnect', {method: 'POST'});
                const data = await response.json();
                if (data.success) {
                    showStatus('Disconnected', 'info');
                    document.getElementById('motorSelect').innerHTML = '<option value="">Select a motor...</option>';
                    document.getElementById('motorSelect').disabled = true;
                    document.getElementById('refreshBtn').disabled = true;
                    document.getElementById('registerTableContainer').innerHTML = 
                        '<div class="loading"><div class="spinner"></div><p>Select a motor to view registers</p></div>';
                    document.getElementById('motorControlContainer').innerHTML = 
                        '<div class="loading"><div class="spinner"></div><p>Select a motor to control</p></div>';
                    currentMotorId = null;
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            }
        }

        async function scanMotors(silent = false) {
            const scanBtn = event ? event.target : document.querySelector('button[onclick="scanMotors()"]');
            const originalText = scanBtn ? scanBtn.textContent : 'Scan Motors';
            if (scanBtn) {
                scanBtn.disabled = true;
                scanBtn.textContent = 'Scanning...';
            }
            if (!silent) {
                showStatus('Scanning for motors...', 'info');
            }
            
            try {
                const response = await fetch('/api/scan', {method: 'POST'});
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                const data = await response.json();
                console.log('Scan response:', data);
                
                if (data.success) {
                    const select = document.getElementById('motorSelect');
                    select.innerHTML = '<option value="">Select a motor...</option>';
                    if (data.motors && data.motors.length > 0) {
                        data.motors.forEach(motor => {
                            const option = document.createElement('option');
                            option.value = motor.id;
                            option.textContent = `Motor 0x${motor.id.toString(16).toUpperCase().padStart(2, '0')} (${motor.id}) - Arb ID: 0x${motor.arb_id.toString(16).toUpperCase().padStart(3, '0')}`;
                            select.appendChild(option);
                        });
                        select.disabled = false;
                        document.getElementById('refreshBtn').disabled = false;
                        
                        // Restore previous selection if motor still exists
                        if (currentMotorId) {
                            const motorExists = data.motors.some(m => m.id === currentMotorId);
                            if (motorExists) {
                                select.value = currentMotorId;
                            } else {
                                currentMotorId = null;
                            }
                        }
                        
                        if (!silent) {
                            showStatus(`Found ${data.motors.length} motor(s)`, 'success');
                        }
                    } else {
                        if (!silent) {
                            showStatus('No motors found. Make sure motors are connected, powered, and CAN bus is configured.', 'info');
                        }
                    }
                } else {
                    if (!silent) {
                        showStatus('Scan failed: ' + (data.error || 'Unknown error'), 'error');
                    }
                }
            } catch (error) {
                console.error('Scan error:', error);
                if (!silent) {
                    showStatus('Error: ' + error.message, 'error');
                }
            } finally {
                if (scanBtn) {
                    scanBtn.disabled = false;
                    scanBtn.textContent = originalText;
                }
            }
        }

        async function loadMotorRegisters() {
            const select = document.getElementById('motorSelect');
            const motorId = parseInt(select.value);
            if (!motorId) {
                // Stop continuous mode when motor is deselected
                stopContinuousMode();
                document.getElementById('registerTableContainer').innerHTML = 
                    '<div class="loading"><div class="spinner"></div><p>Select a motor to view registers</p></div>';
                document.getElementById('motorControlContainer').innerHTML = 
                    '<div class="loading"><div class="spinner"></div><p>Select a motor to control</p></div>';
                return;
            }
            
            // Stop continuous mode if switching motors
            if (currentMotorId !== motorId) {
                stopContinuousMode();
            }
            
            currentMotorId = motorId;
            showStatus('Loading registers...', 'info');
            
            try {
                const response = await fetch(`/api/motors/${motorId}/registers`);
                const data = await response.json();
                if (data.success) {
                    displayRegisters(data.registers);
                    originalValues = {...data.registers};
                    showStatus('Registers loaded', 'success');
                } else {
                    showStatus('Failed to load registers: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            }
            
            // Load motor control panel
            displayMotorControl();
            // Load initial motor state
            await updateMotorState();
        }

        function displayRegisters(registers) {
            const container = document.getElementById('registerTableContainer');
            let html = '<table class="register-table"><thead><tr>';
            html += '<th>RID</th><th>Variable</th><th>Description</th><th>Value</th><th>Type</th><th>Access</th><th>Action</th>';
            html += '</tr></thead><tbody>';
            
            const sortedRids = Object.keys(registers).map(Number).sort((a, b) => a - b);
            
            sortedRids.forEach(rid => {
                const value = registers[rid];
                const regInfo = window.registerTable[rid];
                if (!regInfo) return;
                
                const isReadOnly = regInfo.access === 'RO';
                
                // Special handling for hex registers (7, 8) and dropdowns (10, 35)
                let valueStr, inputHtml;
                
                if (rid === 35) {
                    // CAN baud rate dropdown
                    const baudRateOptions = [
                        {code: 0, label: '125K (0)'},
                        {code: 1, label: '200K (1)'},
                        {code: 2, label: '250K (2)'},
                        {code: 3, label: '500K (3)'},
                        {code: 4, label: '1M (4)'}
                    ];
                    const currentValue = typeof value === 'string' ? 0 : parseInt(value);
                    valueStr = baudRateOptions.find(opt => opt.code === currentValue)?.label || `Unknown (${currentValue})`;
                    
                    if (!isReadOnly) {
                        inputHtml = `<select id="input-${rid}">`;
                        baudRateOptions.forEach(opt => {
                            inputHtml += `<option value="${opt.code}" ${opt.code === currentValue ? 'selected' : ''}>${opt.label}</option>`;
                        });
                        inputHtml += `</select>`;
                    }
                } else if (rid === 10) {
                    // Control mode dropdown
                    const controlModeOptions = [
                        {code: 1, label: 'MIT (1)'},
                        {code: 2, label: 'POS_VEL (2)'},
                        {code: 3, label: 'VEL (3)'},
                        {code: 4, label: 'FORCE_POS (4)'}
                    ];
                    const currentValue = typeof value === 'string' ? 1 : parseInt(value);
                    valueStr = controlModeOptions.find(opt => opt.code === currentValue)?.label || `Unknown (${currentValue})`;
                    
                    if (!isReadOnly) {
                        inputHtml = `<select id="input-${rid}">`;
                        controlModeOptions.forEach(opt => {
                            inputHtml += `<option value="${opt.code}" ${opt.code === currentValue ? 'selected' : ''}>${opt.label}</option>`;
                        });
                        inputHtml += `</select>`;
                    }
                } else if (rid === 7 || rid === 8) {
                    // Hex display for MST_ID and ESC_ID
                    const numValue = typeof value === 'string' ? 0 : parseInt(value);
                    valueStr = `0x${numValue.toString(16).toUpperCase().padStart(3, '0')} (${numValue})`;
                    
                    if (!isReadOnly) {
                        inputHtml = `<input type="text" id="input-${rid}" value="0x${numValue.toString(16).toUpperCase().padStart(3, '0')}" placeholder="0x000" style="font-family: monospace;">`;
                    }
                } else {
                    // Regular numeric display
                    valueStr = typeof value === 'string' ? value : 
                        (regInfo.data_type === 'float' ? parseFloat(value).toFixed(6) : String(parseInt(value)));
                    
                    if (!isReadOnly) {
                        inputHtml = `<input type="number" step="${regInfo.data_type === 'float' ? '0.000001' : '1'}" id="input-${rid}" value="${valueStr}">`;
                    }
                }
                
                html += `<tr class="${isReadOnly ? 'read-only' : ''}">`;
                html += `<td>${rid}</td>`;
                html += `<td>${regInfo.variable}</td>`;
                html += `<td>${regInfo.description}</td>`;
                html += `<td class="value-cell">`;
                html += `<span class="value-display" id="value-${rid}">${valueStr}</span>`;
                if (!isReadOnly) {
                    html += `<span class="value-edit" id="edit-${rid}">`;
                    html += inputHtml;
                    html += `</span>`;
                }
                html += `</td>`;
                html += `<td>${regInfo.data_type}</td>`;
                html += `<td>${regInfo.access}</td>`;
                html += `<td>`;
                if (!isReadOnly) {
                    html += `<button class="edit-btn" onclick="editRegister(${rid})" id="edit-btn-${rid}">Edit</button>`;
                    html += `<button class="save-btn" onclick="saveRegister(${rid})" id="save-btn-${rid}" style="display:none;">Save</button>`;
                    html += `<button class="cancel-btn" onclick="cancelEdit(${rid})" id="cancel-btn-${rid}" style="display:none;">Cancel</button>`;
                } else {
                    html += `<span style="color: #999;">Read Only</span>`;
                }
                html += `</td>`;
                html += `</tr>`;
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function editRegister(rid) {
            document.getElementById(`value-${rid}`).style.display = 'none';
            document.getElementById(`edit-${rid}`).style.display = 'flex';
            document.getElementById(`edit-btn-${rid}`).style.display = 'none';
            document.getElementById(`save-btn-${rid}`).style.display = 'inline-block';
            document.getElementById(`cancel-btn-${rid}`).style.display = 'inline-block';
        }

        function cancelEdit(rid) {
            document.getElementById(`value-${rid}`).style.display = 'flex';
            document.getElementById(`edit-${rid}`).style.display = 'none';
            document.getElementById(`edit-btn-${rid}`).style.display = 'inline-block';
            document.getElementById(`save-btn-${rid}`).style.display = 'none';
            document.getElementById(`cancel-btn-${rid}`).style.display = 'none';
            
            // Restore original value with proper formatting
            const regInfo = window.registerTable[rid];
            const originalValue = originalValues[rid];
            const input = document.getElementById(`input-${rid}`);
            
            if (rid === 35 || rid === 10) {
                input.value = originalValue;
            } else if (rid === 7 || rid === 8) {
                const numValue = typeof originalValue === 'string' ? 0 : parseInt(originalValue);
                input.value = `0x${numValue.toString(16).toUpperCase().padStart(3, '0')}`;
            } else {
                input.value = originalValue;
            }
        }

        async function saveRegister(rid) {
            const input = document.getElementById(`input-${rid}`);
            const regInfo = window.registerTable[rid];
            let newValue;
            
            // Special handling for different input types
            if (rid === 35) {
                // Dropdown for CAN baud rate
                newValue = parseInt(input.value);
            } else if (rid === 10) {
                // Dropdown for control mode
                newValue = parseInt(input.value);
            } else if (rid === 7 || rid === 8) {
                // Hex input for MST_ID and ESC_ID
                const inputValue = input.value.trim();
                if (inputValue.startsWith('0x') || inputValue.startsWith('0X')) {
                    newValue = parseInt(inputValue, 16);
                } else {
                    newValue = parseInt(inputValue, 16); // Try hex first
                    if (isNaN(newValue)) {
                        newValue = parseInt(inputValue, 10); // Fall back to decimal
                    }
                }
            } else {
                // Regular numeric input
                newValue = regInfo.data_type === 'float' ? parseFloat(input.value) : parseInt(input.value);
            }
            
            if (isNaN(newValue)) {
                showStatus('Invalid value. Please enter a valid number.', 'error');
                return;
            }
            
            showStatus('Saving register...', 'info');
            
            try {
                const response = await fetch(`/api/motors/${currentMotorId}/registers/${rid}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({value: newValue})
                });
                
                // Check if response is OK before parsing JSON
                if (!response.ok) {
                    const errorText = await response.text();
                    let errorMsg = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorJson = JSON.parse(errorText);
                        errorMsg = errorJson.error || errorMsg;
                    } catch (e) {
                        errorMsg = errorText || errorMsg;
                    }
                    throw new Error(errorMsg);
                }
                
                const data = await response.json();
                if (data.success) {
                    cancelEdit(rid);
                    
                    // If we changed register 7 (feedback_id) or 8 (motor_id), update currentMotorId
                    if (data.updated_ids) {
                        if (data.updated_ids.motor_id !== undefined) {
                            // Motor ID changed, update our reference
                            const oldMotorId = currentMotorId;
                            currentMotorId = data.updated_ids.motor_id;
                            showStatus(`Register saved. Motor ID changed from ${oldMotorId} to ${currentMotorId}. Rescanning...`, 'info');
                        } else if (data.updated_ids.feedback_id !== undefined) {
                            showStatus(`Register saved. Feedback ID changed to ${data.updated_ids.feedback_id}. Rescanning...`, 'info');
                        }
                    } else {
                        showStatus('Register saved. Rescanning motors and reloading registers...', 'info');
                    }
                    
                    // Rescan motors to find motor with new IDs
                    await scanMotors(true);
                    
                    // Update motor selection if motor_id changed
                    if (data.updated_ids && data.updated_ids.motor_id !== undefined) {
                        const select = document.getElementById('motorSelect');
                        select.value = currentMotorId;
                    }
                    
                    // Reload registers for the current motor
                    if (currentMotorId) {
                        await loadMotorRegisters();
                    }
                    
                    showStatus('Register saved and data refreshed', 'success');
                } else {
                    showStatus('Failed to save: ' + (data.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                console.error('Save register error:', error);
                showStatus('Error: ' + error.message, 'error');
            }
        }

        async function refreshRegisters() {
            if (currentMotorId) {
                await loadMotorRegisters();
            }
        }

        // Motor control functions
        let motorStateInterval = null;
        let continuousCommandInterval = null;
        let continuousModeActive = false;
        let isProgrammaticallyChangingToggle = false;

        function displayMotorControl() {
            const container = document.getElementById('motorControlContainer');
            const motorId = currentMotorId;
            if (!motorId) {
                container.innerHTML = '<div class="loading"><div class="spinner"></div><p>Select a motor to control</p></div>';
                return;
            }

            const html = `
                <div class="motor-control-panel">
                    <div class="control-group">
                        <h3>Control Parameters</h3>
                        <div class="control-row">
                            <label>Control Mode:</label>
                            <select id="controlMode">
                                <option value="MIT">MIT (Position + Velocity + Torque)</option>
                                <option value="POS_VEL">POS_VEL (Position + Velocity)</option>
                                <option value="VEL">VEL (Velocity Only)</option>
                                <option value="FORCE_POS">FORCE_POS (Force Position)</option>
                            </select>
                        </div>
                        <div class="control-row" id="posRow">
                            <label>Position (rad):</label>
                            <input type="number" id="targetPosition" step="0.001" value="0.0">
                        </div>
                        <div class="control-row" id="velRow">
                            <label>Velocity (rad/s):</label>
                            <input type="number" id="targetVelocity" step="0.001" value="0.0">
                        </div>
                        <div class="control-row" id="stiffnessRow">
                            <label>Stiffness (Kp):</label>
                            <input type="number" id="stiffness" step="0.1" value="0.0">
                        </div>
                        <div class="control-row" id="dampingRow">
                            <label>Damping (Kd):</label>
                            <input type="number" id="damping" step="0.01" value="0.0">
                        </div>
                        <div class="control-row" id="torqueRow">
                            <label>Torque (Nm):</label>
                            <input type="number" id="feedforwardTorque" step="0.01" value="0.0">
                        </div>
                        <div class="control-row" id="velLimitRow" style="display:none;">
                            <label>Vel Limit (rad/s):</label>
                            <input type="number" id="velocityLimit" step="0.1" value="0.0" min="0" max="100">
                        </div>
                        <div class="control-row" id="curLimitRow" style="display:none;">
                            <label>Current Limit:</label>
                            <input type="number" id="currentLimit" step="0.01" value="0.0" min="0" max="1">
                        </div>
                        <div class="motor-actions-row">
                            <button class="btn btn-success" id="enableBtn" onclick="enableMotor()" style="display:none;">Enable</button>
                            <button class="btn btn-danger" id="disableBtn" onclick="disableMotor()" style="display:none;">Disable</button>
                        </div>
                        <div class="motor-actions-row">
                            <button class="btn btn-success" id="enableBtn" onclick="enableMotor()">Enable</button>
                            <button class="btn btn-danger" id="disableBtn" onclick="disableMotor()">Disable</button>
                        </div>
                        <div class="motor-actions-row">
                            <button class="btn btn-primary" id="sendCommandBtn" onclick="sendMotorCommand()">Send Command</button>
                            <div class="toggle-switch-container">
                                <span class="toggle-label">Single</span>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="commandModeToggle" onchange="updateCommandMode()">
                                    <span class="toggle-slider"></span>
                                </label>
                                <span class="toggle-label">Continuous</span>
                            </div>
                        </div>
                        <div class="control-row" id="frequencyRow" style="display: none;">
                            <label>Command Frequency (Hz):</label>
                            <input type="number" id="commandFrequency" step="1" value="50" min="1" max="1000" onchange="updateContinuousFrequency()">
                        </div>
                        <div id="continuousStatus" style="margin-top: 5px; margin-bottom: 10px; display: none; padding: 8px; background: #fff3cd; border-radius: 4px; color: #856404; font-size: 13px;">
                            <strong>Continuous Mode Active</strong> - Sending commands at <span id="currentFrequency">50</span>Hz
                        </div>
                        <div class="motor-actions-row">
                            <button class="btn btn-secondary" onclick="setZeroPosition()">Set Zero</button>
                            <button class="btn btn-secondary" onclick="clearMotorError()">Clear Error</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <h3>Motor Feedback</h3>
                        <div id="motorStatus" class="status-badge disabled">Status: Unknown</div>
                        <div class="feedback-display">
                            <div class="feedback-item">
                                <label>Position (rad)</label>
                                <div class="value" id="fbPosition">--</div>
                            </div>
                            <div class="feedback-item">
                                <label>Velocity (rad/s)</label>
                                <div class="value" id="fbVelocity">--</div>
                            </div>
                            <div class="feedback-item">
                                <label>Torque (Nm)</label>
                                <div class="value" id="fbTorque">--</div>
                            </div>
                            <div class="feedback-item">
                                <label>MOS Temp (°C)</label>
                                <div class="value" id="fbMosTemp">--</div>
                            </div>
                            <div class="feedback-item">
                                <label>Rotor Temp (°C)</label>
                                <div class="value" id="fbRotorTemp">--</div>
                            </div>
                            <div class="feedback-item">
                                <label>CAN ID</label>
                                <div class="value" id="fbCanId">--</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            container.innerHTML = html;

            // Update control visibility based on mode
            document.getElementById('controlMode').addEventListener('change', updateControlVisibility);
            updateControlVisibility();
            
            // Initialize frequency row visibility based on toggle state
            const toggle = document.getElementById('commandModeToggle');
            const frequencyRow = document.getElementById('frequencyRow');
            if (frequencyRow && toggle) {
                frequencyRow.style.display = toggle.checked ? 'flex' : 'none';
            }
        }

        function updateControlVisibility() {
            const mode = document.getElementById('controlMode').value;
            document.getElementById('posRow').style.display = mode === 'VEL' ? 'none' : 'flex';
            document.getElementById('velRow').style.display = 'flex';
            document.getElementById('stiffnessRow').style.display = mode === 'MIT' ? 'flex' : 'none';
            document.getElementById('dampingRow').style.display = mode === 'MIT' ? 'flex' : 'none';
            document.getElementById('torqueRow').style.display = mode === 'MIT' ? 'flex' : 'none';
            document.getElementById('velLimitRow').style.display = mode === 'FORCE_POS' ? 'flex' : 'none';
            document.getElementById('curLimitRow').style.display = mode === 'FORCE_POS' ? 'flex' : 'none';
        }

        async function sendMotorCommand() {
            if (!currentMotorId) {
                showStatus('Please select a motor first', 'error');
                return;
            }

            const toggle = document.getElementById('commandModeToggle');
            const isContinuous = toggle.checked;
            
            if (isContinuous) {
                // If continuous mode is selected, toggle it on/off
                if (continuousModeActive) {
                    // Stop continuous mode but preserve toggle state
                    stopContinuousMode(true);
                } else {
                    startContinuousMode();
                }
            } else {
                // Single mode - send once
                await sendMotorCommandInternal();
            }
        }

        function updateCommandMode() {
            // Ignore programmatic changes to the toggle
            if (isProgrammaticallyChangingToggle) {
                return;
            }
            
            const isContinuous = document.getElementById('commandModeToggle').checked;
            const frequencyRow = document.getElementById('frequencyRow');
            if (frequencyRow) {
                frequencyRow.style.display = isContinuous ? 'flex' : 'none';
            }
            
            // If switching to single mode, stop continuous if active
            if (!isContinuous && continuousModeActive) {
                stopContinuousMode();
            }
            // Don't auto-start continuous mode - user must press "Send Command" button
        }

        async function sendMotorCommandInternal() {
            if (!currentMotorId) {
                return;
            }

            // Check if motor is disabled - stop continuous mode if so
            try {
                const stateResponse = await fetch(`/api/motors/${currentMotorId}/state`);
                const stateData = await stateResponse.json();
                if (stateData.success && stateData.state) {
                    const statusCode = stateData.state.status_code;
                    // Status code 0 = DISABLED
                    if (statusCode === 0) {
                        if (continuousModeActive) {
                            stopContinuousMode(true); // preserveToggle = true
                            showStatus('Motor is disabled - stopped continuous mode', 'info');
                        }
                        return;
                    }
                }
            } catch (error) {
                // If we can't check state, continue anyway
                console.warn('Could not check motor state:', error);
            }

            const controlMode = document.getElementById('controlMode').value;
            const targetPosition = parseFloat(document.getElementById('targetPosition').value) || 0.0;
            const targetVelocity = parseFloat(document.getElementById('targetVelocity').value) || 0.0;
            const stiffness = parseFloat(document.getElementById('stiffness').value) || 0.0;
            const damping = parseFloat(document.getElementById('damping').value) || 0.0;
            const feedforwardTorque = parseFloat(document.getElementById('feedforwardTorque').value) || 0.0;
            const velocityLimit = parseFloat(document.getElementById('velocityLimit').value) || 0.0;
            const currentLimit = parseFloat(document.getElementById('currentLimit').value) || 0.0;

            try {
                const response = await fetch(`/api/motors/${currentMotorId}/command`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        control_mode: controlMode,
                        target_position: targetPosition,
                        target_velocity: targetVelocity,
                        stiffness: stiffness,
                        damping: damping,
                        feedforward_torque: feedforwardTorque,
                        velocity_limit: velocityLimit,
                        current_limit: currentLimit,
                    })
                });
                const data = await response.json();
                if (data.success) {
                    // Only show status for single sends, not continuous
                    if (!continuousModeActive) {
                        showStatus('Command sent successfully', 'success');
                    }
                } else {
                    showStatus('Failed to send command: ' + data.error, 'error');
                    stopContinuousMode();
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
                stopContinuousMode();
            }
        }

        function startContinuousMode() {
            if (!currentMotorId) {
                showStatus('Please select a motor first', 'error');
                // Uncheck toggle if motor not selected
                document.getElementById('commandModeToggle').checked = false;
                return;
            }

            continuousModeActive = true;
            const btn = document.getElementById('sendCommandBtn');
            btn.textContent = 'Stop Command';
            btn.classList.remove('btn-primary');
            btn.classList.add('btn-danger');
            
            // Get user-defined frequency
            const frequencyInput = document.getElementById('commandFrequency');
            const frequency = parseFloat(frequencyInput.value) || 50;
            const intervalMs = 1000 / frequency;
            
            // Update status message with current frequency
            const statusDiv = document.getElementById('continuousStatus');
            const currentFreqSpan = document.getElementById('currentFrequency');
            if (currentFreqSpan) {
                currentFreqSpan.textContent = frequency;
            }
            statusDiv.style.display = 'block';

            // Send commands at user-defined frequency
            continuousCommandInterval = setInterval(() => {
                sendMotorCommandInternal();
            }, intervalMs);

            // Automatically start auto-refresh feedback during continuous mode
            if (!motorStateInterval) {
                motorStateInterval = setInterval(updateMotorState, 100);
            }

            showStatus(`Continuous mode started (${frequency}Hz)`, 'info');
        }

        function stopContinuousMode(preserveToggle = false) {
            continuousModeActive = false;
            if (continuousCommandInterval) {
                clearInterval(continuousCommandInterval);
                continuousCommandInterval = null;
            }
            
            // Stop auto-refresh feedback when continuous mode stops
            if (motorStateInterval) {
                clearInterval(motorStateInterval);
                motorStateInterval = null;
            }
            
            const btn = document.getElementById('sendCommandBtn');
            if (btn) {
                btn.textContent = 'Send Command';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-primary');
            }
            
            const statusDiv = document.getElementById('continuousStatus');
            if (statusDiv) {
                statusDiv.style.display = 'none';
            }
            
            const toggle = document.getElementById('commandModeToggle');
            if (toggle) {
                // Only uncheck toggle if not preserving it (e.g., when user explicitly stops)
                if (!preserveToggle) {
                    isProgrammaticallyChangingToggle = true;
                    toggle.checked = false;
                    isProgrammaticallyChangingToggle = false;
                } else {
                    // Explicitly ensure toggle stays checked when preserving
                    isProgrammaticallyChangingToggle = true;
                    toggle.checked = true;
                    isProgrammaticallyChangingToggle = false;
                }
            }
        }

        function updateContinuousFrequency() {
            // Only update if continuous mode is active
            if (!continuousModeActive) {
                return;
            }
            
            const frequencyInput = document.getElementById('commandFrequency');
            let frequency = parseFloat(frequencyInput.value) || 50;
            
            // Validate frequency range
            if (frequency < 1) {
                frequency = 1;
                frequencyInput.value = 1;
            } else if (frequency > 1000) {
                frequency = 1000;
                frequencyInput.value = 1000;
            }
            
            const intervalMs = 1000 / frequency;
            
            // Update status message
            const currentFreqSpan = document.getElementById('currentFrequency');
            if (currentFreqSpan) {
                currentFreqSpan.textContent = frequency;
            }
            
            // Restart the interval with new frequency
            if (continuousCommandInterval) {
                clearInterval(continuousCommandInterval);
            }
            continuousCommandInterval = setInterval(() => {
                sendMotorCommandInternal();
            }, intervalMs);
            
            showStatus(`Command frequency updated to ${frequency}Hz`, 'info');
        }

        async function enableMotor() {
            if (!currentMotorId) {
                showStatus('Please select a motor first', 'error');
                return;
            }
            try {
                const response = await fetch(`/api/motors/${currentMotorId}/enable`, {method: 'POST'});
                const data = await response.json();
                if (data.success) {
                    showStatus('Motor enabled', 'success');
                    await updateMotorState();
                } else {
                    showStatus('Failed to enable motor: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            }
        }

        async function disableMotor() {
            if (!currentMotorId) {
                showStatus('Please select a motor first', 'error');
                return;
            }
            
            // Stop continuous mode when disabling motor, but preserve toggle state
            if (continuousModeActive) {
                stopContinuousMode(true); // preserveToggle = true
            }
            
            try {
                const response = await fetch(`/api/motors/${currentMotorId}/disable`, {method: 'POST'});
                const data = await response.json();
                if (data.success) {
                    showStatus('Motor disabled', 'success');
                    await updateMotorState();
                } else {
                    showStatus('Failed to disable motor: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            }
        }

        async function setZeroPosition() {
            if (!currentMotorId) {
                showStatus('Please select a motor first', 'error');
                return;
            }
            try {
                const response = await fetch(`/api/motors/${currentMotorId}/set-zero`, {method: 'POST'});
                const data = await response.json();
                if (data.success) {
                    showStatus('Zero position set', 'success');
                    await updateMotorState();
                } else {
                    showStatus('Failed to set zero: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            }
        }

        async function clearMotorError() {
            if (!currentMotorId) {
                showStatus('Please select a motor first', 'error');
                return;
            }
            try {
                const response = await fetch(`/api/motors/${currentMotorId}/clear-error`, {method: 'POST'});
                const data = await response.json();
                if (data.success) {
                    showStatus('Error cleared', 'success');
                    await updateMotorState();
                } else {
                    showStatus('Failed to clear error: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            }
        }

        async function updateMotorState() {
            if (!currentMotorId) {
                return;
            }
            try {
                const response = await fetch(`/api/motors/${currentMotorId}/state`);
                const data = await response.json();
                if (data.success && data.state) {
                    const state = data.state;
                    
                    // Update status badge
                    const statusBadge = document.getElementById('motorStatus');
                    const status = state.status || 'UNKNOWN';
                    const statusCode = state.status_code;
                    
                    statusBadge.textContent = `Status: ${status}`;
                    statusBadge.className = 'status-badge ';
                    if (statusCode === 1) {
                        statusBadge.className += 'enabled';
                    } else if (statusCode === 0) {
                        statusBadge.className += 'disabled';
                    } else {
                        statusBadge.className += 'error';
                    }
                    
                    // Update feedback values
                    document.getElementById('fbPosition').textContent = 
                        state.pos !== undefined ? state.pos.toFixed(4) : '--';
                    document.getElementById('fbVelocity').textContent = 
                        state.vel !== undefined ? state.vel.toFixed(4) : '--';
                    document.getElementById('fbTorque').textContent = 
                        state.torq !== undefined ? state.torq.toFixed(4) : '--';
                    document.getElementById('fbMosTemp').textContent = 
                        state.t_mos !== undefined ? state.t_mos.toFixed(1) : '--';
                    document.getElementById('fbRotorTemp').textContent = 
                        state.t_rotor !== undefined ? state.t_rotor.toFixed(1) : '--';
                    document.getElementById('fbCanId').textContent = 
                        state.can_id !== undefined ? `0x${state.can_id.toString(16).toUpperCase().padStart(2, '0')}` : '--';
                }
            } catch (error) {
                console.error('Error updating motor state:', error);
            }
        }

        // Load register table on page load
        window.addEventListener('DOMContentLoaded', async () => {
            try {
                const response = await fetch('/api/register-table');
                const data = await response.json();
                window.registerTable = {};
                data.registers.forEach(reg => {
                    window.registerTable[reg.rid] = reg;
                });
            } catch (error) {
                console.error('Failed to load register table:', error);
            }
        });
    </script>
</body>
</html>

