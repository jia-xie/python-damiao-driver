<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DaMiao Motor Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f5f5f5;
            padding: 10px;
            margin: 0;
            min-height: 100vh;
        }
        .container {
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px;
        }
        h1 {
            color: #333;
            margin-bottom: 5px;
            font-size: 24px;
        }
        .subtitle {
            color: #666;
            margin-bottom: 10px;
            font-size: 14px;
        }
        .section {
            margin-bottom: 15px;
        }
        .top-bar {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        .top-bar-section {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
        }
        .main-content {
            display: flex;
            gap: 0;
            margin-bottom: 15px;
            position: relative;
        }
        .main-content-left {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 400px;
            min-width: 250px;
            max-width: 70%;
            flex-shrink: 0;
            overflow-y: auto;
            padding-right: 15px;
        }
        .resizer {
            width: 5px;
            background: #dee2e6;
            cursor: col-resize;
            flex-shrink: 0;
            position: relative;
            user-select: none;
        }
        .resizer:hover {
            background: #007bff;
        }
        .resizer.active {
            background: #007bff;
        }
        .main-content-right {
            flex: 1;
            min-width: 300px;
            overflow-y: auto;
            padding-left: 15px;
        }
        @media (max-width: 1200px) {
            .main-content {
                flex-direction: column;
            }
            .main-content-left {
                width: 100%;
                max-width: 100%;
                padding-right: 0;
            }
            .resizer {
                display: none;
            }
            .main-content-right {
                padding-left: 0;
            }
        }
        .section-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid #e0e0e0;
        }
        .motor-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background: #0056b3;
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .btn-success:hover {
            background: #218838;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background: #c82333;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #5a6268;
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }
        .toast {
            padding: 12px 20px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 300px;
            max-width: 500px;
            pointer-events: auto;
            animation: slideInRight 0.3s ease-out, fadeOut 0.3s ease-in 2.7s;
            animation-fill-mode: both;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            font-weight: 500;
        }
        .toast.success {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid #28a745;
        }
        .toast.error {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid #dc3545;
        }
        .toast.info {
            background: #d1ecf1;
            color: #0c5460;
            border-left: 4px solid #17a2b8;
        }
        .toast-icon {
            font-size: 18px;
            flex-shrink: 0;
        }
        .toast-message {
            flex: 1;
        }
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(100%);
            }
        }
        .register-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        #registerTableContainer {
            max-height: 400px;
            overflow-y: auto;
        }
        .register-table th {
            background: #f8f9fa;
            padding: 8px;
            text-align: left;
            font-weight: 600;
            color: #495057;
            border-bottom: 2px solid #dee2e6;
            position: sticky;
            top: 0;
            font-size: 13px;
        }
        .register-table td {
            padding: 6px 8px;
            border-bottom: 1px solid #e9ecef;
            font-size: 13px;
        }
        .register-table tr:hover {
            background: #f8f9fa;
        }
        .register-table tr.read-only {
            background: #f8f9fa;
            opacity: 0.8;
        }
        .value-cell {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .value-display {
            flex: 1;
        }
        .value-edit {
            display: none;
            flex: 1;
        }
        .value-edit input {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        .value-edit input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        .edit-btn, .save-btn, .cancel-btn {
            padding: 4px 12px;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .edit-btn {
            background: #ffc107;
            color: #000;
        }
        .edit-btn:hover {
            background: #e0a800;
        }
        .save-btn {
            background: #28a745;
            color: white;
        }
        .save-btn:hover {
            background: #218838;
        }
        .cancel-btn {
            background: #6c757d;
            color: white;
        }
        .cancel-btn:hover {
            background: #5a6268;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .message {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .config-section {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        .config-section label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #495057;
        }
        .config-section input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .value-edit select {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        .value-edit select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        .motor-control-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .control-group {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 5px;
        }
        .control-group h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
        }
        .control-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }
        .control-row label {
            min-width: 120px;
            font-weight: 500;
            color: #495057;
        }
        .control-row input[type="number"],
        .control-row select {
            flex: 1;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        .control-row input[type="number"]:focus,
        .control-row select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        .feedback-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .feedback-item {
            background: white;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        .feedback-item label {
            display: block;
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 5px;
        }
        .feedback-item .value {
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 600;
        }
        .status-badge.enabled {
            background: #d4edda;
            color: #155724;
        }
        .status-badge.disabled {
            background: #f8d7da;
            color: #721c24;
        }
        .status-badge.error {
            background: #fff3cd;
            color: #856404;
        }
        .motor-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        .auto-refresh-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }
        .auto-refresh-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .motor-actions-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
            align-items: center;
        }
        .motor-actions-row.full-width {
            width: 100%;
        }
        .toggle-switch-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 10px;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 24px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }
        .toggle-switch input:checked + .toggle-slider {
            background-color: #007bff;
        }
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        .toggle-label {
            font-size: 14px;
            font-weight: 500;
            color: #495057;
        }
        @media (max-width: 768px) {
            .motor-control-panel {
                grid-template-columns: 1fr;
            }
        }
        .chart-container {
            margin-top: 15px;
            position: relative;
            height: 350px;
            width: 100%;
        }
        .chart-wrapper {
            margin-bottom: 15px;
            background: white;
            padding: 12px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }
        .charts-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }
        .chart-title {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .chart-reset-btn {
            padding: 4px 8px;
            font-size: 11px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-weight: 500;
        }
        .chart-reset-btn:hover {
            background: #5a6268;
        }
        .chart-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 12px;
        }
        .chart-control-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .chart-control-group label {
            font-size: 12px;
            color: #495057;
            font-weight: 500;
            margin: 0;
        }
        .chart-control-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        .chart-control-group select {
            padding: 4px 8px;
            font-size: 12px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            cursor: pointer;
        }
        .chart-control-group input[type="number"] {
            padding: 4px 6px;
            font-size: 12px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            width: 80px;
        }
        .chart-control-btn {
            padding: 4px 10px;
            font-size: 11px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-weight: 500;
        }
        .chart-control-btn:hover {
            background: #0056b3;
        }
        .chart-control-btn.secondary {
            background: #6c757d;
        }
        .chart-control-btn.secondary:hover {
            background: #5a6268;
        }
        .chart-export-btn {
            padding: 4px 10px;
            font-size: 11px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-weight: 500;
            margin-left: 10px;
        }
        .chart-export-btn:hover {
            background: #218838;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }
        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 400px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .modal-header {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
        }
        .modal-body {
            margin-bottom: 20px;
        }
        .modal-body label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #495057;
        }
        .modal-body input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        .modal-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }
        .modal-btn-primary {
            background: #007bff;
            color: white;
        }
        .modal-btn-primary:hover {
            background: #0056b3;
        }
        .modal-btn-secondary {
            background: #6c757d;
            color: white;
        }
        .modal-btn-secondary:hover {
            background: #5a6268;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>DaMiao Motor Control</h1>
        
        <div class="toast-container" id="toastContainer"></div>
        
        <div class="top-bar">
            <div class="top-bar-section">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px;">Connection</div>
                <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <label for="can_channel" style="font-size: 13px;">CAN Channel:</label>
                    <input type="text" id="can_channel" value="can0" placeholder="can0" style="padding: 6px; border: 1px solid #ced4da; border-radius: 4px; width: 100px;">
                    <button class="btn btn-primary" onclick="connect()">Connect</button>
                    <button class="btn btn-secondary" onclick="disconnect()">Disconnect</button>
                </div>
            </div>
            <div class="top-bar-section">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px;">Motor Selection</div>
                <div class="motor-selector" style="margin: 0;">
                    <button class="btn btn-primary" onclick="scanMotors()">Scan Motors</button>
                    <button class="btn btn-success" onclick="refreshRegisters()" id="refreshBtn" disabled>Refresh Registers</button>
                    <select id="motorSelect" onchange="loadMotorRegisters()" style="padding: 6px; border-radius: 5px; border: 1px solid #ced4da; min-width: 200px;" disabled>
                        <option value="">Select a motor...</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="main-content-left">
                <div class="section">
                    <div class="section-title">Motor Control</div>
                    <div id="motorControlContainer">
                        <div class="message">
                            <p>Connect to CAN device and select a motor</p>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-title">Register Parameters</div>
                    <div id="registerTableContainer">
                        <div class="message">
                            <p>Connect to CAN device and select a motor</p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="resizer" id="columnResizer"></div>
            <div class="main-content-right">
                <div class="section">
                    <div class="section-title">Chart Visualizations</div>
                    <div class="charts-container">
                        <div class="chart-wrapper">
                            <div class="chart-title">
                                <span>Position (rad)</span>
                                <button class="chart-export-btn" onclick="showExportModal('positionChart')">Export Data</button>
                            </div>
                            <div class="chart-container">
                                <canvas id="positionChart"></canvas>
                            </div>
                            <div class="chart-controls">
                                <div class="chart-control-group">
                                    <input type="checkbox" id="positionGridToggle" checked onchange="toggleChartGrid('positionChart', this.checked)">
                                    <label for="positionGridToggle">Grid</label>
                                </div>
                                <div class="chart-control-group">
                                    <label for="positionXDuration">Duration (s):</label>
                                    <input type="number" id="positionXDuration" step="any" value="10" min="1" onchange="setChartXDuration('positionChart', this.value)">
                                </div>
                                <div class="chart-control-group">
                                    <label for="positionYMin">Y Min:</label>
                                    <input type="number" id="positionYMin" step="any" placeholder="Auto" onchange="setChartAxisLimits('positionChart', 'y', this.value, document.getElementById('positionYMax').value)">
                                </div>
                                <div class="chart-control-group">
                                    <label for="positionYMax">Y Max:</label>
                                    <input type="number" id="positionYMax" step="any" placeholder="Auto" onchange="setChartAxisLimits('positionChart', 'y', document.getElementById('positionYMin').value, this.value)">
                                </div>
                                <button class="chart-control-btn" onclick="resetChartAxisLimits('positionChart')">Reset Limits</button>
                                <div class="chart-control-group">
                                    <input type="checkbox" id="positionPointsToggle" onchange="toggleChartPoints('positionChart', this.checked)">
                                    <label for="positionPointsToggle">Points</label>
                                </div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <div class="chart-title">
                                <span>Velocity (rad/s)</span>
                                <button class="chart-export-btn" onclick="showExportModal('velocityChart')">Export Data</button>
                            </div>
                            <div class="chart-container">
                                <canvas id="velocityChart"></canvas>
                            </div>
                            <div class="chart-controls">
                                <div class="chart-control-group">
                                    <input type="checkbox" id="velocityGridToggle" checked onchange="toggleChartGrid('velocityChart', this.checked)">
                                    <label for="velocityGridToggle">Grid</label>
                                </div>
                                <div class="chart-control-group">
                                    <label for="velocityXDuration">Duration (s):</label>
                                    <input type="number" id="velocityXDuration" step="any" value="10" min="1" onchange="setChartXDuration('velocityChart', this.value)">
                                </div>
                                <div class="chart-control-group">
                                    <label for="velocityYMin">Y Min:</label>
                                    <input type="number" id="velocityYMin" step="any" placeholder="Auto" onchange="setChartAxisLimits('velocityChart', 'y', this.value, document.getElementById('velocityYMax').value)">
                                </div>
                                <div class="chart-control-group">
                                    <label for="velocityYMax">Y Max:</label>
                                    <input type="number" id="velocityYMax" step="any" placeholder="Auto" onchange="setChartAxisLimits('velocityChart', 'y', document.getElementById('velocityYMin').value, this.value)">
                                </div>
                                <button class="chart-control-btn" onclick="resetChartAxisLimits('velocityChart')">Reset Limits</button>
                                <div class="chart-control-group">
                                    <input type="checkbox" id="velocityPointsToggle" onchange="toggleChartPoints('velocityChart', this.checked)">
                                    <label for="velocityPointsToggle">Points</label>
                                </div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <div class="chart-title">
                                <span>Torque (Nm)</span>
                                <button class="chart-export-btn" onclick="showExportModal('torqueChart')">Export Data</button>
                            </div>
                            <div class="chart-container">
                                <canvas id="torqueChart"></canvas>
                            </div>
                            <div class="chart-controls">
                                <div class="chart-control-group">
                                    <input type="checkbox" id="torqueGridToggle" checked onchange="toggleChartGrid('torqueChart', this.checked)">
                                    <label for="torqueGridToggle">Grid</label>
                                </div>
                                <div class="chart-control-group">
                                    <label for="torqueXDuration">Duration (s):</label>
                                    <input type="number" id="torqueXDuration" step="any" value="10" min="1" onchange="setChartXDuration('torqueChart', this.value)">
                                </div>
                                <div class="chart-control-group">
                                    <label for="torqueYMin">Y Min:</label>
                                    <input type="number" id="torqueYMin" step="any" placeholder="Auto" onchange="setChartAxisLimits('torqueChart', 'y', this.value, document.getElementById('torqueYMax').value)">
                                </div>
                                <div class="chart-control-group">
                                    <label for="torqueYMax">Y Max:</label>
                                    <input type="number" id="torqueYMax" step="any" placeholder="Auto" onchange="setChartAxisLimits('torqueChart', 'y', document.getElementById('torqueYMin').value, this.value)">
                                </div>
                                <button class="chart-control-btn" onclick="resetChartAxisLimits('torqueChart')">Reset Limits</button>
                                <div class="chart-control-group">
                                    <input type="checkbox" id="torquePointsToggle" onchange="toggleChartPoints('torqueChart', this.checked)">
                                    <label for="torquePointsToggle">Points</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Data Modal -->
    <div id="exportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Export Chart Data</div>
            <div class="modal-body">
                <label for="exportFileName">File Name:</label>
                <input type="text" id="exportFileName" placeholder="Enter file name (without extension)">
                <small id="exportHelpText" style="color: #6c757d; display: block; margin-top: 5px;">File will be saved as CSV format</small>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="closeExportModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="confirmExportData()">Save</button>
            </div>
        </div>
    </div>

    <script>
        let currentMotorId = null;
        let originalValues = {};

        function showStatus(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            if (!container) {
                console.log(`[${type.toUpperCase()}] ${message}`);
                return;
            }

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            // Add icon based on type
            const icon = document.createElement('span');
            icon.className = 'toast-icon';
            if (type === 'success') {
                icon.textContent = '✓';
            } else if (type === 'error') {
                icon.textContent = '✕';
            } else {
                icon.textContent = 'ℹ';
            }
            
            const messageSpan = document.createElement('span');
            messageSpan.className = 'toast-message';
            messageSpan.textContent = message;
            
            toast.appendChild(icon);
            toast.appendChild(messageSpan);
            container.appendChild(toast);
            
            // Remove toast after animation completes (3 seconds total)
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 3000);
        }

        async function connect() {
            const channel = document.getElementById('can_channel').value;
            if (!channel) {
                showStatus('Please enter a CAN channel (e.g., can0)', 'error');
                return;
            }
            
            const connectBtn = event.target;
            const originalText = connectBtn.textContent;
            connectBtn.disabled = true;
            connectBtn.textContent = 'Connecting...';
            showStatus('Connecting to CAN bus...', 'info');
            
            try {
                const response = await fetch('/api/connect', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({channel: channel})
                });
                const data = await response.json();
                if (data.success) {
                    showStatus('Connected to CAN bus: ' + channel, 'success');
                    await scanMotors();
                } else {
                    showStatus('Connection failed: ' + data.error, 'error');
                }
            } catch (error) {
                console.error('Connect error:', error);
                showStatus('Error: ' + error.message, 'error');
            } finally {
                connectBtn.disabled = false;
                connectBtn.textContent = originalText;
            }
        }

        async function disconnect() {
            try {
                // Stop auto-refresh if running
                if (motorStateInterval) {
                    clearInterval(motorStateInterval);
                    motorStateInterval = null;
                }
                
                // Stop continuous mode if running
                stopContinuousMode();
                
                // Destroy charts
                if (positionChart) {
                    positionChart.destroy();
                    positionChart = null;
                }
                if (velocityChart) {
                    velocityChart.destroy();
                    velocityChart = null;
                }
                if (torqueChart) {
                    torqueChart.destroy();
                    torqueChart = null;
                }
                
                const response = await fetch('/api/disconnect', {method: 'POST'});
                const data = await response.json();
                if (data.success) {
                    showStatus('Disconnected', 'info');
                    document.getElementById('motorSelect').innerHTML = '<option value="">Select a motor...</option>';
                    document.getElementById('motorSelect').disabled = true;
                    document.getElementById('refreshBtn').disabled = true;
                    document.getElementById('registerTableContainer').innerHTML = 
                        '<div class="message"><p>Connect to CAN device and select a motor</p></div>';
                    document.getElementById('motorControlContainer').innerHTML = 
                        '<div class="message"><p>Connect to CAN device and select a motor</p></div>';
                    currentMotorId = null;
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            }
        }

        async function scanMotors(silent = false) {
            const scanBtn = document.querySelector('button[onclick="scanMotors()"]');
            const originalText = scanBtn ? scanBtn.textContent : 'Scan Motors';
            if (scanBtn) {
                scanBtn.disabled = true;
                scanBtn.textContent = 'Scanning...';
            }
            if (!silent) {
                showStatus('Scanning for motors...', 'info');
            }
            
            try {
                const response = await fetch('/api/scan', {method: 'POST'});
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                const data = await response.json();
                console.log('Scan response:', data);
                
                if (data.success) {
                    const select = document.getElementById('motorSelect');
                    select.innerHTML = '<option value="">Select a motor...</option>';
                    if (data.motors && data.motors.length > 0) {
                        data.motors.forEach(motor => {
                            const option = document.createElement('option');
                            option.value = motor.id;
                            option.textContent = `Motor 0x${motor.id.toString(16).toUpperCase().padStart(2, '0')} (${motor.id}) - Arb ID: 0x${motor.arb_id.toString(16).toUpperCase().padStart(3, '0')}`;
                            select.appendChild(option);
                        });
                        select.disabled = false;
                        document.getElementById('refreshBtn').disabled = false;
                        
                        // Restore previous selection if motor still exists
                        if (currentMotorId) {
                            const motorExists = data.motors.some(m => m.id === currentMotorId);
                            if (motorExists) {
                                select.value = currentMotorId;
                            } else {
                                currentMotorId = null;
                            }
                        }
                        
                        // Auto-select first motor if no motor is currently selected
                        if (!select.value && data.motors.length > 0) {
                            select.value = data.motors[0].id;
                            select.dispatchEvent(new Event('change'));
                        }
                        
                        if (!silent) {
                            showStatus(`Found ${data.motors.length} motor(s)`, 'success');
                        }
                    } else {
                        if (!silent) {
                            showStatus('No motors found. Make sure motors are connected, powered, and CAN bus is configured.', 'info');
                        }
                    }
                } else {
                    if (!silent) {
                        showStatus('Scan failed: ' + (data.error || 'Unknown error'), 'error');
                    }
                }
            } catch (error) {
                console.error('Scan error:', error);
                if (!silent) {
                    showStatus('Error: ' + error.message, 'error');
                }
            } finally {
                if (scanBtn) {
                    scanBtn.disabled = false;
                    scanBtn.textContent = originalText;
                }
            }
        }

        async function loadMotorRegisters() {
            const select = document.getElementById('motorSelect');
            const motorId = parseInt(select.value);
            if (!motorId) {
                // Stop continuous mode when motor is deselected
                stopContinuousMode();
                document.getElementById('registerTableContainer').innerHTML = 
                    '<div class="message"><p>Connect to CAN device and select a motor</p></div>';
                document.getElementById('motorControlContainer').innerHTML = 
                    '<div class="message"><p>Connect to CAN device and select a motor</p></div>';
                return;
            }
            
            // Stop continuous mode if switching motors
            if (currentMotorId !== motorId) {
                stopContinuousMode();
            }
            
            currentMotorId = motorId;
            showStatus('Loading registers...', 'info');
            
            try {
                const response = await fetch(`/api/motors/${motorId}/registers`);
                const data = await response.json();
                if (data.success) {
                    displayRegisters(data.registers);
                    originalValues = {...data.registers};
                    
                    // Read PMAX (RID 21), VMAX (RID 22), TMAX (RID 23)
                    pmaxValue = data.registers[21] !== undefined ? parseFloat(data.registers[21]) : null;
                    vmaxValue = data.registers[22] !== undefined ? parseFloat(data.registers[22]) : null;
                    tmaxValue = data.registers[23] !== undefined ? parseFloat(data.registers[23]) : null;
                    
                    // Set Y-axis limits from register values
                    setChartYAxisLimitsFromRegisters();
                    
                    showStatus('Registers loaded', 'success');
                } else {
                    showStatus('Failed to load registers: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            }
            
            // Load motor control panel
            displayMotorControl();
            // Load initial motor state
            await updateMotorState();
        }

        function displayRegisters(registers) {
            const container = document.getElementById('registerTableContainer');
            let html = '<table class="register-table"><thead><tr>';
            html += '<th>Description</th><th>Value</th><th>Type</th><th>Action</th>';
            html += '</tr></thead><tbody>';
            
            const sortedRids = Object.keys(registers).map(Number).sort((a, b) => a - b);
            
            sortedRids.forEach(rid => {
                const value = registers[rid];
                const regInfo = window.registerTable[rid];
                if (!regInfo) return;
                
                const isReadOnly = regInfo.access === 'RO';
                
                // Special handling for hex registers (7, 8) and dropdowns (10, 35)
                let valueStr, inputHtml;
                
                if (rid === 35) {
                    // CAN baud rate dropdown
                    const baudRateOptions = [
                        {code: 0, label: '125K (0)'},
                        {code: 1, label: '200K (1)'},
                        {code: 2, label: '250K (2)'},
                        {code: 3, label: '500K (3)'},
                        {code: 4, label: '1M (4)'}
                    ];
                    const currentValue = typeof value === 'string' ? 0 : parseInt(value);
                    valueStr = baudRateOptions.find(opt => opt.code === currentValue)?.label || `Unknown (${currentValue})`;
                    
                    if (!isReadOnly) {
                        inputHtml = `<select id="input-${rid}">`;
                        baudRateOptions.forEach(opt => {
                            inputHtml += `<option value="${opt.code}" ${opt.code === currentValue ? 'selected' : ''}>${opt.label}</option>`;
                        });
                        inputHtml += `</select>`;
                    }
                } else if (rid === 10) {
                    // Control mode dropdown
                    const controlModeOptions = [
                        {code: 1, label: 'MIT (1)'},
                        {code: 2, label: 'POS_VEL (2)'},
                        {code: 3, label: 'VEL (3)'},
                        {code: 4, label: 'FORCE_POS (4)'}
                    ];
                    const currentValue = typeof value === 'string' ? 1 : parseInt(value);
                    valueStr = controlModeOptions.find(opt => opt.code === currentValue)?.label || `Unknown (${currentValue})`;
                    
                    if (!isReadOnly) {
                        inputHtml = `<select id="input-${rid}">`;
                        controlModeOptions.forEach(opt => {
                            inputHtml += `<option value="${opt.code}" ${opt.code === currentValue ? 'selected' : ''}>${opt.label}</option>`;
                        });
                        inputHtml += `</select>`;
                    }
                } else if (rid === 7 || rid === 8) {
                    // Hex display for MST_ID and ESC_ID
                    const numValue = typeof value === 'string' ? 0 : parseInt(value);
                    valueStr = `0x${numValue.toString(16).toUpperCase().padStart(3, '0')} (${numValue})`;
                    
                    if (!isReadOnly) {
                        inputHtml = `<input type="text" id="input-${rid}" value="0x${numValue.toString(16).toUpperCase().padStart(3, '0')}" placeholder="0x000" style="font-family: monospace;">`;
                    }
                } else {
                    // Regular numeric display
                    valueStr = typeof value === 'string' ? value : 
                        (regInfo.data_type === 'float' ? parseFloat(value).toFixed(6) : String(parseInt(value)));
                    
                    if (!isReadOnly) {
                        inputHtml = `<input type="number" step="${regInfo.data_type === 'float' ? '0.000001' : '1'}" id="input-${rid}" value="${valueStr}">`;
                    }
                }
                
                html += `<tr class="${isReadOnly ? 'read-only' : ''}">`;
                html += `<td>${regInfo.description}</td>`;
                html += `<td class="value-cell">`;
                html += `<span class="value-display" id="value-${rid}">${valueStr}</span>`;
                if (!isReadOnly) {
                    html += `<span class="value-edit" id="edit-${rid}">`;
                    html += inputHtml;
                    html += `</span>`;
                }
                html += `</td>`;
                html += `<td>${regInfo.data_type}</td>`;
                html += `<td>`;
                if (!isReadOnly) {
                    html += `<button class="edit-btn" onclick="editRegister(${rid})" id="edit-btn-${rid}">Edit</button>`;
                    html += `<button class="save-btn" onclick="saveRegister(${rid})" id="save-btn-${rid}" style="display:none;">Save</button>`;
                    html += `<button class="cancel-btn" onclick="cancelEdit(${rid})" id="cancel-btn-${rid}" style="display:none;">Cancel</button>`;
                } else {
                    html += `<span style="color: #999;">Read Only</span>`;
                }
                html += `</td>`;
                html += `</tr>`;
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function editRegister(rid) {
            document.getElementById(`value-${rid}`).style.display = 'none';
            document.getElementById(`edit-${rid}`).style.display = 'flex';
            document.getElementById(`edit-btn-${rid}`).style.display = 'none';
            document.getElementById(`save-btn-${rid}`).style.display = 'inline-block';
            document.getElementById(`cancel-btn-${rid}`).style.display = 'inline-block';
        }

        function cancelEdit(rid) {
            document.getElementById(`value-${rid}`).style.display = 'flex';
            document.getElementById(`edit-${rid}`).style.display = 'none';
            document.getElementById(`edit-btn-${rid}`).style.display = 'inline-block';
            document.getElementById(`save-btn-${rid}`).style.display = 'none';
            document.getElementById(`cancel-btn-${rid}`).style.display = 'none';
            
            // Restore original value with proper formatting
            const regInfo = window.registerTable[rid];
            const originalValue = originalValues[rid];
            const input = document.getElementById(`input-${rid}`);
            
            if (rid === 35 || rid === 10) {
                input.value = originalValue;
            } else if (rid === 7 || rid === 8) {
                const numValue = typeof originalValue === 'string' ? 0 : parseInt(originalValue);
                input.value = `0x${numValue.toString(16).toUpperCase().padStart(3, '0')}`;
            } else {
                input.value = originalValue;
            }
        }

        async function saveRegister(rid) {
            const input = document.getElementById(`input-${rid}`);
            const regInfo = window.registerTable[rid];
            let newValue;
            
            // Special handling for different input types
            if (rid === 35) {
                // Dropdown for CAN baud rate
                newValue = parseInt(input.value);
            } else if (rid === 10) {
                // Dropdown for control mode
                newValue = parseInt(input.value);
            } else if (rid === 7 || rid === 8) {
                // Hex input for MST_ID and ESC_ID
                const inputValue = input.value.trim();
                if (inputValue.startsWith('0x') || inputValue.startsWith('0X')) {
                    newValue = parseInt(inputValue, 16);
                } else {
                    newValue = parseInt(inputValue, 16); // Try hex first
                    if (isNaN(newValue)) {
                        newValue = parseInt(inputValue, 10); // Fall back to decimal
                    }
                }
            } else {
                // Regular numeric input
                newValue = regInfo.data_type === 'float' ? parseFloat(input.value) : parseInt(input.value);
            }
            
            if (isNaN(newValue)) {
                showStatus('Invalid value. Please enter a valid number.', 'error');
                return;
            }
            
            showStatus('Saving register...', 'info');
            
            try {
                const response = await fetch(`/api/motors/${currentMotorId}/registers/${rid}`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({value: newValue})
                });
                
                // Check if response is OK before parsing JSON
                if (!response.ok) {
                    const errorText = await response.text();
                    let errorMsg = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorJson = JSON.parse(errorText);
                        errorMsg = errorJson.error || errorMsg;
                    } catch (e) {
                        errorMsg = errorText || errorMsg;
                    }
                    throw new Error(errorMsg);
                }
                
                const data = await response.json();
                if (data.success) {
                    cancelEdit(rid);
                    
                    // If we changed register 7 (feedback_id) or 8 (motor_id), update currentMotorId
                    if (data.updated_ids) {
                        if (data.updated_ids.motor_id !== undefined) {
                            // Motor ID changed, update our reference
                            const oldMotorId = currentMotorId;
                            currentMotorId = data.updated_ids.motor_id;
                            showStatus(`Register saved. Motor ID changed from ${oldMotorId} to ${currentMotorId}. Rescanning...`, 'info');
                        } else if (data.updated_ids.feedback_id !== undefined) {
                            showStatus(`Register saved. Feedback ID changed to ${data.updated_ids.feedback_id}. Rescanning...`, 'info');
                        }
                    } else {
                        showStatus('Register saved. Rescanning motors and reloading registers...', 'info');
                    }
                    
                    // Rescan motors to find motor with new IDs
                    await scanMotors(true);
                    
                    // Update motor selection if motor_id changed
                    if (data.updated_ids && data.updated_ids.motor_id !== undefined) {
                        const select = document.getElementById('motorSelect');
                        select.value = currentMotorId;
                    }
                    
                    // Reload registers for the current motor
                    if (currentMotorId) {
                        await loadMotorRegisters();
                    }
                    
                    showStatus('Register saved and data refreshed', 'success');
                } else {
                    showStatus('Failed to save: ' + (data.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                console.error('Save register error:', error);
                showStatus('Error: ' + error.message, 'error');
            }
        }

        async function refreshRegisters() {
            if (currentMotorId) {
                await loadMotorRegisters();
            }
        }

        // Motor control functions
        let motorStateInterval = null;
        let continuousCommandInterval = null;
        let continuousModeActive = false;
        let isProgrammaticallyChangingToggle = false;
        let motorStateUpdateInFlight = false;
        let commandSendInFlight = false;
        
        // Chart instances
        let positionChart = null;
        let velocityChart = null;
        let torqueChart = null;
        
        // Chart data storage (keep last 100 data points)
        const maxDataPoints = 100;
        let chartTimeLabels = [];
        let positionData = [];
        let velocityData = [];
        let torqueData = [];
        let chartTimeCounter = 0;
        let chartStartTime = null;
        let chartUpdateInterval = 0.02; // Default 20ms (50Hz) in seconds
        let chartXDuration = 10; // Default 10 seconds window
        let lastChartRenderTime = 0;
        const chartMaxRenderHz = 100; // Frontend: only render charts at 100 Hz (state arrives at control freq from backend)
        let pmaxValue = null;
        let vmaxValue = null;
        let tmaxValue = null;
        let currentExportChartId = null;

        function displayMotorControl() {
            const container = document.getElementById('motorControlContainer');
            const motorId = currentMotorId;
            if (!motorId) {
                container.innerHTML = '<div class="message"><p>Connect to CAN device and select a motor</p></div>';
                return;
            }

            const html = `
                <div class="motor-control-panel">
                    <div class="control-group">
                        <h3>Control Parameters</h3>
                        <div class="control-row">
                            <label>Control Mode:</label>
                            <select id="controlMode">
                                <option value="MIT">MIT (Position + Velocity + Torque)</option>
                                <option value="POS_VEL">POS_VEL (Position + Velocity)</option>
                                <option value="VEL">VEL (Velocity Only)</option>
                                <option value="FORCE_POS">FORCE_POS (Force Position)</option>
                            </select>
                        </div>
                        <div class="control-row" id="posRow">
                            <label>Position (rad):</label>
                            <input type="number" id="targetPosition" step="0.001" value="0.0">
                        </div>
                        <div class="control-row" id="velRow">
                            <label>Velocity (rad/s):</label>
                            <input type="number" id="targetVelocity" step="0.001" value="0.0">
                        </div>
                        <div class="control-row" id="stiffnessRow">
                            <label>Stiffness (Kp):</label>
                            <input type="number" id="stiffness" step="0.1" value="0.0">
                        </div>
                        <div class="control-row" id="dampingRow">
                            <label>Damping (Kd):</label>
                            <input type="number" id="damping" step="0.01" value="0.0">
                        </div>
                        <div class="control-row" id="torqueRow">
                            <label>Torque (Nm):</label>
                            <input type="number" id="feedforwardTorque" step="0.01" value="0.0">
                        </div>
                        <div class="control-row" id="velLimitRow" style="display:none;">
                            <label>Vel Limit (rad/s):</label>
                            <input type="number" id="velocityLimit" step="0.1" value="0.0" min="0" max="100">
                        </div>
                        <div class="control-row" id="curLimitRow" style="display:none;">
                            <label>Current Limit:</label>
                            <input type="number" id="currentLimit" step="0.01" value="0.0" min="0" max="1">
                        </div>
                        <div class="motor-actions-row">
                            <button class="btn btn-success" id="enableBtn" onclick="enableMotor()" style="display:none;">Enable</button>
                            <button class="btn btn-danger" id="disableBtn" onclick="disableMotor()" style="display:none;">Disable</button>
                        </div>
                        <div class="motor-actions-row">
                            <button class="btn btn-success" id="enableBtn" onclick="enableMotor()">Enable</button>
                            <button class="btn btn-danger" id="disableBtn" onclick="disableMotor()">Disable</button>
                        </div>
                        <div class="motor-actions-row">
                            <button class="btn btn-primary" id="sendCommandBtn" onclick="sendMotorCommand()">Send Command</button>
                            <div class="toggle-switch-container">
                                <span class="toggle-label">Single</span>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="commandModeToggle" onchange="updateCommandMode()">
                                    <span class="toggle-slider"></span>
                                </label>
                                <span class="toggle-label">Continuous</span>
                            </div>
                        </div>
                        <div class="control-row" id="frequencyRow" style="display: none;">
                            <label>Command Frequency (Hz):</label>
                            <input type="number" id="commandFrequency" step="1" value="50" min="1" max="1000" onchange="updateContinuousFrequency()">
                        </div>
                        <div id="continuousStatus" style="margin-top: 5px; margin-bottom: 10px; display: none; padding: 8px; background: #fff3cd; border-radius: 4px; color: #856404; font-size: 13px;">
                            <strong>Continuous Mode Active</strong> - Sending commands at <span id="currentFrequency">50</span>Hz
                        </div>
                        <div class="motor-actions-row">
                            <button class="btn btn-secondary" onclick="setZeroPosition()">Set Zero</button>
                            <button class="btn btn-secondary" onclick="clearMotorError()">Clear Error</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <h3>Motor Feedback</h3>
                        <div id="motorStatus" class="status-badge disabled">Status: Unknown</div>
                        <div class="feedback-display">
                            <div class="feedback-item">
                                <label>Position (rad)</label>
                                <div class="value" id="fbPosition">--</div>
                            </div>
                            <div class="feedback-item">
                                <label>Velocity (rad/s)</label>
                                <div class="value" id="fbVelocity">--</div>
                            </div>
                            <div class="feedback-item">
                                <label>Torque (Nm)</label>
                                <div class="value" id="fbTorque">--</div>
                            </div>
                            <div class="feedback-item">
                                <label>MOS Temp (°C)</label>
                                <div class="value" id="fbMosTemp">--</div>
                            </div>
                            <div class="feedback-item">
                                <label>Rotor Temp (°C)</label>
                                <div class="value" id="fbRotorTemp">--</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            container.innerHTML = html;

            // Update control visibility based on mode
            document.getElementById('controlMode').addEventListener('change', updateControlVisibility);
            updateControlVisibility();
            
            // Initialize frequency row visibility based on toggle state
            const toggle = document.getElementById('commandModeToggle');
            const frequencyRow = document.getElementById('frequencyRow');
            if (frequencyRow && toggle) {
                frequencyRow.style.display = toggle.checked ? 'flex' : 'none';
            }
            
            // Initialize charts
            initializeCharts();
        }
        
        function initializeCharts() {
            // Reset chart data
            chartTimeLabels = [];
            positionData = [];
            velocityData = [];
            torqueData = [];
            chartTimeCounter = 0;
            chartStartTime = Date.now(); // Reset start time
            lastChartRenderTime = 0; // Ensure first updateCharts after init will render
            
            const chartConfig = {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '',
                        data: [],
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        pointBackgroundColor: 'rgb(75, 192, 192)',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(4);
                                }
                            }
                        },
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true,
                                    speed: 0.1
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x'
                            },
                            pan: {
                                enabled: true,
                                mode: 'x'
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: ''
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.1)',
                                drawBorder: true
                            },
                            ticks: {
                                display: true
                            }
                        },
                        x: {
                            display: true,
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (s)'
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.1)',
                                drawBorder: true
                            },
                            ticks: {
                                display: true,
                                callback: function(value, index, ticks) {
                                    // Format time: show seconds, or minutes:seconds if >= 60
                                    if (value >= 60) {
                                        const minutes = Math.floor(value / 60);
                                        const seconds = (value % 60).toFixed(1);
                                        return `${minutes}m ${seconds}s`;
                                    } else {
                                        return value.toFixed(1) + 's';
                                    }
                                }
                            }
                        }
                    },
                    animation: {
                        duration: 0
                    },
                    onHover: (event, activeElements) => {
                        event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'default';
                    }
                }
            };
            
            // Initialize position chart
            const positionCtx = document.getElementById('positionChart');
            if (positionCtx) {
                if (positionChart) {
                    positionChart.destroy();
                }
                const positionConfig = JSON.parse(JSON.stringify(chartConfig));
                positionConfig.options.scales.y.title.text = 'Position (rad)';
                positionChart = new Chart(positionCtx, {
                    ...positionConfig,
                    data: {
                        labels: chartTimeLabels,
                        datasets: [{
                            ...chartConfig.data.datasets[0],
                            label: 'Position',
                            borderColor: 'rgb(54, 162, 235)',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)'
                        }]
                    }
                });
            }
            
            // Initialize velocity chart
            const velocityCtx = document.getElementById('velocityChart');
            if (velocityCtx) {
                if (velocityChart) {
                    velocityChart.destroy();
                }
                const velocityConfig = JSON.parse(JSON.stringify(chartConfig));
                velocityConfig.options.scales.y.title.text = 'Velocity (rad/s)';
                velocityChart = new Chart(velocityCtx, {
                    ...velocityConfig,
                    data: {
                        labels: chartTimeLabels,
                        datasets: [{
                            ...chartConfig.data.datasets[0],
                            label: 'Velocity',
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)'
                        }]
                    }
                });
            }
            
            // Initialize torque chart
            const torqueCtx = document.getElementById('torqueChart');
            if (torqueCtx) {
                if (torqueChart) {
                    torqueChart.destroy();
                }
                const torqueConfig = JSON.parse(JSON.stringify(chartConfig));
                torqueConfig.options.scales.y.title.text = 'Torque (Nm)';
                torqueChart = new Chart(torqueCtx, {
                    ...torqueConfig,
                    data: {
                        labels: chartTimeLabels,
                        datasets: [{
                            ...chartConfig.data.datasets[0],
                            label: 'Torque',
                            borderColor: 'rgb(255, 206, 86)',
                            backgroundColor: 'rgba(255, 206, 86, 0.2)'
                        }]
                    }
                });
            }
            
            // Set Y-axis limits from register values
            setChartYAxisLimitsFromRegisters();
        }
        
        function setChartYAxisLimitsFromRegisters() {
            // Set Position chart Y-axis limits: -PMAX to +PMAX
            if (positionChart && pmaxValue !== null && !isNaN(pmaxValue)) {
                positionChart.options.scales.y.min = -pmaxValue;
                positionChart.options.scales.y.max = pmaxValue;
                positionChart.update();
            }
            
            // Set Velocity chart Y-axis limits: -VMAX to +VMAX
            if (velocityChart && vmaxValue !== null && !isNaN(vmaxValue)) {
                velocityChart.options.scales.y.min = -vmaxValue;
                velocityChart.options.scales.y.max = vmaxValue;
                velocityChart.update();
            }
            
            // Set Torque chart Y-axis limits: -TMAX to +TMAX
            if (torqueChart && tmaxValue !== null && !isNaN(tmaxValue)) {
                torqueChart.options.scales.y.min = -tmaxValue;
                torqueChart.options.scales.y.max = tmaxValue;
                torqueChart.update();
            }
        }
        
        function resetChartZoom(chartId) {
            let chart = null;
            if (chartId === 'positionChart') {
                chart = positionChart;
            } else if (chartId === 'velocityChart') {
                chart = velocityChart;
            } else if (chartId === 'torqueChart') {
                chart = torqueChart;
            }
            
            if (chart && chart.zoomScale) {
                chart.zoomScale('reset');
            } else if (chart) {
                // Fallback: reset scales manually
                chart.resetZoom();
            }
        }
        
        function getChartInstance(chartId) {
            if (chartId === 'positionChart') {
                return positionChart;
            } else if (chartId === 'velocityChart') {
                return velocityChart;
            } else if (chartId === 'torqueChart') {
                return torqueChart;
            }
            return null;
        }
        
        function toggleChartGrid(chartId, show) {
            const chart = getChartInstance(chartId);
            if (chart) {
                chart.options.scales.x.grid.display = show;
                chart.options.scales.y.grid.display = show;
                chart.update();
            }
        }
        
        function setChartAxisLimits(chartId, axis, min, max) {
            const chart = getChartInstance(chartId);
            if (!chart) return;
            
            const scale = axis === 'x' ? chart.options.scales.x : chart.options.scales.y;
            
            // Set min if provided
            if (min !== '' && min !== null && min !== undefined && !isNaN(parseFloat(min))) {
                scale.min = parseFloat(min);
            } else {
                scale.min = undefined; // Auto
            }
            
            // Set max if provided
            if (max !== '' && max !== null && max !== undefined && !isNaN(parseFloat(max))) {
                scale.max = parseFloat(max);
            } else {
                scale.max = undefined; // Auto
            }
            
            chart.update();
        }
        
        function setChartXDuration(chartId, duration) {
            const durationValue = parseFloat(duration);
            if (isNaN(durationValue) || durationValue < 1) {
                return;
            }
            
            // Duration will be applied in updateChartWithDuration
            // Just trigger an update by calling updateCharts if we have data
            if (chartTimeLabels.length > 0) {
                // Get the last state to trigger update
                const chart = getChartInstance(chartId);
                if (chart && chart.data.datasets[0].data.length > 0) {
                    // Re-apply duration filtering
                    const prefix = chartId.replace('Chart', '');
                    const allData = prefix === 'position' ? positionData : 
                                   prefix === 'velocity' ? velocityData : torqueData;
                    updateChartWithDuration(chartId, chart, chartTimeLabels, allData, prefix + 'XDuration');
                }
            }
        }
        
        function resetChartAxisLimits(chartId) {
            const chart = getChartInstance(chartId);
            if (!chart) return;
            
            // Reset Y-axis to register values
            const prefix = chartId.replace('Chart', '');
            if (prefix === 'position' && pmaxValue !== null && !isNaN(pmaxValue)) {
                chart.options.scales.y.min = -pmaxValue;
                chart.options.scales.y.max = pmaxValue;
            } else if (prefix === 'velocity' && vmaxValue !== null && !isNaN(vmaxValue)) {
                chart.options.scales.y.min = -vmaxValue;
                chart.options.scales.y.max = vmaxValue;
            } else if (prefix === 'torque' && tmaxValue !== null && !isNaN(tmaxValue)) {
                chart.options.scales.y.min = -tmaxValue;
                chart.options.scales.y.max = tmaxValue;
            } else {
                // Fallback to auto if register values not available
                chart.options.scales.y.min = undefined;
                chart.options.scales.y.max = undefined;
            }
            
            // Reset duration to default
            const durationInput = document.getElementById(prefix + 'XDuration');
            if (durationInput) {
                durationInput.value = chartXDuration;
            }
            
            // Clear Y-axis input fields
            const yMinInput = document.getElementById(prefix + 'YMin');
            const yMaxInput = document.getElementById(prefix + 'YMax');
            
            if (yMinInput) yMinInput.value = '';
            if (yMaxInput) yMaxInput.value = '';
            
            // X-axis limits will be set by updateChartWithDuration
            // Trigger update if we have data
            if (chartTimeLabels.length > 0) {
                const allData = prefix === 'position' ? positionData : 
                              prefix === 'velocity' ? velocityData : torqueData;
                updateChartWithDuration(chartId, chart, chartTimeLabels, allData, prefix + 'XDuration');
            } else {
                chart.update();
            }
        }
        
        function toggleChartPoints(chartId, show) {
            const chart = getChartInstance(chartId);
            if (chart) {
                chart.data.datasets[0].pointRadius = show ? 3 : 0;
                chart.data.datasets[0].pointHoverRadius = show ? 5 : 0;
                chart.update();
            }
        }
        
        function showExportModal(chartId) {
            currentExportChartId = chartId;
            const modal = document.getElementById('exportModal');
            const fileNameInput = document.getElementById('exportFileName');
            const helpText = document.getElementById('exportHelpText');
            
            // Generate default filename with motor ID and date/time
            const chartName = chartId.replace('Chart', '');
            const motorId = currentMotorId ? `motor${currentMotorId}_` : '';
            const now = new Date();
            const dateStr = now.getFullYear() + 
                          String(now.getMonth() + 1).padStart(2, '0') + 
                          String(now.getDate()).padStart(2, '0');
            const timeStr = String(now.getHours()).padStart(2, '0') + 
                          String(now.getMinutes()).padStart(2, '0') + 
                          String(now.getSeconds()).padStart(2, '0');
            const dateTimeStr = `${dateStr}_${timeStr}`;
            
            fileNameInput.value = `${motorId}${chartName}_${dateTimeStr}`;
            
            // Simple message - file will download to default folder
            helpText.textContent = 'File will be saved as CSV format to your default download folder.';
            
            modal.style.display = 'block';
            fileNameInput.focus();
            fileNameInput.select();
        }
        
        function closeExportModal() {
            const modal = document.getElementById('exportModal');
            modal.style.display = 'none';
            currentExportChartId = null;
        }
        
        async function confirmExportData() {
            if (!currentExportChartId) return;
            
            const chart = getChartInstance(currentExportChartId);
            if (!chart) {
                closeExportModal();
                return;
            }
            
            const fileNameInput = document.getElementById('exportFileName');
            let fileName = fileNameInput.value.trim();
            
            // Use default if empty (with motor ID and date/time)
            if (!fileName) {
                const chartName = currentExportChartId.replace('Chart', '');
                const motorId = currentMotorId ? `motor${currentMotorId}_` : '';
                const now = new Date();
                const dateStr = now.getFullYear() + 
                              String(now.getMonth() + 1).padStart(2, '0') + 
                              String(now.getDate()).padStart(2, '0');
                const timeStr = String(now.getHours()).padStart(2, '0') + 
                              String(now.getMinutes()).padStart(2, '0') + 
                              String(now.getSeconds()).padStart(2, '0');
                const dateTimeStr = `${dateStr}_${timeStr}`;
                fileName = `${motorId}${chartName}_${dateTimeStr}`;
            }
            
            // Sanitize filename - remove invalid characters
            fileName = fileName.replace(/[<>:"/\\|?*]/g, '_');
            
            // Ensure .csv extension
            if (!fileName.endsWith('.csv')) {
                fileName += '.csv';
            }
            
            // Get data from chart (using {x, y} format)
            const dataPoints = chart.data.datasets[0].data;
            const datasetLabel = chart.data.datasets[0].label || 'Data';
            
            // Create CSV content
            let csvContent = `Time (s),${datasetLabel}\n`;
            for (let i = 0; i < dataPoints.length; i++) {
                const point = dataPoints[i];
                if (point && point.x !== null && point.x !== undefined && point.y !== null && point.y !== undefined) {
                    csvContent += `${point.x},${point.y}\n`;
                }
            }
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            
            // Try to use File System Access API if available (allows choosing save location)
            // Firefox 112+ supports this, but requires secure context (HTTPS or localhost)
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: fileName,
                        types: [{
                            description: 'CSV files',
                            accept: { 'text/csv': ['.csv'] }
                        }],
                        excludeAcceptAllOption: false
                    });
                    
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    
                    showStatus(`Exported ${currentExportChartId} data to ${fileName}`, 'success');
                    closeExportModal();
                    return;
                } catch (error) {
                    // User cancelled - don't show error, just fall back silently
                    if (error.name === 'AbortError') {
                        closeExportModal();
                        return;
                    }
                    // Other errors - log and fall back to download
                    console.warn('File System Access API error, falling back to download:', error);
                }
            }
            
            // Fallback: use download link
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', fileName);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showStatus(`Exported ${currentExportChartId} data to ${fileName}`, 'success');
            closeExportModal();
        }
        
        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('exportModal');
            if (event.target === modal) {
                closeExportModal();
            }
        }
        
        function updateCharts(state) {
            // Calculate time in seconds since start
            let timeInSeconds = 0;
            if (chartStartTime !== null) {
                timeInSeconds = (Date.now() - chartStartTime) / 1000;
            } else {
                // Fallback: use counter if start time not set
                chartTimeCounter++;
                timeInSeconds = chartTimeCounter * chartUpdateInterval;
            }
            
            // Store numeric time value (Chart.js will format it using the tick callback)
            chartTimeLabels.push(timeInSeconds);
            
            // Add data values
            positionData.push(state.pos !== undefined ? state.pos : null);
            velocityData.push(state.vel !== undefined ? state.vel : null);
            torqueData.push(state.torq !== undefined ? state.torq : null);
            
            // Calculate max points needed based on max duration (assume max 60 seconds) and update frequency
            // Add some buffer (2x) to ensure we have enough data
            const maxDuration = 60; // seconds
            const pointsPerSecond = 1 / chartUpdateInterval;
            const requiredPoints = Math.ceil(maxDuration * pointsPerSecond * 2);
            
            // Keep enough data points to cover the maximum possible duration window
            if (chartTimeLabels.length > requiredPoints) {
                chartTimeLabels.shift();
                positionData.shift();
                velocityData.shift();
                torqueData.shift();
            }
            
            // Throttle chart re-renders to avoid main-thread saturation (fixes plot freezing after ~10s)
            const now = Date.now();
            const minRenderIntervalMs = 1000 / chartMaxRenderHz;
            if (now - lastChartRenderTime >= minRenderIntervalMs) {
                lastChartRenderTime = now;
                updateChartWithDuration('positionChart', positionChart, chartTimeLabels, positionData, 'positionXDuration');
                updateChartWithDuration('velocityChart', velocityChart, chartTimeLabels, velocityData, 'velocityXDuration');
                updateChartWithDuration('torqueChart', torqueChart, chartTimeLabels, torqueData, 'torqueXDuration');
            }
        }
        
        function updateChartWithDuration(chartId, chart, allLabels, allData, durationInputId) {
            if (!chart) return;
            
            // Get duration for this chart
            const durationInput = document.getElementById(durationInputId);
            const duration = durationInput ? parseFloat(durationInput.value) || chartXDuration : chartXDuration;
            
            // Get current time
            const currentTime = allLabels.length > 0 ? allLabels[allLabels.length - 1] : 0;
            const minTime = Math.max(0, currentTime - duration);
            
            // Convert to {x, y} format; only include points in the visible window to reduce Chart.js work
            const dataPoints = [];
            for (let i = 0; i < allLabels.length; i++) {
                if (allLabels[i] < minTime) continue;
                if (allData[i] !== null && allData[i] !== undefined) {
                    dataPoints.push({
                        x: allLabels[i],
                        y: allData[i]
                    });
                }
            }
            
            // Update chart data with all points in {x, y} format
            // When using {x, y} format, Chart.js uses x values from data points, not labels
            chart.data.labels = []; // Clear labels when using {x, y} format
            chart.data.datasets[0].data = dataPoints;
            
            // Set X-axis limits to show the duration window
            chart.options.scales.x.min = minTime;
            chart.options.scales.x.max = currentTime;
            
            // Force update with all data points
            chart.update('none');
        }

        function updateControlVisibility() {
            const mode = document.getElementById('controlMode').value;
            document.getElementById('posRow').style.display = mode === 'VEL' ? 'none' : 'flex';
            document.getElementById('velRow').style.display = 'flex';
            document.getElementById('stiffnessRow').style.display = mode === 'MIT' ? 'flex' : 'none';
            document.getElementById('dampingRow').style.display = mode === 'MIT' ? 'flex' : 'none';
            document.getElementById('torqueRow').style.display = mode === 'MIT' ? 'flex' : 'none';
            document.getElementById('velLimitRow').style.display = mode === 'FORCE_POS' ? 'flex' : 'none';
            document.getElementById('curLimitRow').style.display = mode === 'FORCE_POS' ? 'flex' : 'none';
        }

        async function sendMotorCommand() {
            if (!currentMotorId) {
                showStatus('Please select a motor first', 'error');
                return;
            }

            const toggle = document.getElementById('commandModeToggle');
            const isContinuous = toggle.checked;
            
            if (isContinuous) {
                // If continuous mode is selected, toggle it on/off
                if (continuousModeActive) {
                    // Stop continuous mode but preserve toggle state
                    stopContinuousMode(true);
                } else {
                    startContinuousMode();
                }
            } else {
                // Single mode - send once
                await sendMotorCommandInternal();
            }
        }

        function updateCommandMode() {
            // Ignore programmatic changes to the toggle
            if (isProgrammaticallyChangingToggle) {
                return;
            }
            
            const isContinuous = document.getElementById('commandModeToggle').checked;
            const frequencyRow = document.getElementById('frequencyRow');
            if (frequencyRow) {
                frequencyRow.style.display = isContinuous ? 'flex' : 'none';
            }
            
            // If switching to single mode, stop continuous if active
            if (!isContinuous && continuousModeActive) {
                stopContinuousMode();
            }
            // Don't auto-start continuous mode - user must press "Send Command" button
        }

        async function sendMotorCommandInternal() {
            if (!currentMotorId) return;
            if (commandSendInFlight) return;
            commandSendInFlight = true;
            try {
                const controlMode = document.getElementById('controlMode').value;
                const targetPosition = parseFloat(document.getElementById('targetPosition').value) || 0.0;
                const targetVelocity = parseFloat(document.getElementById('targetVelocity').value) || 0.0;
                const stiffness = parseFloat(document.getElementById('stiffness').value) || 0.0;
                const damping = parseFloat(document.getElementById('damping').value) || 0.0;
                const feedforwardTorque = parseFloat(document.getElementById('feedforwardTorque').value) || 0.0;
                const velocityLimit = parseFloat(document.getElementById('velocityLimit').value) || 0.0;
                const currentLimit = parseFloat(document.getElementById('currentLimit').value) || 0.0;

                const response = await fetch(`/api/motors/${currentMotorId}/command`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        control_mode: controlMode,
                        target_position: targetPosition,
                        target_velocity: targetVelocity,
                        stiffness: stiffness,
                        damping: damping,
                        feedforward_torque: feedforwardTorque,
                        velocity_limit: velocityLimit,
                        current_limit: currentLimit,
                    })
                });
                const data = await response.json();
                if (data.success) {
                    if (data.state) {
                        if (data.state.status_code === 0 && continuousModeActive) {
                            stopContinuousMode(true);
                            showStatus('Motor is disabled - stopped continuous mode', 'info');
                        } else {
                            applyMotorState(data.state); // state at control freq; charts render at 100 Hz
                        }
                    }
                    if (!continuousModeActive) showStatus('Command sent successfully', 'success');
                } else {
                    showStatus('Failed to send command: ' + data.error, 'error');
                    stopContinuousMode();
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
                stopContinuousMode();
            } finally {
                commandSendInFlight = false;
            }
        }

        function startContinuousMode() {
            if (!currentMotorId) {
                showStatus('Please select a motor first', 'error');
                // Uncheck toggle if motor not selected
                document.getElementById('commandModeToggle').checked = false;
                return;
            }

            continuousModeActive = true;
            const btn = document.getElementById('sendCommandBtn');
            btn.textContent = 'Stop Command';
            btn.classList.remove('btn-primary');
            btn.classList.add('btn-danger');
            
            // Command up to 1000 Hz; state in /command at same rate; chart render at 100 Hz
            const frequencyInput = document.getElementById('commandFrequency');
            const frequency = parseFloat(frequencyInput.value) || 50;
            const intervalMs = 1000 / frequency;
            chartUpdateInterval = intervalMs / 1000;
            
            // Reset chart start time when starting continuous mode
            chartStartTime = Date.now();
            
            // Update status message with current frequency
            const statusDiv = document.getElementById('continuousStatus');
            const currentFreqSpan = document.getElementById('currentFrequency');
            if (currentFreqSpan) {
                currentFreqSpan.textContent = frequency;
            }
            statusDiv.style.display = 'block';

            // Send commands at user-defined frequency
            continuousCommandInterval = setInterval(() => {
                sendMotorCommandInternal();
            }, intervalMs);

            // No motorStateInterval: state comes from /command response at control frequency

            showStatus(`Continuous mode started (${frequency}Hz)`, 'info');
        }

        function stopContinuousMode(preserveToggle = false) {
            continuousModeActive = false;
            if (continuousCommandInterval) {
                clearInterval(continuousCommandInterval);
                continuousCommandInterval = null;
            }
            
            // Stop auto-refresh feedback when continuous mode stops
            if (motorStateInterval) {
                clearInterval(motorStateInterval);
                motorStateInterval = null;
            }
            
            const btn = document.getElementById('sendCommandBtn');
            if (btn) {
                btn.textContent = 'Send Command';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-primary');
            }
            
            const statusDiv = document.getElementById('continuousStatus');
            if (statusDiv) {
                statusDiv.style.display = 'none';
            }
            
            const toggle = document.getElementById('commandModeToggle');
            if (toggle) {
                // Only uncheck toggle if not preserving it (e.g., when user explicitly stops)
                if (!preserveToggle) {
                    isProgrammaticallyChangingToggle = true;
                    toggle.checked = false;
                    isProgrammaticallyChangingToggle = false;
                } else {
                    // Explicitly ensure toggle stays checked when preserving
                    isProgrammaticallyChangingToggle = true;
                    toggle.checked = true;
                    isProgrammaticallyChangingToggle = false;
                }
            }
        }

        function updateContinuousFrequency() {
            // Only update if continuous mode is active
            if (!continuousModeActive) {
                return;
            }
            
            const frequencyInput = document.getElementById('commandFrequency');
            let frequency = parseFloat(frequencyInput.value) || 50;
            
            // Validate frequency range (commands up to 1000 Hz)
            if (frequency < 1) {
                frequency = 1;
                frequencyInput.value = 1;
            } else if (frequency > 1000) {
                frequency = 1000;
                frequencyInput.value = 1000;
            }
            
            const intervalMs = 1000 / frequency;
            chartUpdateInterval = intervalMs / 1000;

            const currentFreqSpan = document.getElementById('currentFrequency');
            if (currentFreqSpan) currentFreqSpan.textContent = frequency;

            if (continuousCommandInterval) clearInterval(continuousCommandInterval);
            continuousCommandInterval = setInterval(() => sendMotorCommandInternal(), intervalMs);
            // No motorStateInterval: state from /command at control frequency

            showStatus(`Command frequency updated to ${frequency}Hz`, 'info');
        }

        async function enableMotor() {
            if (!currentMotorId) {
                showStatus('Please select a motor first', 'error');
                return;
            }
            try {
                const response = await fetch(`/api/motors/${currentMotorId}/enable`, {method: 'POST'});
                const data = await response.json();
                if (data.success) {
                    showStatus('Motor enabled', 'success');
                    await updateMotorState();
                } else {
                    showStatus('Failed to enable motor: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            }
        }

        async function disableMotor() {
            if (!currentMotorId) {
                showStatus('Please select a motor first', 'error');
                return;
            }
            
            // Stop continuous mode when disabling motor, but preserve toggle state
            if (continuousModeActive) {
                stopContinuousMode(true); // preserveToggle = true
            }
            
            try {
                const response = await fetch(`/api/motors/${currentMotorId}/disable`, {method: 'POST'});
                const data = await response.json();
                if (data.success) {
                    showStatus('Motor disabled', 'success');
                    await updateMotorState();
                } else {
                    showStatus('Failed to disable motor: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            }
        }

        async function setZeroPosition() {
            if (!currentMotorId) {
                showStatus('Please select a motor first', 'error');
                return;
            }
            try {
                const response = await fetch(`/api/motors/${currentMotorId}/set-zero`, {method: 'POST'});
                const data = await response.json();
                if (data.success) {
                    showStatus('Zero position set', 'success');
                    await updateMotorState();
                } else {
                    showStatus('Failed to set zero: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            }
        }

        async function clearMotorError() {
            if (!currentMotorId) {
                showStatus('Please select a motor first', 'error');
                return;
            }
            try {
                const response = await fetch(`/api/motors/${currentMotorId}/clear-error`, {method: 'POST'});
                const data = await response.json();
                if (data.success) {
                    showStatus('Error cleared', 'success');
                    await updateMotorState();
                } else {
                    showStatus('Failed to clear error: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            }
        }

        function applyMotorState(state) {
            if (!state) return;
            const statusBadge = document.getElementById('motorStatus');
            if (statusBadge) {
                const status = state.status || 'UNKNOWN';
                const statusCode = state.status_code;
                statusBadge.textContent = `Status: ${status}`;
                statusBadge.className = 'status-badge ';
                if (statusCode === 1) statusBadge.className += 'enabled';
                else if (statusCode === 0) statusBadge.className += 'disabled';
                else statusBadge.className += 'error';
            }
            const fbPos = document.getElementById('fbPosition');
            if (fbPos) fbPos.textContent = state.pos !== undefined ? state.pos.toFixed(4) : '--';
            const fbVel = document.getElementById('fbVelocity');
            if (fbVel) fbVel.textContent = state.vel !== undefined ? state.vel.toFixed(4) : '--';
            const fbTorq = document.getElementById('fbTorque');
            if (fbTorq) fbTorq.textContent = state.torq !== undefined ? state.torq.toFixed(4) : '--';
            const fbMos = document.getElementById('fbMosTemp');
            if (fbMos) fbMos.textContent = state.t_mos !== undefined ? state.t_mos.toFixed(1) : '--';
            const fbRot = document.getElementById('fbRotorTemp');
            if (fbRot) fbRot.textContent = state.t_rotor !== undefined ? state.t_rotor.toFixed(1) : '--';
            updateCharts(state); // chart render throttled to chartMaxRenderHz (100) inside
        }

        async function updateMotorState() {
            if (!currentMotorId) return;
            if (motorStateUpdateInFlight) return;
            motorStateUpdateInFlight = true;
            try {
                const response = await fetch(`/api/motors/${currentMotorId}/state`);
                const data = await response.json();
                if (data.success && data.state) applyMotorState(data.state);
            } catch (error) {
                console.error('Error updating motor state:', error);
            } finally {
                motorStateUpdateInFlight = false;
            }
        }

        // Load register table on page load
        window.addEventListener('DOMContentLoaded', async () => {
            try {
                const response = await fetch('/api/register-table');
                const data = await response.json();
                window.registerTable = {};
                data.registers.forEach(reg => {
                    window.registerTable[reg.rid] = reg;
                });
            } catch (error) {
                console.error('Failed to load register table:', error);
            }
        });

        // Column resizer functionality
        (function() {
            const resizer = document.getElementById('columnResizer');
            const leftPanel = document.querySelector('.main-content-left');
            const rightPanel = document.querySelector('.main-content-right');
            const mainContent = document.querySelector('.main-content');
            
            if (!resizer || !leftPanel || !rightPanel) return;
            
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;
            
            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = leftPanel.offsetWidth;
                resizer.classList.add('active');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const deltaX = e.clientX - startX;
                const newWidth = startWidth + deltaX;
                const minWidth = 250;
                const maxWidth = mainContent.offsetWidth * 0.7;
                
                if (newWidth >= minWidth && newWidth <= maxWidth) {
                    leftPanel.style.width = newWidth + 'px';
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    resizer.classList.remove('active');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        })();
    </script>
</body>
</html>

